---
title: "Report on the use of passive acoustic monitoring for analysis of bird trends in Jasper National Park"
format:
  html:
    grid:
      margin-width: 300px
navbar: right
theme: cosmo
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: 
  - name: "Alex MacPhail"
    affiliation: "Biodiversity Pathways Ltd."
  - name: "Brenda Shepherd"
    affiliation: "Parks Canada"
editor: visual
bibliography: references.bib
nocite: '@*'
toc: true
toc-depth: 3
toc-expand: true
toc-location: left
styles: styles.css
github: https://github.com/biodiversitypathways/janp
---



![](janp.png){style="float:left`;" fig-alt="Photo of Jasper" fig-align="center"}



```{r}
#| label: Load packages and authenticate to WildTrax
#| include: false
#| echo: false
#| eval: true
#| warning: false
#| message: false

library(tidyverse)
library(leaflet)
library(wildrtrax)
library(sf)
library(ggridges)
library(scales)
library(kableExtra)
library(plotly)
library(DT)
library(lubridate)
library(spdep)
library(vegan)
library(ggrepel)
library(broom)
library(lme4)
library(pwr)
library(ggeffects)
library(modifiedmk)
library(MuMIn)
library(mgcv)
library(emmeans)
library(MASS)
library(pscl)
library(segmented)
library(glmmTMB)
library(FD)
library(shiny)

wt_auth()

load('janp.RData')
#save.image('janp.RData')
```

```{r}
#| label: Download data from WildTrax
#| warning: false
#| message: false
#| echo: false
#| eval: false
#| include: true

janp_aru_projects <- wildrtrax::wt_get_download_summary(sensor = 'ARU') |>
  filter(grepl('Jasper National Park', project)) |>
  dplyr::select(project_id) |>
  pull()

# All projects associated with a single-visit ARU deployment with no abundance cap
janp_0max <- wildrtrax::wt_get_download_summary(sensor = 'ARU') |>
  filter(grepl('Jasper NP - EI', project)) |>
  filter(!grepl('2021|2022',project)) |>
  dplyr::select(project_id) |>
  pull()

# All projects associated with a single-visit ARU deployment with an abundance cap of 3
janp_3max <- wildrtrax::wt_get_download_summary(sensor = 'ARU') |>
  filter(grepl('Jasper NP - EI', project)) |>
  filter(grepl('2021|2022',project)) |>
  dplyr::select(project_id) |>
  pull()

janp_project_lists <- list(
  multi_day = janp_aru_projects,
  single_visit_0_max = janp_0max,
  single_visit_3_max = janp_3max
)

janp_aru <- imap_dfr(
  janp_project_lists,
  ~ map_dfr(
      .x, 
      ~ wildrtrax::wt_download_report(
          project_id = .x,
          sensor_id = "ARU",
          weather_cols = TRUE,
          reports = "main"
        )
    ) |> mutate(data_type = .y, .after = organization) 
)

# Mountain Pine Beetle
mpb <- wildrtrax::wt_download_report(project_id = 2129, sensor_id = "ARU", weather_cols = TRUE, reports = "main")

# Bind legacy data with acoustic data
janp_main <- bind_rows(old_s_mean, janp_aru) |>
  group_by(location) |>
  fill(ecoregion, .direction = "down") |>
  ungroup() |>
  mutate(year = year(recording_date_time)) # Get year in as a variable

```



# Abstract

Since 2007, Jasper National Park has conducted passive acoustic monitoring as part of its ecological integrity monitoring program. After 17 years, we sought to analyze trends and extract insights from these data to inform ongoing monitoring and establish robust practices for future species monitoring. Our objective was to assess whether the abundance (count) of species and guild thresholds shifted by ±2.5% in the alpine and montane ecoregions, respectively. Data management and processing were conducted in WildTrax, where legacy datasets from multiple methodologies were combined and harmonized. We evaluated whether the sampling locations were independent and then conducted trend analyse to examine changes in species counts over time across guilds and ecoregions.

::: {.callout-note collapse="true" style="background-color: #f4f4f4; padding: 20px;"}
This report is dynamically generated, meaning its results may evolve with the addition of new data or further analyses. For the most recent updates, refer to the publication date and feel free to reach out to the authors.
:::

# Land Acknowledgement

We respectfully acknowledge that Jasper National Park is located in Treaty 6 and 8 as well as the traditional lands of the Anishinabe, Aseniwuche Winewak, Dene-zaa, Nêhiyawak, Secwépemc, Stoney Nakoda, Mountain Métis and Métis. We acknowledge the past, present, and future generations of these nations who continue to steward the land.

# Introduction

Human activities have been identified as key pressures and contributors to the global decline in forest wildlife (@allan2017recent). The repercussions of habitat fragmentation (@fahrig2003effects) and loss (@hanski2011habitat), climate change (@mantyka2012interactions, @sattar2021review, @abrahms2023climate), and increased access to sensitive areas exert direct and indirect pressures on forest biodiversity, particularly in managed regions in Canada (@lemieux2011state). Climate change and increasing wildfire activity in Alberta's Rocky Mountain Natural Region have significantly impacted montane bird monitoring; in 2023, two of the park's three long-term montane monitoring transects were affected by wildfires, while the third is currently undergoing wildfire risk reduction measures.

Since 2007, Jasper National Park initiated a program incorporating autonomous recording units (ARUs) for passive acoustic monitoring of the Park's vocalizing wildlife. ARUs are compact environmental sensors that are designed to passively record the environment (@aru-overview), capturing vocalizing species like birds and amphibians, which is growing in use across the globe (@lots-of-pam). This technology enables resource managers to conduct prolonged surveys with minimal human interference. The subsequent data collected by these units contribute valuable information to ecological integrity metrics such as species richness, diversity, occupancy, and trends over time. This data aids decision-making and management within the Park. Given the rapid and ease of accumulating data from these units, maintaining a high standard of data integrity is paramount to ensure future data interoperability and sharing. [WildTrax](https://www.wildtrax.ca) is an online platform developed by the [Alberta Biodiversity Monitoring Institute (**ABMI**)](https://abmi.ca) for users of environmental sensors to help addresses these big data challenges by providing solutions to standardize, harmonize, and share data.

The project will analyze Jasper’s bird point count data from 2007 to 2024, assessing trends in species and guild abundance while accounting for the clustering of survey points within transects. Separate analyses will be conducted for montane and sub-alpine and alpine ecoregions to align with Ecological Integrity reporting requirements, determining time-to-first-detection usability in analysis. To enhance accessibility and reproducibility, the findings will be presented in this online report with fully documented code, allowing future updates as data collection methods become standardized. Additionally, recommendations will be developed to refine data transcription priorities, improve annual reporting methods, and evaluate species guild classifications for long-term monitoring. The objectives of this report are to:

-   Describe the data management and processing procedures for the acoustic data collected from 2007 to 2024;
-   Comparing data processing methods on count of species and individuals heard on recordings;
-   Report on transects in montane/sub-alpine and alpine ecoregions, including time-to-first-detection where possible, with key metrics such as the percentage of bird species and guilds declining by ≥2.5% in both montane/sub-alpine and alpine regions.
-   Recommendations for prioritizing previous years’ data for re-transcription to 1SPT, determine the best approach for annual reporting, e.g. baseline comparisons or 10-year trend assessments, adjust methods for evaluating species trends against thresholds, and review guilds and traits used in assessments
-   Facilitate data publication to the public, resource managers, academic institutions, and any other relevant agencies

# Methods

## Data collection

Songbird data was collected using autonomous recording units (ARUs), deployed by field staff to capture one 10-minute recording per point count annually. Surveys were scheduled consistently each breeding season in June and early July, starting at dawn. Technicians walked transects containing ten points, each spaced at least 300 m apart to prevent duplicate detections and ensure independence of locations. At each location, the ARU is set up, and technicians move 10–20 m away to minimize disturbance, allowing at least 11 minutes of recording. Recordings were then clipped and organized to only include the 10-minute count.



```{r}
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| include: true
#| fig-align: center
#| fig-cap: Locations from Jasper National Park ARU Monitoring Program. Includes acoustic monitoring locations for other collaborative projects. Ecoregions were not classified for Other sites but only EI Monitoring locations.
#| label: fig-aru-monitoring-locations

janp_locs <- janp_main |>
  mutate(year = lubridate::year(recording_date_time)) |>
  dplyr::select(location, latitude, longitude, year, ecoregion) |>
  drop_na(latitude) |>
  distinct() |>
  dplyr::mutate(type = case_when(grepl('BAT', location) ~ "Bat", TRUE ~ "Bird")) |>
  sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326)

# Create mpb_in_janp
mpb_sf <- mpb |>
  mutate(year = year(recording_date_time)) |>
  dplyr::select(location, year, latitude, longitude) |>
  distinct() |>
  drop_na(latitude, longitude) |>
  sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326)
mpb_in_janp <- st_intersection(mpb_sf, janp_shp)

# Combine
janp_locs_map <- janp_locs |> 
  bind_rows(mpb_in_janp) |>
  dplyr::select(location, year, ecoregion, geometry) |>
  mutate(ecoregion = case_when(
    grepl("^JANP", location) ~ "Other ARU Monitoring", 
    grepl("MPB", location) ~ "Mountain Pine Beetle Project", 
    TRUE ~ ecoregion
  ))

# Generate summary table
locs_summary <- janp_locs_map |>
  st_drop_geometry() |>
  group_by(location, ecoregion, year) |>
  distinct() |>
  mutate(value = row_number()) |>
  ungroup() |>
  arrange(year) |>
  pivot_wider(names_from = year, values_from = value, values_fill = 0) |>
  rename('Location' = location)

# Map visualization
pal <- colorFactor(
  palette = "Set3", 
  domain = janp_locs_map$ecoregion
)

leaflet() %>%
  addTiles() %>%
  addPolygons(
    data = janp_shp,
    color = "black",
    weight = 1,
    fillOpacity = 0.4,
    popup = ~paste("Park:", adminAreaN)
  ) %>%
  addCircleMarkers(
    data = janp_locs_map,
    popup = ~paste("Location:", location, "<br>"),
    fillColor = ~pal(ecoregion),  
    fillOpacity = 1,
    color = "black", 
    radius = 6 
  ) %>%
  addLegend(
    "topright",
    pal = pal,
    values = janp_locs_map$ecoregion,
    title = "Ecoregion",
    opacity = 1
  ) %>%
  addMeasure(primaryLengthUnit = "meters", primaryAreaUnit = "sqmeters") %>%
  addMiniMap(position = "bottomleft")



```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| label: tbl-loc-summary
#| collapse: true
#| code-fold: true
#| tbl-cap: Locations surveyed across years. Ones indicated a deployment in that year for that location.

datatable(locs_summary, 
          options = list(
            searching = TRUE,  
            paging = TRUE,    
            pageLength = 10   
          )) |>
  formatStyle(columns = colnames(locs_summary), 
              backgroundColor = styleEqual(c("NA"), "lightgray"))  
```



## Location correlation {#sec-location-correction}

To assess spatial autocorrelation among bird survey locations in Jasper National Park, we examined the spatial relationship between survey points based on total species abundance per location and year. Given that survey points are approximately 300 meters apart, we used the `knearneigh()` function to identify the nearest neighbours within this threshold. This function calculates the closest neighboring survey points for each location. We then constructed a spatial weight matrix using the `knn2nb()` function and calculated Moran's *I* statistic using `moran.test` to determine whether spatial autocorrelation exists in the abundance of species across survey locations. A significant Moran's *I* suggests that survey locations are not independent and that spatial autocorrelation should be accounted for in further analyses. We also conducted further analyses grouping locations from each transect (`r paste(unique(janp_transects$transect_name), collapse = ", ")`).




```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: false
#| include: true
#| code-fold: true

# Create an object that defines the EI transects

janp_transects <- janp_main |>
  filter(!grepl('^JANP|^MPB',location)) |>
  filter(data_type %in% c("legacy","single_visit_3_max","single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F) |>
  dplyr::select(location) |>
  distinct() |>
  separate(location, into = c("transect_name", "station_id"), remove = FALSE)

```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: false
#| include: true
#| code-fold: true

janp_total_count <- janp_main %>%
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  wt_replace_tmtt(calc = "round") |>
  group_by(location, year, species_code) %>%
  summarise(n = max(individual_order, na.rm = TRUE), .groups = "drop") %>%
  group_by(location, year) %>%
  summarise(n = sum(n, na.rm = TRUE), .groups = "drop")

janp_locs_sf <- janp_locs %>%
  distinct(location, ecoregion, geometry) %>%
  inner_join(janp_total_count, by = "location") %>%
  st_as_sf()

janp_locs_sf <- janp_locs_sf %>%
  mutate(n = as.numeric(n)) %>%
  filter(!is.na(n))

coords <- st_coordinates(janp_locs_sf)
neighbours <- knn2nb(knearneigh(coords, k = 1, longlat = TRUE))
weights <- nb2listw(neighbours, style = "W", zero.policy = TRUE)
moran_test <- moran.test(janp_locs_sf$n, listw = weights, zero.policy = TRUE)

print(moran_test)

```



## Data management, processing and quality control

Before adopting WildTrax, analysts excluded the initial 20 seconds to 1.5 minutes of recordings to reduce human impact on detection probability, then logged the first detection time per species. Recordings are now uploaded as clean 10-minute files with the voice note and observer noise removed. Transcription methods varied over time @tbl-transcriptions, possibly affecting data consistency, from both a detectability and methodological standpoint. To ensure comparability, we examined the effect of using the mean and maximum abundance of species on trend. We used generalized linear mixed models (GLMM) using the `lme4` with package (@bates2015parsimonious) to also examine time-to-first detection and the differences it posed across years to account for detection probability differences, using location as random effect (`1 | location`). In WildTrax, individuals were counted by users scanning both the spectrogram and listening to the audio output. Tags were then drawn to encompass the signal within the methods indicated in each project (see @tbl-transcriptions and @fig-acousticprocessing). Transcribers also had site photos available (see @fig-visitphotos) to optimize their species identification by having *in situ* habitat context while processing.

![WildTrax Acoustic Processing Interface (Version 1)](acousticprocessing.png){#fig-acousticprocessing .float-left .fig-align-center}



```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| label: tbl-transcriptions
#| collapse: true
#| code-fold: true
#| tbl-cap: Transcription method by year with re-transcribed data being conducted from 2007 - 2012.

transcription_table <- tibble(
  Years = c("2007-2020", "2021-2022", "2023-2024", "2011"),
  `Transcription Method` = c(
    "0-3.33, 3.33-6.66, 6.66-10 min",
    "1 SPT - Species per task or recording (Every new individual is tagged within the 600s recording).",
    "1 SPT - Species per task or recording (Every new individual is tagged within the 600s recording).",
    "1 SPT - Species per task or recording (Every new individual is tagged within the 600s recording)."
  ),
  `Bin Method` = c(
    "Abundance re-starts for each 3.33-minute bin",
    "Unbinned on WildTrax* (Forced into bins for analysis)",
    "Unbinned on WildTrax* (Forced into bins for analysis)",
    "Unbinned on WildTrax*"
  ),
  `Method Details` = c(
    "No cap on abundance; abundance re-starts for each bin, no total abundance for the 10-min recording",
    "Counts per bin include only new individuals detected; individuals not re-counted across bins",
    "Counts per bin include only new individuals detected; individuals not re-counted across bins",
    "No cap on abundance"
  ),
  `Max Species` = c(
    "No cap",
    "Maximum of 3 individuals per 10-minute recording",
    "No cap",
    "No cap"
  )
)

transcription_table


# Render the datatable
datatable(transcription_table, 
          options = list(
            searching = TRUE,  
            paging = TRUE,    
            pageLength = 10   
          )) |>
  formatStyle(columns = colnames(transcription_table), 
              backgroundColor = styleEqual(c("NA"), "lightgray"))  


```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: tbl-verified
#| tbl-cap: Proportion of tags verified. NA evaluated tags were from legacy acoustic data, not including re-transcriptions for method comparison in WildTrax.

all_tags <- janp_main |>
  tally() |>
  pull()

verified_tags <- janp_main |>
  group_by(tag_is_verified) |>
  tally() |>
  ungroup() |>
  mutate(Proportion = round(n / all_tags,4)*100) |>
  rename("Count" = n) |>
  rename("Tag is verified" = tag_is_verified)

kable(verified_tags)

```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: tbl-tmtt
#| tbl-cap: Too many to count (TMTT) tags in WildTrax

tmtt_tags <- janp_main |>
  dplyr::select(location, recording_date_time, species_code, individual_count) |>
  distinct() |>
  filter(individual_count == "TMTT") |>
  mutate(recording_date_time = format(recording_date_time, "%Y-%m-%d %H:%M:%S"))

datatable(tmtt_tags, 
          options = list(
            searching = TRUE,  
            paging = TRUE,    
            pageLength = 10   
          )) |>
  formatStyle(columns = colnames(tmtt_tags), 
              backgroundColor = styleEqual(c("NA"), "lightgray"))

```



![Visit photos at PYRAMID-6](visitphotos.png){#fig-visitphotos .float-left .fig-align-center}

## Analyses

::: {.callout-warning collapse="true" style="background-color: #f4f4f4; padding: 20px;"}
For the purpose of these analyses abundance was defined as the count of individuals detected during point counts, rather than as a density x area relationship.
:::

We analyzed bird abundance trends in Jasper National Park from 2007 to 2024 across multiple scales, including individual species, specific locations, grouped transects, ecoregions, and functional guilds. This multi-level approach allowed us to assess patterns of abundance while accounting for ecological and functional groupings. All analyses took place in R 4.4.2 'Pile of Leaves'. Observations were first filtered to include only data from the EI monitoring sites containing ecoregional classification, with species being classified into functional guilds using an ecological trait database (see @tbl-guilds). Spatial clustering was addressed by grouping data by individual locations and transects (see Section [Location correlation](#sec-location-correlation)). To address potential biases in detectability, we used time-to-first-detection (TTFD) to model detectability differences across species, locations, and sampling methods, following the approach outlined in @solymos2013calibrating. By integrating offsets based on detectability into our final models, we controlled for variability in detection probabilities across methods, ensuring that observed trends in species abundance reflected true ecological patterns rather than methodological artifacts.

A redundancy analysis (RDA) was conducted using the `vegan` package (@vegan2025) to quantify the variation in community composition explained by ecoregions and to visualize species–ecoregion relationships with ordination plots (see @Rao1964). Species‑level observations were aggregated into a species‑by‑location matrix, with abundances recorded as the maximum count of each species at each location and transect. Ecoregions were categorized into Alpine and Montane groups, with the latter further divided into Upper Subalpine, Lower Subalpine, and Montane zones for all subsequent analyses. Differences in composition between Alpine and Montane groups were tested using permutational multivariate analysis of variance (PERMANOVA; @Anderson2001) on Bray–Curtis dissimilarities with 999 permutations under a reduced model.

Generalized linear mixed‑effects models (GLMMs, @bates2015parsimonious) were implemented in R using the `lme4` package (@bates2015lme4) to analyze abundance trends for 20 species (`r paste(mdm, collapse = ", ")` that were the most abundant and represented different guilds for the single-species analyses. Count data were modeled with a Poisson distribution or a negative binomial distribution when overdispersion was detected. Models included year, ecoregion, and their interaction as fixed effects, and location and transect as random effects to account for spatial clustering. Separate models were fitted for montane/subalpine versus alpine ecoregions to enable region‑specific inference. Model selection was based on Akaike’s Information Criterion (AIC; @akaike1974).

To evaluate trend significance we applied the Mann–Kendall test (@mann1945non, @hamed1998; non‑parametric and sensitive to monotonic trends [@birds6010014]) and estimated trend magnitude with Sen’s Slope (@Sen01121968; @dawood2017spatio) using the `mmkh()` function from the `modifiedmk` package. Functional diversity was quantified with Rao’s Q (@rao1982diversity; @laliberte2010adistance) using the `dbFD()` function in the `FD` package (@FDpackage) to examine shifts in guild‑level trait diversity over time. Species richness, representing the count of unique species, was summarized per location and plotted over time to assess local biodiversity dynamics (@fig-spp-rich-locs). Shannon’s diversity index, which incorporates species richness and evenness, was calculated annually to analyze temporal changes in community structure (@fig-shannon). These metrics provide complementary perspectives on biodiversity trends across locations and years.

Finally, breakpoint analysis was performed using the `segmented` package (@segmented2008) to identify significant shifts in abundance trends. Segmented models detected structural changes in trend slopes, ensuring that phase‑specific dynamics were not masked by overall trend estimates (see @smith2015change).




```{r}

#| eval: false
#| include: true

# Jasper species
mdm <- c("AMPI","AMRO","BRSP","CHSP","DEJU","GCKI","HETH","FOSP","OCWA","RCKI","SWTH","VATH","WAVI","WCSP","WTSP","GCSP","YRWA","RBNU","LISP","MOCH")

comp <- janp_main |>
  mutate(year = lubridate::year(recording_date_time)) |>
  group_by(location, recording_date_time) |>
  mutate(unique_data_types = n_distinct(data_type)) |>
  ungroup() |>
  filter(unique_data_types == 2, species_code %in% mdm) |>
  group_by(year, location, recording_date_time, data_type, species_code) |>
  summarise(mean = mean(individual_order)) |>
  ggplot(aes(x = data_type, y = mean, group = data_type)) +
  geom_boxplot() +
  facet_wrap(~species_code) +
  theme_bw()


```



# Results

## Ecoregional analysis

@fig-community shows the relationship between species and ecoregion. The RDA can determine how much variation in community composition is explained by these factors and visualize species-environment relationships through ordination plots. The PERMANOVA test was performed using Bray-Curtis dissimilarity to assess whether community composition significantly differed between ecoregion groups. The analysis revealed a significant difference in community composition between alpine and montane groups. The ecoregion grouping explained approximately 27.85% of the variation in community composition, while residual variation accounted for 72.15%. These findings indicate a substantial divergence in species composition between ecoregion groups for subsequent analyses looking at trend differences between these areas.



```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: fig-community
#| tbl-cap: Community matrix

comm_matrix <- janp_main |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  wt_replace_tmtt(calc = "round") |>
  dplyr::select(-ecoregion) |>
  inner_join(locs_summary, by = c("location" = "Location")) |>
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane")) |>
  group_by(location, ecoregion, species_code) |>
  summarise(individual_order = max(individual_order)) |>
  ungroup() |>
  pivot_wider(names_from = species_code, values_from = individual_order, values_fill = 0) |>
  drop_na(ecoregion)

multi_type <- comm_matrix  %>%
  dplyr::select(location, ecoregion) %>%
  distinct() %>%
  drop_na()

t3 <- rda(comm_matrix[,-c(1:2)] ~ ecoregion + location, data = multi_type)
t3scores <- scores(t3, display = "sites") %>%
as.data.frame() %>%
rownames_to_column("site") %>%
bind_cols(., multi_type)
t3vect <- scores(t3, display = "species") %>%
as.data.frame()

plot_RDA <- ggplot(data = t3scores, aes(x = RDA1, y = RDA2)) +
  geom_point(data = t3scores, aes(x = RDA1, y = RDA2, colour = ecoregion), 
             alpha = 0.7, size = 3, shape = 16) +
  stat_ellipse(data = t3scores, aes(colour = ecoregion), 
               linetype = 1, type = 'norm', level = 0.67, size = 1) +
  geom_vline(xintercept = 0, color = "#A19E99", linetype = 2, size = 1) +
  geom_hline(yintercept = 0, color = "#A19E99", linetype = 2, size = 1) +
  geom_segment(data = t3vect, aes(x = 0, y = 0, xend = RDA1, yend = RDA2), 
               arrow = arrow(length = unit(0.2, "cm")), size = 0.3) +
  geom_text_repel(data = t3vect, aes(x = RDA1, y = RDA2, label = rownames(t3vect)), 
                  size = 3, colour = "black", fontface = "italic", 
                  max.overlaps = 10, 
                  segment.color = "grey70") +
  theme_bw() +
  scale_colour_viridis_d(option = "cividis", end = 0.9) +
  labs(x = "RDA1", y = "RDA2", title = "RDA Plot of Ecoregions and Species", 
       colour = "Ecoregion") +
  theme(legend.position = "right", 
        legend.title = element_text(size = 10), 
        legend.text = element_text(size = 9), 
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))

plot_RDA
```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: permanova
#| tbl-cap: PERMANOVA test

comm_matrix_data <- comm_matrix[, -c(1:2)] # Exclude location and ecoregion columns
ecoregion_group <- comm_matrix$ecoregion

# Perform PERMANOVA
permanova_result <- adonis2(comm_matrix_data ~ ecoregion_group, data = comm_matrix, method = "bray", permutations = 999)

print(permanova_result)
```



## Guild analysis

Activity patterns across nesting, dietary and migratory guilds are illustrated in @fig-spp-activity-nesting, @fig-spp-activity-dietary, and @fig-spp-activity-migratory, respectively. A notable pattern emerges across all three guilds of the proportion of tags detected being detected later in the alpine ecoregion compared to the montane ecoregion.



```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| label: tbl-guilds
#| collapse: true
#| code-fold: true
#| tbl-cap: Guilds

guilds <- read_csv("jasper_guilds.csv")

datatable(guilds, 
          options = list(
            searching = TRUE,  
            paging = TRUE,    
            pageLength = 10   
          ))

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Seasonal detection activity of by nesting guild and ecoregion
#| label: fig-spp-activity-nesting
#| cap-location: margin
#| code-fold: true

guild_activity <- janp_main |>
  filter(data_type %in% c("legacy", "single_visit_3_max", "single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal", "amphibian", "abiotic", "insect", "unknown"), zerofill = T) |>
  dplyr::select(location, recording_date_time, species_common_name, species_code, individual_count) |>
  mutate(julian = lubridate::yday(recording_date_time),
         month = month(recording_date_time),
         year = factor(year(recording_date_time))) |>
  inner_join(guilds, by = "species_code") |>
  group_by(species_code) |>
  add_tally() |>
  ungroup() |>
  rename(`Nesting habitat` = "habitat_guild") |>
  group_by(julian, species_code) |>
  add_tally() |>
  ungroup() |>
  arrange(species_code) |>
  mutate(recording_date_time = as.POSIXct(recording_date_time)) |>
  mutate(species_code = factor(species_code, levels = sort(unique(species_code)))) |>
  inner_join(locs_summary, by = c("location" = "Location")) |>
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine", "Lower Subalpine", "Montane") ~ "Montane"))

ui <- fluidPage(
  selectInput("guild_type", "Choose Guild Type", 
              choices = c("trait" = "trait",
                          "Nesting habitat" = "habitat_guild", 
                          "Dietary Guild" = "dietary_guild", 
                          "Migratory Guild" = "migratory_guild"),
              selected = "habitat_guild"),  # Set default value
  plotOutput("guild_plot")
)

server <- function(input, output) {
  
  output$guild_plot <- renderPlot({    
    
    selected_column <- input$guild_type
    
    if (!(selected_column %in% colnames(guild_activity))) {
      stop("Selected guild type column not found in data.")
    }
    
    guild_data <- guild_activity |> 
      dplyr::select(julian, ecoregion, !!sym(selected_column)) |> 
      filter(!is.na(!!sym(selected_column)))
    
    ggplot(guild_data, aes(x = julian, y = !!sym(selected_column), fill = !!sym(selected_column))) + 
      geom_density_ridges(alpha = 0.7) +
      scale_fill_viridis_d(option = "cividis") +
      facet_wrap(~ecoregion) +
      theme_bw() +
      xlab("Day of Year") + 
      ylab("Species")
  })
  
}

# Run the Shiny app
shinyApp(ui = ui, server = server)

```

```{r}

library(dplyr)
library(tidyr)
library(FD)
library(Kendall)
library(lme4)
library(segmented)

abund_sp <- janp_main %>%
  group_by(location, year, species_code) %>%
  summarise(abund = n(), .groups = "drop") %>%
  pivot_wider(id_cols = c(location, year),
              names_from  = species_code,
              values_from = abund,
              values_fill = 0)

trait_df <- guilds %>%
  dplyr::select(species_code, dietary_guild, habitat_guild, migratory_guild) %>%
  distinct() %>%
  column_to_rownames("species_code")

trait_mat <- model.matrix(~ dietary_guild + habitat_guild + migratory_guild - 1,
                          data = trait_df)

a_mat <- abund_sp %>% dplyr::select(-location, -year) %>% as.matrix()

common <- intersect(colnames(a_mat), rownames(trait_mat))
a_mat2     <- a_mat[, common, drop = FALSE]
trait_mat2 <- trait_mat[common, , drop = FALSE]

nonzero   <- rowSums(a_mat2) > 0
a_mat3    <- a_mat2[nonzero, , drop = FALSE]
sites3    <- abund_sp[nonzero, c("location","year")]

fd <- dbFD(x = trait_mat2, a = a_mat3, calc.FRic = FALSE, calc.CWM = FALSE, messages = FALSE)

loc_year_rao <- sites3 %>%
  mutate(RaoQ = fd$RaoQ)

yearly_rao <- loc_year_rao %>%
  group_by(year) %>%
  summarise(meanRao = mean(RaoQ), .groups = "drop")

mk        <- mmkh(yearly_rao$meanRao, ci = 0.95)
lm_trend  <- lm(meanRao ~ year, data = yearly_rao)
mix_trend <- lmer(RaoQ ~ year + (1|location), data = loc_year_rao)
seg       <- segmented(lm(meanRao ~ year, data = yearly_rao), seg.Z = ~ year)

list(
  yearly_rao   = yearly_rao,
  mann_kendall = mk,
  lm_trend     = summary(lm_trend),
  mix_trend    = summary(mix_trend),
  breakpoints  = seg$psi
)


```



Rao’s Q averaged between about 8.2 and 10.5 across survey locations, with a clear upward tendency over time. The non‑parametric Mann–Kendall test gave a Kendall’s τ of 0.32 (p ≈ 0.07), indicating a positive but marginally non‑significant monotonic increase in functional diversity. A simple linear regression of mean Rao’s Q against year yielded a slope of 0.051 units per year (p ≈ 0.06), again suggesting an upward trend that narrowly misses the conventional 0.05 significance threshold. When we account for repeated measures at each location via a mixed‑effects model (random intercepts by location), the year effect becomes highly significant (slope = 0.058 Rao’s Q units per year; t ≈ 4.3), demonstrating that functional diversity has increases when location‑level variation is considered. Finally, breakpoint analysis identifies a shift around 2009, suggesting that functional diversity was relatively low and stable from 2007–2009, then rose to more variable but generally higher values from 2010 onward.

## Species richness and diversity trends

Species richness per location is at @fig-spp-rich-locs and Shannon's diversity index over years at @fig-shannon. Overall, both richness and diversity were stable across years.



```{r}
#| warning: false
#| message: false
#| echo: true
#| eval: true
#| include: true
#| fig-align: center
#| fig-cap: Species richness by year
#| label: fig-spp-rich-locs
#| cap-location: bottom
#| code-fold: true

spp_rich_location <- janp_main |>
  filter(data_type %in% c("legacy","single_visit_3_max","single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F) |>
  dplyr::select(location, year, species_code) |>
  distinct() |>
  group_by(location, year) |>
  summarise(species_count = n_distinct(species_code)) |>
  ungroup() |>
  inner_join(locs_summary, by = c("location" = "Location")) |>
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane"))

spp_rich_location |>
  ggplot(aes(x=as.factor(year), y=species_count, fill=year)) +
  geom_boxplot() +
  geom_point(alpha = 0.7, colour = "grey") +
  geom_smooth(method = "lm") +
  theme_bw() +
  facet_wrap(~ecoregion) +
  scale_fill_viridis_c(option = "cividis") +
  xlab('Year') + ylab('Species richness per location') +
  coord_flip()

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Shannon diversity index over years
#| label: fig-shannon
#| cap-location: bottom
#| code-fold: true

shannon_d <- janp_main |> 
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F) |>
  inner_join(wt_get_species() |> dplyr::select(species_code, species_class, species_order), by = "species_code") |>
  dplyr::select(location, recording_date_time, species_code, species_common_name, individual_order, individual_count) |>
  distinct() |>
  group_by(location, recording_date_time, species_code, species_common_name) |>
  summarise(count = max(individual_order)) |>
  ungroup() |>
  pivot_wider(names_from = species_code, values_from = count, values_fill = 0) |>
  pivot_longer(cols = -(location:species_common_name), names_to = "species", values_to = "count") |>
  group_by(location, year = year(recording_date_time), species) |>
  summarise(total_count = sum(count)) |>
  ungroup() |>
  group_by(location, year) |>
  summarise(shannon_index = diversity(total_count, index = "shannon")) |>
  ungroup() |>
  ggplot(aes(x = factor(year), y = shannon_index, fill = factor(year))) +
  geom_boxplot() +
  geom_point(alpha = 0.6, colour = "grey") +
  labs(x = "Year",
       y = "Shannon diversity index per location") +
  theme_bw() +
  guides(fill = guide_legend(title = "Year")) +
  scale_fill_viridis_d(alpha = 0.8, option = "cividis")

shannon_d
```



## Abundance trend analysis

The trend in species abundance is summarized in @fig-normalized-count-mdm-year.



```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-width: 8
#| fig-height: 8
#| fig-cap: Normalized count abundance of mean number of medium-distance migrants by year
#| label: fig-normalized-count-mdm-year
#| cap-location: margin

z <- locs_summary |>
  rowwise() |>
  mutate(sum = sum(across(`2007`:`2024`))) |>
  filter(sum == 17)

# Jasper species
mdm <- c("AMPI","AMRO","BRSP","CHSP","DEJU","GCKI","HETH","FOSP","OCWA","RCKI","SWTH","VATH","WAVI","WCSP","WTSP","GCSP","YRWA","RBNU","LISP","MOCH")

tot_a <- janp_main |>
  filter(data_type %in% c("legacy","single_visit_3_max","single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F)

prop_tidy <- nrow(tot_a) / nrow(janp_main)

tot_a_mdm <- tot_a |>
  filter(species_code %in% mdm)

prop_a <- nrow(tot_a_mdm) / nrow(tot_a)

plot_mdm <- 
  tot_a_mdm |>
  mutate(year = year(recording_date_time)) |>
  dplyr::select(location, data_type, year, species_code, individual_order, individual_count) |>
  group_by(location, data_type, year, species_code) |>
  summarise(individual_order = mean(individual_order)) |>
  ungroup() |>
  mutate(year = round(year,0)) |>
  group_by(year, data_type, species_code) |>
  summarise(
    total_abundance = sum(individual_order),  
    sample_size = n_distinct(location)
  ) |>
  ungroup() |>
  mutate(normalized_count = total_abundance / sample_size) |>
  inner_join(wt_get_species() |> dplyr::select(species_code, species_common_name), by = "species_code") |>
  inner_join(guilds, by = "species_common_name")

plot_mdm |>
  ggplot(aes(x = year, y = normalized_count, colour = dietary_guild)) +
  geom_point() + 
  geom_smooth(aes(x = as.numeric(as.character(year))), method = "lm") + 
  scale_colour_viridis_d(option = "cividis", alpha = 0.7) +
  theme_bw() +
  facet_wrap(~species_code.x) +
  labs(x = "Year", y = "Normalized count of mean number of individuals per location")

plot_mdm |>
  ggplot(aes(x = year, y = normalized_count, colour = migratory_guild)) +
  geom_point() + 
  geom_smooth(aes(x = as.numeric(as.character(year))), method = "lm") + 
  scale_colour_viridis_d(option = "cividis", alpha = 0.7) +
  theme_bw() +
  facet_wrap(~species_code.x) +
  labs(x = "Year", y = "Normalized count of mean number of individuals per location")

plot_mdm |>
  ggplot(aes(x = year, y = normalized_count, colour = habitat_guild)) +
  geom_point() + 
  geom_smooth(aes(x = as.numeric(as.character(year))), method = "lm") + 
  scale_colour_viridis_d(option = "cividis", alpha = 0.7) +
  theme_bw() +
  facet_wrap(~species_code.x) +
  labs(x = "Year", y = "Normalized count of mean number of individuals per location")

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| label: tbl-normalized-count-mdm-year
#| collapse: true
#| code-fold: true
#| tbl-cap: Linear models of species trends using normalized mean count per location

datatable(
  plot_mdm |>
    group_by(species_code.x) |>
    summarise(models = list(
      lm(normalized_count ~ year + data_type, data = cur_data())
    )) |>
    mutate(model_summary = map(models, tidy)) |>
    unnest(model_summary) |>
    dplyr::select(-models) |>
    mutate(across(where(is.numeric), round, 2)),
  options = list(
    searching = TRUE,
    paging = TRUE,
    pageLength = 10
  )
)

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Annual count of medium-distance migrants 
#| label: fig-annual-count
#| cap-location: bottom
#| code-fold: true

# Aggregate and normalize data
count_annual_mdm <- tot_a_mdm |>
  mutate(ecoregion = case_when(
    ecoregion == "Alpine" ~ "Alpine",
    ecoregion %in% c("Upper Subalpine", "Lower Subalpine", "Montane") ~ "Montane"
  )) |>
  mutate(year = year(recording_date_time)) |>
  dplyr::select(location, ecoregion, year, species_code, individual_order, individual_count) |>
  group_by(location, ecoregion, year, species_code) |>
  summarise(individual_order = max(individual_order), .groups = "drop") |>
  mutate(year = round(year, 0)) |>
  group_by(ecoregion, year) |>
  summarise(sum_year = sum(individual_order), 
            sample_size = n(), 
            .groups = "drop") |>
  mutate(normalized_count = sum_year / sample_size)

# Run separate models for each ecoregion
lm_results <- count_annual_mdm %>%
  group_split(ecoregion) %>%
  map_df(~ {
    model <- lm(normalized_count ~ year, data = .x)
    tibble(
      ecoregion = unique(.x$ecoregion),
      slope = coef(model)[2],
      p_value = summary(model)$coefficients[2, 4]
    )
  })

# Merge results back
count_annual_mdm <- count_annual_mdm %>%
  left_join(lm_results, by = "ecoregion")

# Plot
ggplot(count_annual_mdm, aes(x = year, y = normalized_count, colour = ecoregion)) +
  geom_smooth(method = "lm") +
  geom_point(size = 2) +
  scale_colour_manual(values = c("Alpine" = "#71706D", "Montane" = "#001F42")) +
  labs(x = "Year", y = "Normalized Count of Medium-Distance Migrants", colour = "Ecoregion") +
  scale_x_continuous(breaks = unique(count_annual_mdm$year)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  geom_text(data = lm_results, 
            aes(x = 2008, 
                y = ifelse(ecoregion == "Alpine", 1.7, 1.55),  # Offset text
                label = paste0("Ecoregion: ", ecoregion, 
                               "\nSlope: ", round(slope, 2), 
                               "\nP-value: ", round(p_value, 4))),
            size = 3, hjust = 0, vjust = 1, show.legend = FALSE)


```



The mean time to first detection was stable throughout the years and methods used (see @fig-mean-time-ttfd)



```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Mean time of first detection across years
#| label: fig-mean-time-ttfd
#| cap-location: bottom
#| code-fold: true

mean_ttfd <- janp_main |>
  filter(data_type %in% c("legacy","single_visit_3_max","single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  group_by(year, location, data_type, species_code) |>
  summarise(mean_detection = mean(detection_time, na.rm = TRUE)) |>
  ungroup() |>
  mutate(mean_detection_log = log(mean_ttfd$mean_detection + 1))

# mean_ttfd |>
#   ggplot(aes(x = factor(year), y = mean_detection, fill = factor(year))) +  # Convert year to factor
#   geom_boxplot() +
#   theme_bw() +
#   xlab("Year") + ylab("Mean time of first detection") +
#   scale_fill_viridis_d(option = "cividis")

# ggplot(mean_ttfd, aes(x = factor(year), y = mean_detection, fill = data_type)) +
#   geom_boxplot() +
#   facet_wrap(~ data_type) +
#   theme_bw() +
#   xlab("Year") + ylab("Mean time to first detection") +
#   scale_fill_viridis_d(option = "cividis")

mean_ttfd_model_mixed <- lmer(mean_detection ~ year + data_type + (1 | species_code) + (1 | location), data = mean_ttfd)
reduced_model_log <- lmer(mean_detection_log ~ data_type + (1 | species_code) + (1 | location), data = mean_ttfd)
model_ttfd_anova <- anova(mean_ttfd_model_mixed, reduced_model)
p_ttfd <- model_ttfd_anova$`Pr(>Chisq)`[2]

# glmm_nb <- glmer.nb(mean_detection ~ data_type + (1 | species_code) + (1 | location), data = mean_ttfd)
# fixed_effects <- fixef(glmm_nb)

 prediction_data <- data.frame(
  data_type = c("legacy", "single_visit_0_max", "single_visit_3_max")
)

# Calculate predicted mean_detection values
prediction_data <- prediction_data %>%
  mutate(predicted_mean_detection = exp(fixed_effects[1] + 
                                          case_when(
                                            data_type == "legacy" ~ 0,
                                            data_type == "single_visit_0_max" ~ fixed_effects["data_typesingle_visit_0_max"],
                                            data_type == "single_visit_3_max" ~ fixed_effects["data_typesingle_visit_3_max"]
                                          )))

# Plot the predicted values
ggplot(prediction_data, aes(x = data_type, y = predicted_mean_detection, fill = data_type)) +
  geom_bar(stat = "identity", color = "black") +
  theme_bw() +
  xlab("Data Type") +
  ylab("Predicted Mean Detection Time") +
  scale_fill_viridis_d(option = "cividis") +
  ggtitle("Predicted Mean Detection Time by Data Type")

# preds <- ggpredict(reduced_model, terms = c("data_type"))
# ggplot(preds, aes(x = x, y = predicted, color = group)) +
#   geom_line() +
#   geom_point() +
#   theme_minimal() +
#   labs(x = "Year", y = "Predicted mean detection time", color = "Data Type")
# emmeans_reduced <- emmeans(reduced_model_log, pairwise ~ data_type)
# plot(emmeans_reduced$emmeans)
# qqnorm(residuals(reduced_model_log))
# qqline(residuals(reduced_model_log))

```



Analysis setup for trend.



```{r}
#| warning: false
#| echo: true
#| eval: false
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Analysess
#| label: fig-analyses
#| cap-location: bottom
#| code-fold: true

janp_main_mean <- bind_rows(old_s_mean, janp_aru) |>
  group_by(location) |>
  fill(ecoregion, .direction = "down") |>
  ungroup() |>
  mutate(year = year(recording_date_time))

janp_main_max <- bind_rows(old_s_max, janp_aru) |>
  group_by(location) |>
  fill(ecoregion, .direction = "down") |>
  ungroup() |>
  mutate(year = year(recording_date_time))

janp_main_3_mean <- bind_rows(old_s_3_mean, janp_aru) |>
  group_by(location) |>
  fill(ecoregion, .direction = "down") |>
  ungroup() |>
  mutate(year = year(recording_date_time))

---------- # Mean all
  
compare_means <- function(data) {
    data %>%
      group_by(species_code) %>%
      summarise(
        wilcox_p = wilcox.test(mean ~ data_type, data = cur_data())$p.value
      )
  }

# Apply the function to each scenario
results_mean <- janp_main_mean |>
  group_by(location, recording_date_time) |>
  mutate(unique_data_types = n_distinct(data_type)) |>
  ungroup() |>
  filter(unique_data_types == 2, species_code %in% mdm) |>
  group_by(year, location, recording_date_time, data_type, species_code) |>
  summarise(mean = mean(individual_order)) |>
  compare_means()

results_max <- janp_main_max |>
  group_by(location, recording_date_time) |>
  mutate(unique_data_types = n_distinct(data_type)) |>
  ungroup() |>
  filter(unique_data_types == 2, species_code %in% mdm) |>
  group_by(year, location, recording_date_time, data_type, species_code) |>
  summarise(mean = mean(individual_order)) |>
  compare_means()

results_3_mean <- janp_main_3_mean |>
  group_by(location, recording_date_time) |>
  mutate(unique_data_types = n_distinct(data_type)) |>
  ungroup() |>
  filter(unique_data_types == 2, species_code %in% mdm) |>
  group_by(year, location, recording_date_time, data_type, species_code) |>
  summarise(mean = mean(individual_order)) |>
  compare_means()

# Combine results for comparison
all_results <- bind_rows(
  results_mean %>% mutate(scenario = "mean"),
  results_max %>% mutate(scenario = "max"),
  results_3_mean %>% mutate(scenario = "3_mean")
) |>
  arrange(scenario)

-----------#
  
  
full_grid <- janp_main_mean %>%
  distinct(year, data_type, location, recording_date_time) %>%
  expand_grid(species_code = unique(janp_main_mean$species_code))

all_species_data <- janp_main_mean %>%
  filter(!(data_type == "single_visit_0_max|multi_day" & year < 2023)) %>%
  group_by(year, data_type, location, recording_date_time, species_code) %>%
  summarise(mean = mean(individual_order, na.rm = TRUE), .groups = "drop") %>%
  right_join(full_grid, by = c("year", "data_type", "location", "recording_date_time", "species_code")) %>%
  mutate(mean = ifelse(is.na(mean), 0, mean))

results <- all_species_data %>%
  group_by(species_code) %>%
  summarise(
    trend_vi = list(mmkh(mean, ci = 0.95)),
    .groups = "drop"
  ) %>%
  mutate(
    vi_p_trend = map_dbl(trend_vi, ~ if ("newPvalue" %in% rownames(as.data.frame(.x))) {
      as.data.frame(.x)["newPvalue", "mmkh.mean", drop = TRUE]
    } else {
      NA_real_
    }),
    vi_z = map_dbl(trend_vi, ~ if ("CorrectedZc" %in% rownames(as.data.frame(.x))) {
      as.data.frame(.x)["CorrectedZc", "mmkh.mean", drop = TRUE]
    } else {
      NA_real_
    }),
    vi_sens = map_dbl(trend_vi, ~ if ("Sensslope" %in% rownames(as.data.frame(.x))) {
      as.data.frame(.x)["Sensslope", "mmkh.mean", drop = TRUE]
    } else {
      NA_real_
    })
  ) %>%
  dplyr::select(species_code, vi_p_trend, vi_z, vi_sens)



```



# Discussion



```{r}
#| eval: false
#| include: true

tot_a <- janp_main |>
  filter(data_type %in% c("legacy","single_visit_3_max","single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F)

mP0 <- glm(abundance ~ 1, data = results, family = poisson)
mP1 <- glm(abundance ~ year, data = results, family = poisson)
mP2 <- glm(abundance ~ year + data_type, data = results, family = poisson)
mP3 <- gam(abundance ~ s(year), data = results, family = poisson)
mP4 <- gam(abundance ~ s(year) + data_type, data = results, family = poisson)
mP5 <- glm.nb(abundance ~ year, data = results)
mP6 <- glm.nb(abundance ~ year + data_type, data = results)
mP7 <- zeroinfl(abundance ~ year | 1, data = results, dist = "poisson")
mP8 <- zeroinfl(abundance ~ year | 1 + data_type, data = results, dist = "poisson")
mP9 <- zeroinfl(abundance ~ year | 1, data = results, dist = "negbin")
mP10 <- zeroinfl(abundance ~ year | 1 + data_type, data = results, dist = "negbin")
mP11 <- glmmTMB(abundance ~ year + (1 | location), ziformula = ~1, family = poisson(), data = results)
mP12 <- glmmTMB(abundance ~ year + (1 | location) + data_type, ziformula = ~1, family = poisson(), data = results)
mP13 <- glmer(abundance ~ year + (1 | location), data = results, family = "poisson")
mP14 <- glmer(abundance ~ year + data_type + (1 | location), data = results, family = "poisson")


AIC(mP0, mP1, mP2, mP3, mP4, mP5, mP6, mP7, mP8, mP9, mP10, mP11, mP12, mP13, mP14) |>
  arrange(AIC)
BIC(mP0, mP1, mP2, mP3, mP4, mP5, mP6, mP7, mP8, mP9, mP10, mP11, mP12, mP13, mP14)
model.sel(mP0, mP1, mP2, mP3, mP4, mP5, mP6, mP7, mP8, mP9, mP10, mP11, mP12, mP13, mP14)

# Add prediction with confidence intervals
prediction <- predict(mP14, type = "response", se.fit = TRUE)

# Add predictions and confidence intervals to the results dataset
results <- results %>%
  mutate(
    predicted = prediction$fit,
    lower_ci = prediction$fit - 1.96 * prediction$se.fit,
    upper_ci = prediction$fit + 1.96 * prediction$se.fit
  )

# Summarize raw data
raw_summary <- results %>%
  group_by(year) %>%
  summarize(mean_abundance = mean(abundance, na.rm = TRUE))

# Summarize predictions and confidence intervals
predicted_summary <- results %>%
  group_by(year) %>%
  summarize(
    mean_predicted = mean(predicted, na.rm = TRUE),
    lower_ci = mean(lower_ci, na.rm = TRUE),
    upper_ci = mean(upper_ci, na.rm = TRUE)
  )

# Plot with confidence intervals
ggplot() +
  # Raw data points
  geom_jitter(data = results, aes(x = year, y = abundance), alpha = 0.1) +
  geom_point(data = raw_summary, aes(x = year, y = mean_abundance), color = "blue", size = 2, alpha = 0.7) +
  # Model predictions
  geom_line(data = predicted_summary, aes(x = year, y = mean_predicted), color = "red", size = 1) +
  # Confidence intervals
  geom_ribbon(
    data = predicted_summary,
    aes(x = year, ymin = lower_ci, ymax = upper_ci),
    fill = "red", alpha = 0.2
  ) +
  labs(
    title = "Trend of Abundance Over Years with Confidence Intervals",
    x = "Year",
    y = "Mean Abundance"
  ) +
  theme_minimal()

```

```{r}
#ecoregions

results <- tot_a
```



## Future incorporation of multi-day deployment datasets

As noted in @fig-locations, there are many more historical and ongoing monitoring datasets that do fall outside the realm of the typical EI monitoring.


