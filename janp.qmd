---
title: "Report on the use of passive acoustic monitoring for analysis of bird trends in Jasper National Park"
format:
  html:
    grid:
      margin-width: 300px
navbar: right
theme: cosmo
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: 
  - name: "Alex MacPhail"
    affiliation: "Biodiversity Pathways Ltd."
  - name: "Brenda Shepherd"
    affiliation: "Jasper National Park, Parks Canada"
  - name: "Nina Veselka"
    affiliation: "Jasper National Park, Parks Canada"
editor: visual
bibliography: references.bib
nocite: '@*'
toc: true
toc-depth: 3
toc-expand: true
prefer-html: true
toc-location: left
styles: styles.css
github: https://github.com/biodiversitypathways/janp
---

![](assets/janp.png){style="float:left`;" fig-alt="Photo of Jasper" fig-align="center"}

```{r}
#| label: Load packages and authenticate to WildTrax
#| include: false
#| echo: false
#| eval: true
#| warning: false
#| message: false

library(tidyverse)
library(leaflet)
library(wildrtrax)
library(sf)
library(ggridges)
library(scales)
library(kableExtra)
library(ggrepel)
library(DT)
library(lubridate)
library(vegan)
library(lme4)
library(modifiedmk)
library(FD)
library(detect)
library(segmented)
library(fs)

wt_auth()

load('janp.RData')
#save.image('janp.RData')
```


```{r}
#| label: Download data from WildTrax
#| warning: false
#| message: false
#| echo: false
#| eval: false
#| include: true

janp_aru_projects <- wildrtrax::wt_get_projects(sensor = 'ARU') |>
  filter(grepl('Jasper National Park', project)) |>
  dplyr::select(project_id) |>
  pull()

# All projects associated with a single-visit ARU deployment with no abundance cap
janp_0max <- wildrtrax::wt_get_projects(sensor = 'ARU') |>
  filter(grepl('Jasper NP - EI', project)) |>
  filter(!grepl('2021|2022',project)) |>
  dplyr::select(project_id) |>
  pull()

# All projects associated with a single-visit ARU deployment with an abundance cap of 3
janp_3max <- wildrtrax::wt_get_projects(sensor = 'ARU') |>
  filter(grepl('Jasper NP - EI', project)) |>
  filter(grepl('2021|2022',project)) |>
  dplyr::select(project_id) |>
  pull()

janp_project_lists <- list(
  #multi_day = janp_aru_projects,
  single_visit_0_max = janp_0max,
  single_visit_3_max = janp_3max
)

janp_aru <- imap_dfr(
  janp_project_lists,
  ~ map_dfr(
      .x, 
      ~ wildrtrax::wt_download_report(
          project_id = .x,
          sensor_id = "ARU",
          reports = "main"
        )
    ) |> mutate(data_type = .y, .after = organization) 
)

rel_wea <- imap_dfr(
  janp_project_lists,
  ~ map_dfr(
      .x, 
      ~ wildrtrax::wt_download_report(
          project_id = .x,
          sensor_id = "ARU",
          reports = "recording",
          max_seconds = 600
        )
    ) |> mutate(data_type = .y, .after = organization) 
)

# Mountain Pine Beetle
mpb <- wildrtrax::wt_download_report(project_id = 2129, sensor_id = "ARU", reports = "main")

# Bind legacy data with acoustic data
janp_main <- bind_rows(old_s_max, janp_aru) |>
  group_by(location) |>
  fill(ecoregion, .direction = "down") |>
  ungroup() |>
  mutate(location = case_when(grepl("^VALLEY-",location) ~ gsub("VALLEY-","VALLEY5-",location), TRUE ~ location),
         ecoregion = case_when(grepl("COTTONWOOD|MUSHROOM|VALLEY5",location) & is.na(ecoregion) ~ "Montane", TRUE ~ ecoregion),
         year = year(recording_date_time)) # Get year in as a variable

```

::: {.callout-note collapse="true" style="background-color: #f4f4f4; padding: 20px;"}
This report is dynamically generated, meaning its results may evolve with the addition of new data or further analyses. For the most recent updates, refer to the publication date and feel free to reach out to the authors.
:::

# Abstract

Since 2007, Jasper National Park has conducted passive acoustic monitoring as part of its ecological integrity monitoring program. The 18 years of data were analyzed to identify trends and extract insights that inform ongoing monitoring and strengthen future species monitoring practices. The analysis assessed whether species and guild abundances shifted by ±2.5% in the alpine and montane ecoregions. Data were managed and processed in WildTrax, combining and harmonizing legacy datasets from multiple methodologies. Sampling locations were tested for independence, and trend analyses quantified changes in species counts over time across guilds and ecoregions.

# Land Acknowledgement

We respectfully acknowledge that Jasper National Park is located in Treaty 6 and 8 as well as the traditional lands of the Anishinabe, Aseniwuche Winewak, Dene-zaa, Nêhiyawak, Secwépemc, Stoney Nakoda, Mountain Métis and Métis. We acknowledge the past, present, and future generations of these nations who continue to steward the land.

# Introduction

Human activities have been identified as key pressures and contributors to the global decline in forest wildlife (@allan2017recent). The repercussions of habitat fragmentation (@fahrig2003effects) and loss (@hanski2011habitat), climate change (@mantyka2012interactions, @sattar2021review, @abrahms2023climate), and increased access to sensitive areas exert direct and indirect pressures on forest biodiversity, particularly in managed regions in Canada (@lemieux2011state). Climate change and increasing wildfire activity in Alberta's Rocky Mountain Natural Region have significantly impacted montane bird monitoring; in 2023, two of the park's three long-term montane monitoring transects were affected by wildfires, while the third is currently undergoing wildfire risk reduction measures. Since 2007, Jasper National Park initiated a program incorporating passive acoustic monitoring of the Park's vocalizing wildlife. ARUs are compact environmental sensors that are designed to passively record the environment (@aru-overview), capturing vocalizing species like birds and amphibians, which is growing in use across the globe (@lots-of-pam). This technology enables resource managers to conduct prolonged surveys with minimal human interference, but also to create a permanent, archiveable recording of the soundscape. The subsequent data collected by these units contribute valuable information to ecological integrity metrics such as species richness, diversity, occupancy, and trends of species and human activities in National Parks over time. This data can aid in decision-making and management within the Park. Given the rapid and ease of accumulating data from these units, maintaining a high standard of data integrity is paramount to ensure future data interoperability and sharing.

This project aims to analyze Jasper’s passive acoustic monitoring data from 2007 to 2024, assessing trends in species and guild abundance while accounting for the clustering of survey points within transects. Separate analyses will be conducted for montane and sub-alpine and alpine ecoregions to align with Ecological Integrity reporting requirements, determining time-to-first-detection usability in analysis. To enhance accessibility and reproducibility, the findings will be presented in this online report with fully documented code, allowing future updates as data collection methods become standardized. Additionally, recommendations will be developed to refine data transcription priorities, improve annual reporting methods, and evaluate species guild classifications for long-term monitoring. The objectives of this report are to:

-   Describe the data management and processing procedures for the acoustic data collected from 2007 to 2025;
-   Comparing data processing methods on count of species and individuals heard on recordings;
-   Report on transects in montane/sub-alpine and alpine ecoregions, including time-to-first-detection where possible, with key metrics such as the percentage of bird species and guilds declining by ≥2.5% in both montane/sub-alpine and alpine regions.
-   Recommendations for prioritizing previous years’ data for re-transcription to 1SPT, determine the best approach for annual reporting, e.g. baseline comparisons or 10-year trend assessments, adjust methods for evaluating species trends against thresholds, and review guilds and traits used in assessments
-   Facilitate data publication to the public, resource managers, academic institutions, and any other relevant agencies

# Methods

## Data collection

Songbird data was collected using autonomous recording units (ARUs), deployed by field staff to capture one 10-minute recordings per point count annually. Surveys were scheduled consistently each breeding season in June and early July, starting at dawn. Technicians walked transects containing ten points, each spaced at least 300 m apart to prevent duplicate detections and ensure independence of locations. At each location, the ARU is set up, and technicians move 10–20 m away to minimize disturbance, allowing at least 11 minutes of recording for voice notes and activation and de-activation of the units.

```{r}
#| echo: false
#| eval: false
#| warning: false
#| message: false
#| include: true

janp_shp <- read_sf("assets/National_Parks_and_National_Park_Reserves_of_Canada_Legislative_Boundaries.shp") |>
  filter(grepl("JASPER",adminAreaN))

janp_fire <- read_sf("./assets/JNP_FirePerimeters_selection.shp") |>
  st_transform(st_crs(janp_shp))

abfire <- read_sf("/users/alexandremacphail/downloads/abfire/WildfirePerimeters1931to2024.shp") |>
  st_transform(st_crs(janp_shp)) |>
  st_make_valid()
abfire <- abfire[!st_is_empty(abfire), ]


janp_utm <- janp_shp |> st_transform(26911)

abfire_utm <- abfire |>
  st_transform(26911)

abfire_utm <- abfire_utm |>
  st_make_valid() |>
  st_collection_extract("POLYGON")

idx <- lengths(st_intersects(abfire_utm, janp_utm)) > 0
fires_in_janp <- abfire_utm[idx, ] 
fires_in_janp <- fires_in_janp |> filter(!grepl('Chetamon',ALIAS)) |>
  filter(!YEAR == 2024)
fires_in_janp <- fires_in_janp |> st_transform(4326)

lc_150m <- read_csv("Habitat/LandCoverClass_Buffer150Raw.csv") |>
  pivot_longer(
    cols = matches("^LANDCOVER_(CODE|PCT)_"),
    names_to = c(".value", "rank"),
    names_pattern = "LANDCOVER_(CODE|PCT)_(\\d+)"
  ) |>
  rename(
    landcover = CODE,
    pct = PCT
  ) |>
  filter(!is.na(landcover), pct > 0) |>
  mutate(area_m2 = Shape_Area * (pct / 100)) |>
  group_by(Point_ID, landcover, VEGETATION_DENSITY, REFERENCE_YEAR) |>
  summarise(
    total_area_m2 = sum(area_m2, na.rm = TRUE),
    .groups = "drop"
  ) |>
  mutate(prop_cover = total_area_m2 / (pi * 150^2))

```

```{r}
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| include: true
#| fig-align: center
#| fig-cap: Locations from Jasper National Park ARU EI Monitoring Program.
#| label: fig-aru-monitoring-locations

janp_locs <- janp_main |>
  dplyr::select(location, latitude, longitude, year, ecoregion) |>
  drop_na(latitude) |>
  distinct() |>
  dplyr::mutate(type = case_when(grepl('BAT', location) ~ "Bat", TRUE ~ "Bird")) |>
  sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326)

# Create mpb_in_janp
# mpb_sf <- mpb |>
#   mutate(year = year(recording_date_time)) |>
#   dplyr::select(location, year, latitude, longitude) |>
#   distinct() |>
#   drop_na(latitude, longitude) |>
#   sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326)
# mpb_in_janp <- st_intersection(mpb_sf, janp_shp)

# Combine
janp_locs_map <- janp_locs |> 
  #bind_rows(mpb_in_janp) |>
  dplyr::select(location, year, ecoregion, geometry) |>
  mutate(ecoregion = case_when(
    grepl("^JANP", location) ~ "Other ARU Monitoring", 
    grepl("MPB", location) ~ "Mountain Pine Beetle Project", 
    TRUE ~ ecoregion
  )) |>
  filter(!grepl('MPB',location))

fire_intersect <- st_intersects(janp_locs_map, janp_fire)

ysf <- janp_locs_map %>%
  mutate(
    FIRE_YEAR = sapply(fire_intersect, function(x) if(length(x)) janp_fire$FIRE_YEAR[x] else NA),
    Fire_Name = sapply(fire_intersect, function(x) if(length(x)) janp_fire$Fire_Name[x] else NA)
  ) |>
  filter(!is.na(FIRE_YEAR)) |>
  st_drop_geometry() |>
  mutate_at(vars(year, FIRE_YEAR), as.numeric) |>
  rowwise() |>
  mutate(yrs_since_fire = case_when(FIRE_YEAR > year ~ NA_real_,
                                    FIRE_YEAR == year ~ 0,
                                    FIRE_YEAR < year ~ year - FIRE_YEAR,
                                    TRUE ~ NA_real_))

# Generate summary table
locs_summary <- janp_locs_map |>
  st_drop_geometry() |>
  group_by(location, ecoregion, year) |>
  distinct() |>
  mutate(value = row_number()) |>
  ungroup() |>
  arrange(year) |>
  pivot_wider(names_from = year, values_from = value, values_fill = 0) |>
  rename('Location' = location)

# Map visualization
pal <- colorFactor(
  palette = "Set3", 
  domain = janp_locs_map$ecoregion
)

fire_color <- "#C71585"  # You can adjust to a medium pink if you like

leaflet() %>%
  addTiles() %>%
  addPolygons(
    data = janp_shp,
    color = "blue",
    weight = 1,
    fillOpacity = 0.2,
    popup = ~paste("Park:", adminAreaN)
  ) %>%
  addPolygons(
    data = fires_in_janp,
    fillColor = fire_color,
    color = fire_color,
    weight = 1,
    fillOpacity = 0.5,
    popup = ~paste("Fire:", ALIAS, "<br>Year:", YEAR),
    group = "Fires"   # group them for a single legend entry
  ) %>%
  addPolygons(
    data = janp_fire,
    fillColor = fire_color,
    color = fire_color,
    weight = 1,
    fillOpacity = 0.7,
    popup = ~paste("Fire: ", Fire_Name, "<br>Year:", FIRE_YEAR),
    group = "Fires"
  ) %>%
  addLegend(
    position = "bottomright",
    colors = fire_color,
    labels = "Fires",
    title = "Recent Fires",
    opacity = 1
  ) %>%
  addCircleMarkers(
    data = janp_locs_map,
    popup = ~paste("Location:", location, "<br>"),
    fillColor = ~pal(ecoregion),  
    fillOpacity = 1,
    color = "black", 
    radius = 6 
  ) %>%
  addLegend(
    "topright",
    pal = pal,
    values = janp_locs_map$ecoregion,
    title = "Ecoregion",
    opacity = 1
  ) %>%
  addMeasure(primaryLengthUnit = "meters", primaryAreaUnit = "sqmeters") %>%
  addMiniMap(position = "bottomleft")

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| label: tbl-loc-summary
#| collapse: true
#| code-fold: true
#| tbl-cap: Locations surveyed across years. Ones indicated a deployment in that year for that location.

datatable(locs_summary, 
          options = list(
            searching = TRUE,  
            paging = TRUE,    
            pageLength = 10   
          )) |>
  formatStyle(columns = colnames(locs_summary), 
              backgroundColor = styleEqual(c("NA"), "lightgray"))  
```

## Data management, processing and quality control

Recordings were clipped and organized to only include the 10-minute count. Before adopting WildTrax in 2021, processing analysts excluded the initial 20 seconds to 1.5 minutes of recordings to reduce human impact on detection probability, then logged the first detection time per species. Recordings are now uploaded as clean 10-minute files with the voice note and observer notes removed. In WildTrax, individuals were counted by users scanning both the spectrogram and listening to the audio output. Tags were then drawn to encompass the signal within the methods indicated in each project (see @tbl-transcriptions and @fig-acousticprocessing). Transcribers also had site photos available (see @fig-visitphotos) to optimize their species identification by having habitat context while processing.

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| label: tbl-transcriptions
#| collapse: true
#| code-fold: true
#| tbl-cap: Transcription method by year with re-transcribed data being conducted from 2007 - 2024.

transcription_table <- tibble(
  Years = c("2007-2020", "2021-2022", "2023-2025", "2007-2011"),
  `Transcription Method` = c(
    "0-3.33, 3.33-6.66, 6.66-10 min",
    "1 SPT - Species per task or recording (Every new individual is tagged within the 10 minute recording).",
    "1 SPT - Species per task or recording (Every new individual is tagged within the 10 minute recording).",
    "1 SPT - Species per task or recording (Every new individual is tagged within the 10 minute recording). Re-transcription."
  ),
  `Bin Method` = c(
    "Abundance re-starts for each 3.33-minute bin",
    "Time of first detection over 10 minute period",
    "Time of first detection over 10 minute period",
    "Time of first detection over 10 minute period. Re-transcription."
  ),
  `Method Details` = c(
    "No cap on abundance; abundance re-starts for each bin, no total abundance for the 10-min recording",
    "Time of first detection over 10 minute period",
    "Time of first detection over 10 minute period",
    "Time of first detection over 10 minute period. Re-transcription."
  ),
  `Max # of Individuals` = c(
    "No cap",
    "Maximum of 3 individuals per 10-minute recording",
    "No cap",
    "No cap. Re-transcription."
  )
)

transcription_table

# Render the datatable
datatable(transcription_table, 
          options = list(
            searching = TRUE,  
            paging = TRUE,    
            pageLength = 10   
          )) |>
  formatStyle(columns = colnames(transcription_table), 
              backgroundColor = styleEqual(c("NA"), "lightgray"))  


```

![WildTrax Acoustic Processing Interface (Version 2)](assets/acousticprocessing.png){#fig-acousticprocessing .float-left .fig-align-center}

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true

all_tags <- janp_main |>
  tally() |>
  pull()

verified_tags <- janp_main |>
  group_by(tag_is_verified) |>
  tally() |>
  ungroup() |>
  mutate(Proportion = round(n / all_tags,4)*100) |>
  rename("Count" = n) |>
  rename("Tag is verified" = tag_is_verified)

```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: false

tmtt_tags <- janp_main |>
  dplyr::select(location, recording_date_time, species_code, abundance) |>
  distinct() |>
  filter(abundance == "TMTT") |>
  mutate(recording_date_time = format(recording_date_time, "%Y-%m-%d %H:%M:%S"))

```

![Visit photos at CAVELL-3](assets/locationphotos.png){#fig-visitphotos .float-left .fig-align-center}

## Analyses

::: {.callout-note collapse="true" style="background-color: #f4f4f4; padding: 20px;"}
For the purpose of these analyses abundance was defined as the count of individuals detected during point counts, rather than as a density x area relationship. All analyses took place in R 4.5.1 'Great Square Root'.
:::

### Location correlation {#sec-location-correction}

To assess spatial autocorrelation among bird survey locations across years, we examined the spatial relationship between survey points based on total species abundance per location and year in order to determine whether spatial clustering or spatial dependence exists in the species abundance data. Given that survey points are typically 300 meters apart, we used the `knearneigh()` function to identify the nearest neighbours within this threshold. This function calculates the closest neighboring survey points for each location. We then constructed a spatial weight matrix using the `knn2nb()` function. To evaluate whether spatial proximity among sampling locations influenced annual count estimates, we tested for spatial autocorrelation using Moran’s *I*. Annual minimum counts were calculated for each location by estimating the maximum number of individuals per species detected within a year and summing across species. Spatial coordinates for each location were derived from geographic point data and used to construct spatial neighbor relationships. Global spatial autocorrelation was assessed using Moran’s I under a randomization assumption. Neighbors were defined using a k-nearest-neighbor approach (k = 1) based on great-circle distances, and row-standardized spatial weights were applied. Non-finite values were excluded prior to analysis to ensure valid estimation. To assess whether spatial dependence was driven by localized clusters, we further calculated Local Indicators of Spatial Association (LISA) using local Moran’s I. Local statistics were used to identify potential high–high, low–low, and spatial outlier patterns, with statistical significance evaluated at α = 0.05. While global Moran’s I indicated significant positive spatial autocorrelation, local Moran’s I did not identify statistically significant local clusters. This suggests that spatial dependence in counts was diffuse across the study area.

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: false
#| include: true
#| code-fold: true

# Create an object that defines the EI transects
janp_transects <- janp_main |>
  filter(!grepl('^JANP|^MPB',location)) |>
  filter(data_type %in% c("legacy","single_visit_3_max","single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F) |>
  dplyr::select(location) |>
  distinct() |>
  separate(location, into = c("transect_name", "station_id"), remove = FALSE)

```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: false
#| include: true
#| code-fold: true

janp_total_count <- janp_main %>%
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  group_by(location, year, species_code) %>%
  summarise(n = max(individual_order, na.rm = TRUE), .groups = "drop") %>%
  group_by(location, year) %>%
  summarise(n = sum(n, na.rm = TRUE), .groups = "drop")

janp_locs_sf <- janp_locs %>%
  distinct(location, ecoregion, geometry) %>%
  inner_join(janp_total_count, by = "location") %>%
  st_as_sf()

janp_locs_sf <- janp_locs_sf %>%
  mutate(n = as.numeric(n)) %>%
  filter(!is.na(n))

janp_clean <- janp_locs_sf |>
  mutate(n = ifelse(is.finite(n), n, NA_real_)) |>
  filter(!is.na(n))

coords <- st_coordinates(janp_clean)

neighbours <- knn2nb(
  knearneigh(coords, k = 1, longlat = TRUE)
)

weights <- nb2listw(
  neighbours,
  style = "W",
  zero.policy = TRUE
)

moran_test <- moran.test(
  janp_clean$n,
  listw = weights,
  zero.policy = TRUE
)

lisa <- localmoran(
  janp_clean$n,
  listw = weights,
  zero.policy = TRUE
)

janp_lisa_sf <- janp_clean |>
  mutate(
    Ii      = lisa[, "Ii"],
    z_Ii    = lisa[, "Z.Ii"],
    p_Ii    = lisa[, "Pr(z != E(Ii))"]
  )

lag_n <- lag.listw(weights, janp_clean$n, zero.policy = TRUE)

janp_lisa_sf <- janp_lisa_sf |>
  mutate(
    n_std     = scale(n)[, 1],
    lag_n_std = scale(lag_n)[, 1],
    lisa_type = case_when(
      n_std > 0 & lag_n_std > 0 & p_Ii <= 0.05 ~ "High–High",
      n_std < 0 & lag_n_std < 0 & p_Ii <= 0.05 ~ "Low–Low",
      n_std > 0 & lag_n_std < 0 & p_Ii <= 0.05 ~ "High–Low",
      n_std < 0 & lag_n_std > 0 & p_Ii <= 0.05 ~ "Low–High",
      TRUE                                     ~ "Not significant"
    )
  )

ggplot(janp_lisa_sf) +
  geom_sf(aes(fill = lisa_type), color = "grey30", size = 6) +
  scale_fill_manual(
    values = c(
      "High–High"       = "#d7191c",
      "Low–Low"         = "#2c7bb6",
      "High–Low"        = "#fdae61",
      "Low–High"        = "#abd9e9",
      "Not significant" = "grey85"
    )
  ) +
  labs(
    fill = "LISA cluster",
    title = "Local Moran’s I (LISA) cluster map",
    subtitle = "k = 1 nearest neighbor"
  ) +
  theme_minimal()

```

### Site comparisons

The 2024 Jasper Fire destroyed two established acoustic transects (VALLEY5 and TEKKARA). These transects were replaced in 2025 with two new montane transects (COTTONWOOD and MUSHROOM). To assess whether the replacement transects were appropriate proxies for the original sites, we evaluated how similar their species assemblages were to those observed at other existing montane transects.

Specifically, we compared species detections from COTTONWOOD and MUSHROOM to the distribution of detections across all other montane transects to quantify their compositional similarity and degree of departure from the montane baseline. We assessed whether replacement transects were representative of montane communities using a multivariate dispersion analysis (PERMDISP) based on Bray–Curtis dissimilarity. Distances of replacement transects to the montane centroid were compared against the distribution of distances observed among existing montane transects.

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| code-fold: true

montane_all <- comm_matrix |> filter(ecoregion == "Montane")
sp_mat <- montane_all |> dplyr::select(-location, -ecoregion)
sp_mat <- as.data.frame(sp_mat)
rownames(sp_mat) <- montane_all$location
bc_dist <- vegdist(sp_mat, method = "bray")
group <- ifelse(
  grepl("^COTTONWOOD|^MUSHROOM", rownames(sp_mat)),
  "Replacement",
  "Reference"
)
bd <- betadisper(bc_dist, group)
dist_df <- data.frame(
  location = rownames(sp_mat),
  group = group,
  dist_to_centroid = bd$distances
)
#summary(dist_df$dist_to_centroid[group == "Reference"])
#dist_df %>% filter(group == "Replacement")
ggplot(dist_df, aes(x=group, y=dist_to_centroid, fill=group)) +
  geom_boxplot() +
  geom_point(alpha = 0.2) +
  scale_fill_viridis_d(option = "cividis") +
  ylab("Distance to Montane Centroid") + xlab("Group") +
  theme_bw() +
  ylim(0,1)
```

### Observer and methodological comparisons

```{r}

obs_dups <- janp_main |>
  filter(!observer == "Not Assigned") |>
  group_by(location, recording_date_time) |>
  mutate(n = n_distinct(data_type), n_obs = n_distinct(observer)) |>
  ungroup() |>
  filter(n > 1) |>
  distinct() |>
  dplyr::select(-c(organization, data_type, project_id:n_obs)) |>
  arrange(recording_date_time) |>
  group_by(location, recording_date_time, species_code, observer) %>%
  summarise(individual_order = max(individual_order, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(
    names_from = observer,
    values_from = individual_order,
    values_fill = 0  # missing species = 0
  )

obs_matrix <- obs_dups %>%
  dplyr::select(-location, -recording_date_time, -species_code) %>%
  mutate(across(everything(), ~ ifelse(. > 0, 1, 0)))

dist_obs <- vegdist(t(obs_matrix), method = "bray")
hc <- hclust(dist_obs)
plot(hc)

```

### Community analysis

A redundancy analysis (RDA) was conducted using the `vegan` package (@vegan2025) to quantify the variation in community composition explained by ecoregions and to visualize species–ecoregion relationships with ordination plots (@Rao1964). Species‑level observations were aggregated into a species‑by‑location matrix, with abundances recorded as the maximum count of each species at each location. Ecoregions were categorized into Alpine and Montane with the Montaine ecoregions that can be further sub-divided into Upper Subalpine, Lower Subalpine, and Montane proper ecozones for all subsequent analyses. Differences in composition between Alpine and Montane groups were tested using permutational multivariate analysis of variance (PERMANOVA; @Anderson2001) on Bray–Curtis dissimilarities with 999 permutations under a reduced model.

### Functional and community-level diversity

To evaluate community-level ecological responses, we examined temporal changes in functional diversity, species richness, and community evenness. Functional diversity was quantified using Rao’s Q (@rao1982diversity; @laliberte2010adistance) via the `dbFD()` function in the `FD` package (@FDpackage). We also calculated species richness (number of unique species per location per year) and Shannon’s diversity index, which integrates richness and evenness to describe community structure. These metrics were modeled through time using linear, mixed-effects, and segmented regression models to detect both gradual and threshold-type changes. Results were summarized graphically by ecoregion and functional guild to highlight spatial variation in diversity trajectories.


```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| label: tbl-guilds
#| collapse: true
#| code-fold: true
#| tbl-cap: Guilds

guilds <- read_csv("./assets/jasper_guilds.csv")

guild_activity <- janp_main |>
  filter(data_type %in% c("legacy", "single_visit_3_max", "single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal", "amphibian", "abiotic", "insect", "unknown"), zerofill = T) |>
  dplyr::select(location, recording_date_time, species_common_name, species_code, abundance) |>
  mutate(julian = lubridate::yday(recording_date_time),
         month = month(recording_date_time),
         year = factor(year(recording_date_time))) |>
  inner_join(guilds, by = "species_code") |>
  group_by(species_code) |>
  add_tally() |>
  ungroup() |>
  group_by(julian, species_code) |>
  add_tally() |>
  ungroup() |>
  arrange(species_code) |>
  mutate(recording_date_time = as.POSIXct(recording_date_time)) |>
  mutate(species_code = factor(species_code, levels = sort(unique(species_code)))) |>
  inner_join(locs_summary, by = c("location" = "Location")) |>
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine", "Lower Subalpine", "Montane") ~ "Montane"))

datatable(guilds, 
          options = list(
            searching = TRUE,  
            paging = TRUE,    
            pageLength = 10   
          ))

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| code-fold: true

abund_sp <- janp_main %>%
  group_by(location, year, species_code) %>%
  summarise(abund = n(), .groups = "drop") %>%
  pivot_wider(id_cols = c(location, year),
              names_from  = species_code,
              values_from = abund,
              values_fill = 0)

trait_df <- guilds %>%
  dplyr::select(species_code, dietary_guild, habitat_guild, migratory_guild) %>%
  distinct() %>%
  column_to_rownames("species_code")

trait_mat <- model.matrix(~ dietary_guild + habitat_guild + migratory_guild - 1,
                          data = trait_df)

a_mat <- abund_sp %>% dplyr::select(-location, -year) %>% as.matrix()

common <- intersect(colnames(a_mat), rownames(trait_mat))
a_mat2     <- a_mat[, common, drop = FALSE]
trait_mat2 <- trait_mat[common, , drop = FALSE]

nonzero   <- rowSums(a_mat2) > 0
a_mat3    <- a_mat2[nonzero, , drop = FALSE]
sites3    <- abund_sp[nonzero, c("location","year")]

fd <- dbFD(x = trait_mat2, a = a_mat3, calc.FRic = TRUE, calc.CWM = FALSE, messages = FALSE)

loc_year_rao <- sites3 %>%
  mutate(RaoQ = fd$RaoQ)

yearly_rao <- loc_year_rao %>%
  group_by(year) %>%
  summarise(meanRao = mean(RaoQ), .groups = "drop")

mk        <- mmkh(yearly_rao$meanRao, ci = 0.95)
lm_trend  <- lm(meanRao ~ year, data = yearly_rao)
mix_trend <- lmer(RaoQ ~ year + (1|location), data = loc_year_rao)
seg       <- segmented(lm(meanRao ~ year, data = yearly_rao), seg.Z = ~ year)

yearly_rao <- yearly_rao |>
  mutate(
    lm_fit = predict(lm_trend, newdata = yearly_rao),
    mix_fit = predict(mix_trend, newdata = yearly_rao, re.form = NA),
    seg_fit = predict(seg, newdata = yearly_rao)
  )

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| results: hide
#| code-fold: true

shannon_d <- janp_main |> 
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane")) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F) |>
  inner_join(wt_get_species() |> dplyr::select(species_code, species_class, species_order), by = "species_code") |>
  dplyr::select(location, ecoregion, recording_date_time, species_code, species_common_name, individual_order, abundance) |>
  distinct() |>
  group_by(location, ecoregion, recording_date_time, species_code, species_common_name) |>
  summarise(count = max(individual_order)) |>
  ungroup() |>
  pivot_wider(names_from = species_code, values_from = count, values_fill = 0) |>
  pivot_longer(cols = -(location:species_common_name), names_to = "species", values_to = "count") |>
  group_by(location, ecoregion, year = year(recording_date_time), species) |>
  summarise(total_count = sum(count)) |>
  ungroup() |>
  group_by(location, ecoregion, year) |>
  summarise(shannon_index = diversity(total_count, index = "shannon")) |>
  ungroup() |>
  ggplot(aes(x = factor(year), y = shannon_index, fill = factor(year))) +
  geom_boxplot() +
  geom_point(alpha = 0.6, colour = "grey") +
  labs(x = "Year",
       y = "Shannon diversity index per location") +
  theme_bw() +
  guides(fill = guide_legend(title = "Year")) +
  scale_fill_viridis_d(alpha = 0.8, option = "cividis") +
  facet_wrap(~ecoregion, ncol = 1)
```

### Trend analysis

To quantify temporal changes in bird populations and community composition from 2007 to 2025, we analyzed trends in species-specific abundance, forest and alpine assemblages, and functional guilds. Analyses were designed to separate biological change from potential sampling and methodological effects, ensuring that observed patterns represented genuine ecological responses. This was achieved through a multi-step framework that (1) modeled detection probability and methodological variability, (2) estimated detection-corrected abundance, and (3) evaluated long-term directional trends and associated shifts in functional and community-level diversity.

#### Detection-corrected abundance estimation

Temporal trends in abundance were estimated using single-visit abundance models implemented in the `detect::svabu()` function (@solymos2012conditional). This framework jointly models site-level abundance and detection probability from single-visit counts, providing unbiased estimates without requiring repeated surveys. In the models, year, ecoregion and landcover type and proportion at a 150 meter buffer were included as observation covariates with julian date, hour of day and observer included in the detection covariates to account for within-season and diurnal variation in detectability.The resulting detection-corrected expected abundance per site-visit (λ) was then aggregated by year to produce mean annual abundance indices. These indices were subsequently used to evaluate temporal trends in species abundance.

#### Trend estimation

Temporal trends were quantified using the Mann–Kendall test (@mann1945non; @hamed2009), which detects monotonic directional change, and Sen’s Slope (@Sen01121968) to estimate the magnitude of those trends. Both tests were implemented via the `modifiedmk` package (@hamed1998) and applied to the detection-corrected abundance estimates (λ̂).Sen’s slope provides an estimate of the median annual rate of change in the abundance index over the time series. To express this rate in a standardized and interpretable way, we converted Sen’s slope to a percent change per year by dividing the estimated slope by the mean annual abundance index across the full time series and multiplying by 100. This metric represents the average proportional change in abundance per year, relative to the long-term mean abundance of the species in that ecoregion. Positive values indicate increasing abundance, while negative values indicate declining abundance.

# Results

::: {.callout-note collapse="true" style="background-color: #f4f4f4; padding: 20px;"}
Some of these analyses are still a work-in-progress. Check back soon for updates and additional details.
:::

## Ecoregions

@fig-community shows the relationship between species and ecoregion. The PERMANOVA test was performed using Bray-Curtis dissimilarity to assess whether community composition significantly differed between ecoregion groups. The analysis revealed a significant difference in community composition between alpine and montane groups. The ecoregion grouping explained approximately 27.85% of the variation in community composition, while residual variation accounted for 72.15%. These findings indicate a substantial divergence in species composition between ecoregion groups and helps to justify subsequent analyses looking at trend differences between these areas.

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: fig-community
#| tbl-cap: Community matrix

comm_matrix <- janp_main |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  dplyr::select(-ecoregion) |>
  inner_join(locs_summary, by = c("location" = "Location")) |>
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane")) |>
  group_by(location, ecoregion, species_code) |>
  summarise(individual_order = max(individual_order)) |>
  ungroup() |>
  drop_na(ecoregion) |>
  drop_na(individual_order) |>
  pivot_wider(names_from = species_code, values_from = individual_order, values_fill = 0)

multi_type <- comm_matrix  %>%
  dplyr::select(location, ecoregion) %>%
  distinct() %>%
  drop_na()

t3 <- rda(comm_matrix[,-c(1:2)] ~ ecoregion + location, data = multi_type)
t3scores <- scores(t3, display = "sites") %>%
as.data.frame() %>%
rownames_to_column("site") %>%
bind_cols(., multi_type)
t3vect <- scores(t3, display = "species") %>%
as.data.frame()

plot_RDA <- ggplot(data = t3scores, aes(x = RDA1, y = RDA2)) +
  geom_point(data = t3scores, aes(x = RDA1, y = RDA2, colour = ecoregion), 
             alpha = 0.7, size = 3, shape = 16) +
  stat_ellipse(data = t3scores, aes(colour = ecoregion), 
               linetype = 1, type = 'norm', level = 0.67, size = 1) +
  geom_vline(xintercept = 0, color = "#A19E99", linetype = 2, size = 1) +
  geom_hline(yintercept = 0, color = "#A19E99", linetype = 2, size = 1) +
  geom_segment(data = t3vect, aes(x = 0, y = 0, xend = RDA1, yend = RDA2), 
               arrow = arrow(length = unit(0.2, "cm")), size = 0.3) +
  geom_text_repel(data = t3vect, aes(x = RDA1, y = RDA2, label = rownames(t3vect)), 
                  size = 3, colour = "black", fontface = "italic", 
                  max.overlaps = 10, 
                  segment.color = "grey70") +
  theme_bw() +
  scale_colour_viridis_d(option = "cividis", end = 0.9) +
  labs(x = "RDA1", y = "RDA2", title = "Species-ecoregion associations", 
       colour = "Ecoregion") +
  theme(legend.position = "right", 
        legend.title = element_text(size = 10), 
        legend.text = element_text(size = 9), 
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))

plot_RDA
```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: permanova
#| tbl-cap: PERMANOVA test

comm_matrix_data <- comm_matrix[, -c(1:2)] # Exclude location and ecoregion columns
ecoregion_group <- comm_matrix$ecoregion

# Perform PERMANOVA
permanova_result <- adonis2(comm_matrix_data ~ ecoregion_group, data = comm_matrix, method = "bray", permutations = 999)

```

## Species richness and functional diversity

Activity patterns across nesting, dietary and migratory guilds are illustrated in @fig-spp-activity-nesting onwards. A notable pattern emerges across all four guilds of the proportion of tags detected being detected later in the alpine ecoregion compared to the montane ecoregion. Species richness per location is at @fig-spp-rich-locs and Shannon's diversity index over years at @fig-shannon. Overall, both richness and diversity were stable across years. Rao’s Q averaged between about 8.2 and 10.5 across survey locations, with a clear upward tendency over time (@fig-raos-q). The non‑parametric Mann–Kendall test gave a Kendall’s τ of 0.32 (p ≈ 0.07), indicating a positive but marginally non‑significant monotonic increase in functional diversity. A simple linear regression of mean Rao’s Q against year yielded a slope of 0.051 units per year (p ≈ 0.06), again suggesting an upward trend that narrowly misses the conventional 0.05 significance threshold. When we account for repeated measures at each location via a mixed‑effects model (random intercepts by location), the year effect becomes highly significant (slope = 0.058 Rao’s Q units per year; t ≈ 4.3), demonstrating that functional diversity has increases when location‑level variation is considered. Finally, breakpoint analysis identifies a shift around 2009, suggesting that functional diversity was relatively low and stable from 2007–2009, then rose to more variable but generally higher values from 2010 onward.

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Seasonal detection activity of by nesting guild and ecoregion
#| label: fig-spp-activity-nesting
#| cap-location: margin
#| code-fold: true

ggplot(guild_activity, aes(x = julian, y = habitat_guild, fill = habitat_guild)) + 
      geom_density_ridges(alpha = 0.7) +
      scale_fill_viridis_d(option = "cividis") +
      facet_wrap(~ecoregion) +
      theme_bw() +
      xlab("Day of Year") + 
      ylab("Species")

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Seasonal detection activity of by migratory guild and ecoregion
#| label: fig-spp-activity-migratory
#| cap-location: margin
#| code-fold: true

ggplot(guild_activity, aes(x = julian, y = migratory_guild, fill = migratory_guild)) + 
      geom_density_ridges(alpha = 0.7) +
      scale_fill_viridis_d(option = "cividis") +
      facet_wrap(~ecoregion) +
      theme_bw() +
      xlab("Day of Year") + 
      ylab("Species")

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Seasonal detection activity of by trait and ecoregion
#| label: fig-spp-activity-trait
#| cap-location: margin
#| code-fold: true

ggplot(guild_activity |> filter(!is.na(trait)), aes(x = julian, y = trait, fill = trait)) + 
      geom_density_ridges(alpha = 0.7) +
      scale_fill_viridis_d(option = "cividis") +
      facet_wrap(~ecoregion) +
      theme_bw() +
      xlab("Day of Year") + 
      ylab("Species")

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Seasonal detection activity of by dietary guild and ecoregion
#| label: fig-spp-activity-dietary
#| cap-location: margin
#| code-fold: true

ggplot(guild_activity, aes(x = julian, y = dietary_guild, fill = dietary_guild)) + 
      geom_density_ridges(alpha = 0.7) +
      scale_fill_viridis_d(option = "cividis") +
      facet_wrap(~ecoregion) +
      theme_bw() +
      xlab("Day of Year") + 
      ylab("Species")

```


```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Mean functional diversity (Rao's Q) over time
#| label: fig-raos-q
#| cap-location: margin
#| code-fold: true

ggplot(yearly_rao, aes(x = year, y = meanRao)) +
  geom_point(color = "#213b6e", size = 2) +  # Points for yearly Rao
  geom_line(aes(y = lm_fit, color = "Linear Model"), size = 1.2, linetype = "dashed") +
  geom_line(aes(y = mix_fit, color = "Mixed Effects"), size = 1.2, linetype = "dotted") +
  geom_line(aes(y = seg_fit, color = "Segmented Trend"), size = 1.2) +  # Segmented trend
  scale_color_manual(values = c("Linear Model" = "#b1a570", 
                                "Mixed Effects" = "#6c6e72", 
                                "Segmented Trend" = "#d9c55c")) +  # Custom color mapping
  labs(
    x = "Year",
    y = "Mean Rao's Quadratic Entropy",
    color = "Trend Type"  # Legend title
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12)
  )

```

```{r}
#| warning: false
#| message: false
#| echo: false
#| eval: false
#| include: false
#| code-fold: true

res_raos_q

```

```{r}
#| warning: false
#| message: false
#| echo: true
#| eval: true
#| include: true
#| fig-align: center
#| fig-cap: Species richness by year
#| label: fig-spp-rich-locs
#| cap-location: bottom
#| code-fold: true

spp_rich_location <- janp_main |>
  filter(data_type %in% c("legacy","single_visit_3_max","single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F) |>
  dplyr::select(location, year, species_code) |>
  distinct() |>
  group_by(location, year) |>
  summarise(species_count = n_distinct(species_code)) |>
  ungroup() |>
  inner_join(locs_summary, by = c("location" = "Location")) |>
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane"))

spp_rich_location |>
  ggplot(aes(x=as.factor(year), y=species_count, fill=year)) +
  geom_boxplot() +
  geom_point(alpha = 0.7, colour = "grey") +
  geom_smooth(method = "lm") +
  theme_bw() +
  facet_wrap(~ecoregion) +
  scale_fill_viridis_c(option = "cividis") +
  xlab('Year') + ylab('Species richness per location') +
  coord_flip()

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Shannon diversity index over years
#| label: fig-shannon
#| cap-location: bottom
#| code-fold: true

shannon_d
```

## Trends

```{r}
#| warning: false
#| echo: true
#| eval: false
#| message: false
#| include: true
#| results: hide
#| code-fold: true

janp_ready_trend <- janp_main |>
  inner_join(lc_150m, by = c("location" = "Point_ID")) |>
  mutate(landcover = case_when(grepl('TEKARRA|VALLEY5', location) & year > 2024 ~ "Burned", TRUE ~ landcover)) |>
  distinct()

# Trend
run_trend <- function(spp) {
  
    # 1. Summarize per site-visit using max()
    janp_trend <- janp_ready_trend |>
      filter(!(data_type == "single_visit_0_max" & year < 2021)) |>
      filter(ecoregion %in% c("Alpine")) |>
      mutate(year = year(recording_date_time), 
             hour = hour(recording_date_time),
             julian = yday(recording_date_time)) |>
      dplyr::select(organization, project_id, longitude, latitude, location,
                    location_id, task_id, ecoregion, landcover, prop_cover,
                    VEGETATION_DENSITY, recording_date_time, observer, species_code,
                    individual_order, abundance, detection_time) |>
      distinct() |>
      wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","human","unknown"), zerofill = T)
    
    # 2. Combine with zero sites
    base_zero <- janp_trend |>
      dplyr::select(location, ecoregion, landcover, prop_cover, VEGETATION_DENSITY, recording_date_time, observer) |>
      distinct()
    
    spp_max <- janp_trend |>
      filter(species_code == spp) |>
      group_by(location, ecoregion, landcover, prop_cover, VEGETATION_DENSITY, recording_date_time, observer) |>
      summarise(individual_order = max(individual_order, na.rm = TRUE)) |>
      ungroup()
    
    if (nrow(spp_max) < 20) {
      message(paste0("Probably an error in Alpine with ", spp))
    }
    
    jpt <- base_zero |>
      left_join(spp_max, by = c("location", "ecoregion", "landcover", "prop_cover", "VEGETATION_DENSITY", "recording_date_time", "observer")) |>
      mutate(individual_order = tidyr::replace_na(individual_order, 0)) |>
      mutate(year = year(recording_date_time),
             hour = hour(recording_date_time),
             julian = yday(recording_date_time)) |>
      filter(!is.infinite(individual_order)) |>
      mutate(lc_group = case_when(landcover %in% c("Tree Coniferous", "Shrub Low", "Herbaceous Mixed") ~ landcover, TRUE ~ "Other"), .after = landcover) |>
      dplyr::select(-c(landcover, VEGETATION_DENSITY)) |>
      group_by(location, ecoregion, recording_date_time, observer, individual_order, year, hour, julian) |>
      pivot_wider(names_from = lc_group, values_from = prop_cover, values_fill = 0, values_fn = sum) |>
      ungroup() |>
      rename(shrub = `Shrub Low`) |>
      rename(conf = `Tree Coniferous`) |>
      rename(herb = `Herbaceous Mixed`) |>
      rename(other = Other) |>
      mutate(across(c(shrub, conf, herb, other, julian, hour), scale))
    
    fit <- svabu(individual_order ~ year + shrub + herb + conf | julian + hour + observer, data = jpt)

    ref_vals <- jpt |>
      summarise(observer = first(observer), 
                julian = mean(julian, na.rm = TRUE),
                hour   = mean(hour, na.rm = TRUE))
    
    jpt$lambda_hat <- predict(fit, newdata = jpt |> 
                                mutate(julian = ref_vals$julian,
                                       hour = ref_vals$hour,
                                       observer = ref_vals$observer),
                              type = "response")

    lambda_year <- jpt |>
      group_by(year) |>
      summarise(lambda_hat = mean(lambda_hat, na.rm = TRUE)) |>
      ungroup() |>
      arrange(year)
    
    # 6. Run Mann-Kendall + Sen's slope
    x <- lambda_year$lambda_hat
    mk <- mmkh(x)
    tau       <- mk[6]
    sen_slope <- mk[7]
    p_value   <- mk[2]
    pct_change <- mk[["Sen's slope"]] / mean(x) * 100
    trend_class <- dplyr::case_when(pct_change >  2.5  ~ "Increasing",
                                    pct_change < -2.5  ~ "Decreasing",
                                    TRUE               ~ "Stable")
    
    trend_result_alpine <- tibble(
        ecoregion = "Alpine",
        tau          = tau,
        p_value      = p_value,
        sen_slope    = sen_slope,
        pct_change   = pct_change,
        trend        = trend_class
      )
    
    janp_trend <- janp_ready_trend |>
      filter(!(data_type == "single_visit_0_max" & year < 2021)) |>
      filter(ecoregion %in% c("Montane", "Upper Subalpine", "Lower Subalpine"), !grepl('COTTONWOOD|MUSHROOM', location), !year == 2012) |>
      mutate(year = year(recording_date_time),
             hour = hour(recording_date_time),
             julian = yday(recording_date_time)) |>
      dplyr::select(organization, project_id, longitude, latitude, location, location_id, task_id, ecoregion, landcover, prop_cover, VEGETATION_DENSITY,
                    recording_date_time, observer, species_code, individual_order, abundance, detection_time) |>
      distinct() |>
      wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","human","unknown"), zerofill = T)

    base_zero <- janp_trend |>
      dplyr::select(location, ecoregion, landcover, prop_cover, VEGETATION_DENSITY, recording_date_time, observer) |>
      distinct()
    
    spp_max <- janp_trend |>
      filter(species_code == spp) |>
      group_by(location, ecoregion, landcover, prop_cover, VEGETATION_DENSITY, recording_date_time, observer) |>
      summarise(individual_order = max(individual_order, na.rm = TRUE)) |>
      ungroup()
    
    if (nrow(spp_max) < 20) {message(paste0("Probably an error in Forested with ", spp))}
    
    jpt <- base_zero |>
      left_join(spp_max, by = c("location", "ecoregion", "landcover", "prop_cover", "VEGETATION_DENSITY", "recording_date_time", "observer")) |>
      mutate(individual_order = tidyr::replace_na(individual_order, 0)) |>
      mutate(year = year(recording_date_time),
             hour = hour(recording_date_time),
             julian = yday(recording_date_time)) |>
      filter(!is.infinite(individual_order)) |>
      mutate(lc_group = case_when(landcover %in% c("Tree Coniferous", "Shrub Low", "Herbaceous Mixed") ~ landcover, TRUE ~ "Other"), .after = landcover) |>
      dplyr::select(-c(landcover, VEGETATION_DENSITY)) |>
      group_by(location, ecoregion, recording_date_time, observer, individual_order, year, hour, julian) |>
      pivot_wider(names_from = lc_group, values_from = prop_cover, values_fill = 0, values_fn = sum) |>
      ungroup() |>
      rename(shrub = `Shrub Low`) |>
      rename(conf = `Tree Coniferous`) |>
      rename(herb = `Herbaceous Mixed`) |>
      rename(other = Other) |>
      mutate(across(c(shrub, conf, herb, other, julian, hour), scale))
    
    fit <- svabu(individual_order ~ year + shrub + conf + herb + other | julian + hour + observer, data = jpt)
    
    ref_vals <- jpt |>
      summarise(observer = first(observer),
                julian = mean(julian, na.rm = TRUE),
                hour   = mean(hour, na.rm = TRUE))
    
    jpt$lambda_hat <- predict(fit, newdata = jpt |> mutate( julian = ref_vals$julian, hour = ref_vals$hour, observer = ref_vals$observer), type = "response")
    
    lambda_year <- jpt |>
      group_by(year) |>
      summarise(lambda_hat = mean(lambda_hat, na.rm = TRUE),
                .groups = "drop") |>
      arrange(year)
  
    x <- lambda_year$lambda_hat
    mk <- mmkh(x)
    tau       <- mk[6]
    sen_slope <- mk[7]
    p_value   <- mk[2]
    pct_change <- mk[["Sen's slope"]] / mean(x) * 100
    trend_class <- dplyr::case_when(pct_change >  2.5  ~ "Increasing",
                                    pct_change < -2.5  ~ "Decreasing",
                                    TRUE               ~ "Stable")
    
    trend_result_forested <- tibble(
        ecoregion = "Forested",
        tau          = tau,
        p_value      = p_value,
        sen_slope    = sen_slope,
        pct_change   = pct_change,
        trend        = trend_class
      )
  
    return(bind_rows(trend_result_alpine, trend_result_forested))
    
}

```

```{r}
#| warning: false
#| echo: true
#| eval: false
#| message: false
#| include: true
#| results: hide
#| code-fold: true

trendz <- janp_main |>
  group_by(species_code) |>
  tally() |>
  arrange(-n) |>
  filter(!species_code == "NONE") |>
  slice(1:10) |>
  mutate(trend = map(.x = species_code, .f = ~run_trend(.x))) |>
  unnest_wider(trend) |>
  unnest()


```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| code-fold: true

kable(trendz)

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| code-fold: true

trend_guild <- trendz |>
  inner_join(guilds, by = "species_code")
  
kable(trend_guild |>
  group_by(ecoregion) |>
  summarise(
    total_species = n_distinct(species_code),
    declining_species = n_distinct(species_code[pct_change <= -2.5]),
    percent_declining = declining_species / total_species * 100
  ))

kable(trend_guild |>
  group_by(ecoregion, habitat_guild) |>   # or another guild column if desired
  summarise(
    total_guild_species = n_distinct(species_code),
    declining_guild_species = n_distinct(species_code[pct_change <= -2.5]),
    percent_declining = declining_guild_species / total_guild_species * 100
  ) |>
  ungroup() |>
  group_by(ecoregion) |>
  summarise(
    total_guilds = n_distinct(habitat_guild),
    guilds_with_decline = sum(percent_declining > 0),
    percent_guilds_declining = guilds_with_decline / total_guilds * 100
  ))

```

## Discussion and recommendations

The Discussion and Recommendations. 
