---
title: "Report on the use of passive acoustic monitoring for analysis of bird trends in Jasper National Park"
format:
  html:
    grid:
      margin-width: 300px
  pdf:
    toc: true
    toc-depth: 3
    number-sections: true
    colorlinks: true
    geometry:
      - margin=1in
    papersize: letter
navbar: right
theme: cosmo
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: 
  - name: "Alex MacPhail"
    affiliation: "Biodiversity Pathways Ltd."
  - name: "Brenda Shepherd"
    affiliation: "Jasper National Park, Parks Canada"
  - name: "Nina Veselka"
    affiliation: "Jasper National Park, Parks Canada"
editor: visual
bibliography: references.bib
nocite: '@*'
toc: true
toc-depth: 3
toc-expand: true
prefer-html: true
toc-location: left
styles: styles.css
github: https://github.com/biodiversitypathways/janp
---

![](assets/janp.png){style="float:left`;" fig-alt="Photo of Jasper" fig-align="center"}{.lightbox}

```{r}
#| label: Load packages and authenticate to WildTrax
#| include: false
#| echo: false
#| eval: true
#| warning: false
#| message: false

library(tidyverse)
library(leaflet)
library(wildrtrax)
library(sf)
library(ggridges)
library(scales)
library(kableExtra)
library(ggrepel)
library(DT)
library(lubridate)
library(vegan)
library(lme4)
library(modifiedmk)
library(FD)
library(detect)
library(segmented)
library(fs)
library(tinytex)
library(spdep)

wt_auth()

load('janp.RData')
#save.image('janp.RData')
```


```{r}
#| label: Download data from WildTrax
#| warning: false
#| message: false
#| echo: false
#| eval: false
#| include: true

janp_aru_projects <- wildrtrax::wt_get_projects(sensor = 'ARU') |>
  filter(grepl('Jasper National Park', project)) |>
  dplyr::select(project_id) |>
  pull()

# All projects associated with a single-visit ARU deployment with no abundance cap
janp_0max <- wildrtrax::wt_get_projects(sensor = 'ARU') |>
  filter(grepl('Jasper NP - EI', project)) |>
  filter(!grepl('2021|2022',project)) |>
  dplyr::select(project_id) |>
  pull()

# All projects associated with a single-visit ARU deployment with an abundance cap of 3
janp_3max <- wildrtrax::wt_get_projects(sensor = 'ARU') |>
  filter(grepl('Jasper NP - EI', project)) |>
  filter(grepl('2021|2022',project)) |>
  dplyr::select(project_id) |>
  pull()

janp_project_lists <- list(
  #multi_day = janp_aru_projects,
  single_visit_0_max = janp_0max,
  single_visit_3_max = janp_3max
)

janp_aru <- imap_dfr(
  janp_project_lists,
  ~ map_dfr(
      .x, 
      ~ wildrtrax::wt_download_report(
          project_id = .x,
          sensor_id = "ARU",
          reports = "main"
        )
    ) |> mutate(data_type = .y, .after = organization) 
)

rel_wea <- imap_dfr(
  janp_project_lists,
  ~ map_dfr(
      .x, 
      ~ wildrtrax::wt_download_report(
          project_id = .x,
          sensor_id = "ARU",
          reports = "recording",
          max_seconds = 600
        )
    ) |> mutate(data_type = .y, .after = organization) 
)

# Mountain Pine Beetle
mpb <- wildrtrax::wt_download_report(project_id = 2129, sensor_id = "ARU", reports = "main")

# Bind legacy data with acoustic data
janp_main <- bind_rows(old_s_max, janp_aru) |>
  group_by(location) |>
  fill(ecoregion, .direction = "down") |>
  ungroup() |>
  mutate(location = case_when(grepl("^VALLEY-",location) ~ gsub("VALLEY-","VALLEY5-",location), TRUE ~ location),
         ecoregion = case_when(grepl("COTTONWOOD|MUSHROOM|VALLEY5",location) & is.na(ecoregion) ~ "Montane", TRUE ~ ecoregion),
         year = year(recording_date_time)) # Get year in as a variable

```

::: {.callout-note collapse="true" style="background-color: #f4f4f4; padding: 20px;"}
This report is dynamically generated, meaning its results may evolve with the addition of new data or further analyses. For the most recent updates, refer to the publication date and feel free to reach out to the authors.
:::

# Abstract

Since 2007, Jasper National Park has conducted passive acoustic monitoring as part of its ecological integrity monitoring program. The 18 years of data were analyzed to identify trends and extract insights that inform ongoing monitoring and strengthen future species monitoring practices. The analysis assessed whether species and guild abundances shifted by ±2.5% in the alpine and montane ecoregions. Data were managed and processed in WildTrax, combining and harmonizing legacy datasets from multiple methodologies. Sampling locations were tested for independence, and trend analyses quantified changes in species counts over time across guilds and ecoregions.

# Land Acknowledgement

We respectfully acknowledge that Jasper National Park is located in Treaty 6 and 8 as well as the traditional lands of the Anishinabe, Aseniwuche Winewak, Dene-zaa, Nêhiyawak, Secwépemc, Stoney Nakoda, Mountain Métis and Métis. We acknowledge the past, present, and future generations of these nations who continue to steward the land.

# Introduction

Human activities have been identified as key pressures and contributors to the global decline in forest wildlife (@allan2017recent). The repercussions of habitat fragmentation (@fahrig2003effects) and loss (@hanski2011habitat), climate change (@mantyka2012interactions, @sattar2021review, @abrahms2023climate), and increased access to sensitive areas exert direct and indirect pressures on forest biodiversity, particularly in protected areas in Canada (@lemieux2011state). Climate change and increasing wildfire activity in Alberta's Rocky Mountain Natural Region have significantly impacted montane bird monitoring; in 2023, two of the park's three long-term montane monitoring transects were affected by wildfires, while the third is currently undergoing wildfire risk reduction measures. Since 2007, Jasper National Park initiated a program incorporating passive acoustic monitoring of the Park's vocalizing wildlife. ARUs are compact environmental sensors that are designed to passively record the environment (@aru-overview), capturing vocalizing species like birds and amphibians, which is growing in use across the globe (@lots-of-pam). This technology enables resource managers to conduct prolonged surveys with minimal human interference, but also to create a permanent, archiveable recording of the soundscape. The subsequent data collected by these units contribute valuable information to ecological integrity metrics such as species richness, diversity, occupancy, and trends of species and human activities in National Parks over time. This data can aid in decision-making and management within the Park. Given the rapid and ease of accumulating data from these units, maintaining a high standard of data integrity is paramount to ensure future data interoperability and sharing.

This project aims to analyze Jasper’s passive acoustic monitoring data from 2007 to 2025, assessing trends in species and guild abundance while accounting for the clustering of survey points within transects. Separate analyses will be conducted for montane and sub-alpine and alpine ecoregions to align with Ecological Integrity reporting requirements, determining time-to-first-detection usability in analysis. To enhance accessibility and reproducibility, the findings will be presented in this online report with fully documented code, allowing future updates as data collection methods become standardized. Additionally, recommendations will be developed to refine data transcription priorities, improve annual reporting methods, and evaluate species guild classifications for long-term monitoring. The objectives of this report are to:

-   Describe the data management and processing procedures for the acoustic data collected from 2007 to 2025;
-   Comparing data processing methods on count of species and individuals heard on recordings;
-   Report on transects in montane/sub-alpine and alpine ecoregions, including time-to-first-detection where possible, with key metrics such as the percentage of bird species and guilds declining by ≥2.5% in both montane/sub-alpine and alpine regions.
-   Recommendations for prioritizing previous years’ data for re-transcription to 1SPT, determine the best approach for annual reporting, e.g. baseline comparisons or 10-year trend assessments, adjust methods for evaluating species trends against thresholds, and review guilds and traits used in assessments
-   Facilitate data publication to the public, resource managers, academic institutions, and any other relevant agencies

# Methods

## Data collection

Songbird data was collected using autonomous recording units (ARUs), deployed by field staff to capture one 10-minute recording per point count annually. Surveys were scheduled consistently each breeding season in June and early July, starting 30 minutes before sunrise. Technicians walked transects containing ten points, each spaced at least 300 m apart to prevent duplicate detections and ensure independence of locations. At each monumented location, the ARU is set up, and technicians move 10–20 m away to minimize disturbance, allowing at least 11 minutes of recording for voice notes and activation and de-activation of the units.

```{r}
#| echo: false
#| eval: false
#| warning: false
#| message: false
#| include: true

janp_shp <- read_sf("assets/National_Parks_and_National_Park_Reserves_of_Canada_Legislative_Boundaries.shp") |>
  filter(grepl("JASPER",adminAreaN))

janp_fire <- read_sf("./assets/JNP_FirePerimeters_selection.shp") |>
  st_transform(st_crs(janp_shp))

abfire <- read_sf("/users/alexandremacphail/downloads/abfire/WildfirePerimeters1931to2024.shp") |>
  st_transform(st_crs(janp_shp)) |>
  st_make_valid()
abfire <- abfire[!st_is_empty(abfire), ]

janp_utm <- janp_shp |> st_transform(26911)

abfire_utm <- abfire |>
  st_transform(26911)

abfire_utm <- abfire_utm |>
  st_make_valid() |>
  st_collection_extract("POLYGON")

idx <- lengths(st_intersects(abfire_utm, janp_utm)) > 0
fires_in_janp <- abfire_utm[idx, ] 
fires_in_janp <- fires_in_janp |> filter(!grepl('Chetamon',ALIAS)) |>
  filter(!YEAR == 2024)
fires_in_janp <- fires_in_janp |> st_transform(4326)

lc_150m <- read_csv("Habitat/LandCoverClass_Buffer150Raw.csv") |>
  pivot_longer(
    cols = matches("^LANDCOVER_(CODE|PCT)_"),
    names_to = c(".value", "rank"),
    names_pattern = "LANDCOVER_(CODE|PCT)_(\\d+)"
  ) |>
  rename(
    landcover = CODE,
    pct = PCT
  ) |>
  filter(!is.na(landcover), pct > 0) |>
  mutate(area_m2 = Shape_Area * (pct / 100)) |>
  group_by(Point_ID, landcover, VEGETATION_DENSITY, REFERENCE_YEAR) |>
  summarise(
    total_area_m2 = sum(area_m2, na.rm = TRUE),
    .groups = "drop"
  ) |>
  mutate(prop_cover = total_area_m2 / (pi * 150^2))

canopy_150m <- read_csv("Habitat/DomCanopy_Buffer150Raw.csv") |>
  group_by(Point_ID) |>
  mutate(buffer_area = sum(Shape_Area, na.rm = TRUE)) |>
  ungroup() |>
  group_by(Point_ID, DOM_LAYER_SPECIES_CODE) |>
  summarise(
    canopy_cover = sum(Shape_Area, na.rm = TRUE) / first(buffer_area),
    avg_height = mean(DOM_LAYER_HEIGHT, na.rm = TRUE),
    .groups = "drop"
  ) |>
  rename(canopy_species = DOM_LAYER_SPECIES_CODE) |>
  mutate(
    canopy_species = if_else(is.na(canopy_species), "NC", canopy_species),
    avg_height     = if_else(is.na(avg_height) | is.nan(avg_height), 0, avg_height)
  )


```

```{r}
#| echo: false
#| eval: false
#| warning: false
#| message: false
#| include: true

janp_locs <- janp_main |>
  filter(year > 2022) |>
  dplyr::select(location, latitude, longitude, year, ecoregion) |>
  drop_na(latitude) |>
  distinct() |>
  dplyr::mutate(type = case_when(grepl('BAT', location) ~ "Bat", TRUE ~ "Bird")) |>
  sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326)

# Create mpb_in_janp
# mpb_sf <- mpb |>
#   mutate(year = year(recording_date_time)) |>
#   dplyr::select(location, year, latitude, longitude) |>
#   distinct() |>
#   drop_na(latitude, longitude) |>
#   sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326)
# mpb_in_janp <- st_intersection(mpb_sf, janp_shp)

# Combine
janp_locs_map <- janp_locs |> 
  #bind_rows(mpb_in_janp) |>
  dplyr::select(location, year, ecoregion, geometry) |>
  mutate(ecoregion = case_when(
    grepl("^JANP", location) ~ "Other ARU Monitoring", 
    grepl("MPB", location) ~ "Mountain Pine Beetle Project", 
    TRUE ~ ecoregion
  )) |>
  filter(!grepl('MPB',location))

fire_intersect <- st_intersects(janp_locs_map, janp_fire)

ysf <- janp_locs_map %>%
  mutate(
    FIRE_YEAR = sapply(fire_intersect, function(x) if(length(x)) janp_fire$FIRE_YEAR[x] else NA),
    Fire_Name = sapply(fire_intersect, function(x) if(length(x)) janp_fire$Fire_Name[x] else NA)
  ) |>
  filter(!is.na(FIRE_YEAR)) |>
  st_drop_geometry() |>
  mutate_at(vars(year, FIRE_YEAR), as.numeric) |>
  rowwise() |>
  mutate(yrs_since_fire = case_when(FIRE_YEAR > year ~ NA_real_,
                                    FIRE_YEAR == year ~ 0,
                                    FIRE_YEAR < year ~ year - FIRE_YEAR,
                                    TRUE ~ NA_real_))

# Generate summary table
locs_summary <- janp_locs_map |>
  st_drop_geometry() |>
  group_by(location, ecoregion, year) |>
  distinct() |>
  mutate(value = row_number()) |>
  ungroup() |>
  arrange(year) |>
  pivot_wider(names_from = year, values_from = value, values_fill = 0) |>
  rename('Location' = location)

```

```{r}
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| include: true
#| fig-align: center
#| fig-cap: Locations from Jasper National Park ARU EI Monitoring Program.
#| label: fig-aru-monitoring-locations

# Map visualization
pal <- colorFactor(
  palette = "Set3", 
  domain = janp_locs_map$ecoregion
)

fire_color <- "#C71585"  # You can adjust to a medium pink if you like

leaflet() %>%
  addTiles() %>%
  addPolygons(
    data = janp_shp,
    color = "blue",
    weight = 1,
    fillOpacity = 0.2,
    popup = ~paste("Park:", adminAreaN)
  ) %>%
  addPolygons(
    data = fires_in_janp,
    fillColor = fire_color,
    color = fire_color,
    weight = 1,
    fillOpacity = 0.5,
    popup = ~paste("Fire:", ALIAS, "<br>Year:", YEAR),
    group = "Fires"   # group them for a single legend entry
  ) %>%
  addPolygons(
    data = janp_fire,
    fillColor = fire_color,
    color = fire_color,
    weight = 1,
    fillOpacity = 0.7,
    popup = ~paste("Fire: ", Fire_Name, "<br>Year:", FIRE_YEAR),
    group = "Fires"
  ) %>%
  addLegend(
    position = "bottomright",
    colors = fire_color,
    labels = "Fires",
    title = "Recent Fires",
    opacity = 1
  ) %>%
  addCircleMarkers(
    data = janp_locs_map,
    popup = ~paste("Location:", location, "<br>"),
    fillColor = ~pal(ecoregion),  
    fillOpacity = 1,
    color = "black", 
    radius = 6 
  ) %>%
  addLegend(
    "topright",
    pal = pal,
    values = janp_locs_map$ecoregion,
    title = "Ecoregion",
    opacity = 1
  ) %>%
  addMeasure(primaryLengthUnit = "meters", primaryAreaUnit = "sqmeters") %>%
  addMiniMap(position = "bottomleft")

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| label: tbl-loc-summary
#| collapse: true
#| code-fold: true
#| tbl-cap: Locations surveyed across years. Ones indicated a deployment in that year for that location.

datatable(locs_summary, 
          options = list(
            searching = TRUE,  
            paging = TRUE,    
            pageLength = 10   
          )) |>
  formatStyle(columns = colnames(locs_summary), 
              backgroundColor = styleEqual(c("NA"), "lightgray"))  
```

## Data management, processing and quality control

Recordings were clipped and organized to only include the 10-minute count. Before adopting WildTrax in 2021, processing analysts excluded the initial 20 seconds to 1.5 minutes of recordings to reduce human impact on detection probability, then logged the first detection time per species. Recordings are now uploaded as clean 10-minute files with the voice note and observer notes removed. In WildTrax, individuals were counted by users scanning both the spectrogram and listening to the audio output (MacPhail 2026, *In Review*). Tags were then drawn to encompass the signal within the methods indicated in each project (see @tbl-transcriptions). Transcribers also had site photos available to optimize their species identification by having habitat context while processing.

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| label: tbl-transcriptions
#| collapse: true
#| code-fold: true
#| tbl-cap: Transcription method by year with re-transcribed data being conducted from 2007 - 2025.

transcription_table <- tibble(
  Years = c("2007-2020", "2021-2022", "2023-2025", "2007-2011"),
  `Transcription Method` = c(
    "0-3.33, 3.33-6.66, 6.66-10 min",
    "1 SPT - Species per task or recording (Every new individual is tagged within the 10 minute recording).",
    "1 SPT - Species per task or recording (Every new individual is tagged within the 10 minute recording).",
    "1 SPT - Species per task or recording (Every new individual is tagged within the 10 minute recording). Re-transcription."
  ),
  `Bin Method` = c(
    "Abundance re-starts for each 3.33-minute bin",
    "Time of first detection over 10 minute period",
    "Time of first detection over 10 minute period",
    "Time of first detection over 10 minute period. Re-transcription."
  ),
  `Method Details` = c(
    "No cap on abundance; abundance re-starts for each bin, no total abundance for the 10-min recording",
    "Time of first detection over 10 minute period",
    "Time of first detection over 10 minute period",
    "Time of first detection over 10 minute period. Re-transcription."
  ),
  `Max # of Individuals` = c(
    "No cap",
    "Maximum of 3 individuals per 10-minute recording",
    "No cap",
    "No cap. Re-transcription."
  )
)

transcription_table

# Render the datatable
datatable(transcription_table, 
          options = list(
            searching = TRUE,  
            paging = TRUE,    
            pageLength = 10   
          )) |>
  formatStyle(columns = colnames(transcription_table), 
              backgroundColor = styleEqual(c("NA"), "lightgray"))  


```

![WildTrax Acoustic Processing Interface (Version 2)](assets/acousticprocessing.png){#fig-acousticprocessing .float-left .fig-align-center}{.lightbox}

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true

all_tags <- janp_main |>
  tally() |>
  pull()

verified_tags <- janp_main |>
  group_by(tag_is_verified) |>
  tally() |>
  ungroup() |>
  mutate(Proportion = round(n / all_tags,4)*100) |>
  rename("Count" = n) |>
  rename("Tag is verified" = tag_is_verified)

```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: false

tmtt_tags <- janp_main |>
  dplyr::select(location, recording_date_time, species_code, abundance) |>
  distinct() |>
  filter(abundance == "TMTT") |>
  mutate(recording_date_time = format(recording_date_time, "%Y-%m-%d %H:%M:%S"))

```

![Visit photos at CAVELL-3](assets/locationphotos.png){#fig-visitphotos .float-left .fig-align-center}{.lightbox}

## Analytical methods

::: {.callout-note collapse="true" style="background-color: #f4f4f4; padding: 20px;"}
For the purpose of these analyses, abundance was defined as the count of individuals detected during point counts, rather than as a density x area relationship. All analyses took place in R 4.5.2 ‘[Not] Part in a Rumble’.
:::

### Location correlation {#sec-location-correction}

To inform our subsequent modeling choices, we first evaluated the bird survey data for spatial autocorrelation (e.g., survey points close to one another exhibit similar bird counts). To test for this, we calculated a total abundance index for each location and year by summing the maximum number of individuals detected, representing the minimum number of individuals known to be present. Because survey points were typically spaced 300 m apart, we defined spatial neighbor relationships using a 1-nearest-neighbor approach (*k* = 1) based on great-circle distances. We derived spatial coordinates from geographic point data, excluding non-finite values to ensure valid estimation. Using the `knearneigh()` and `knn2nb()` functions in R, we constructed a spatial weights matrix with row-standardized weights to reflect immediate adjacency between points. We assessed global spatial autocorrelation in total abundance using Moran’s *I* under a randomization assumption. This statistic evaluates whether the landscape is spatially structured—specifically, whether nearby locations tend to have similar abundance values more often than expected by chance. To determine if this dependence was driven by localized clustering, we further calculated Local Indicators of Spatial Association (LISA) using local Moran’s *I*. This allowed for the identification of potential high–high, low–low, and spatial outlier patterns, with statistical significance evaluated at *α* = 0.05. While global Moran’s *I* indicated significant positive spatial autocorrelation across the study area, local Moran’s *I* revealed no statistically significant clusters. This pattern suggests that similarities in bird counts among nearby survey locations were spread broadly rather than concentrated in distinct hotspots, consistent with spatial dependence arising from gradual, landscape‑scale ecological processes rather than localized aggregations. Therefore, we proceeded by treating the locations as spatially independent.


```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: false
#| include: true
#| code-fold: true

# Create an object that defines the EI transects
janp_transects <- janp_main |>
  filter(!grepl('^JANP|^MPB',location)) |>
  filter(data_type %in% c("legacy","single_visit_3_max","single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F) |>
  dplyr::select(location) |>
  distinct() |>
  separate(location, into = c("transect_name", "station_id"), remove = FALSE)

```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: false
#| include: true
#| code-fold: true

janp_total_count <- janp_main %>%
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  group_by(location, year, species_code) %>%
  summarise(n = max(individual_order, na.rm = TRUE), .groups = "drop") %>%
  group_by(location, year) %>%
  summarise(n = sum(n, na.rm = TRUE), .groups = "drop")

janp_locs_sf <- janp_locs %>%
  distinct(location, ecoregion, geometry) %>%
  inner_join(janp_total_count, by = "location") %>%
  st_as_sf()

janp_locs_sf <- janp_locs_sf %>%
  mutate(n = as.numeric(n)) %>%
  filter(!is.na(n))

janp_clean <- janp_locs_sf |>
  mutate(n = ifelse(is.finite(n), n, NA_real_)) |>
  filter(!is.na(n))

coords <- st_coordinates(janp_clean)

neighbours <- knn2nb(
  knearneigh(coords, k = 1, longlat = TRUE)
)

weights <- nb2listw(
  neighbours,
  style = "W",
  zero.policy = TRUE
)

moran_test <- moran.test(
  janp_clean$n,
  listw = weights,
  zero.policy = TRUE
)

lisa <- localmoran(
  janp_clean$n,
  listw = weights,
  zero.policy = TRUE
)

janp_lisa_sf <- janp_clean |>
  mutate(
    Ii      = lisa[, "Ii"],
    z_Ii    = lisa[, "Z.Ii"],
    p_Ii    = lisa[, "Pr(z != E(Ii))"]
  )

lag_n <- lag.listw(weights, janp_clean$n, zero.policy = TRUE)

janp_lisa_sf <- janp_lisa_sf |>
  mutate(
    n_std     = scale(n)[, 1],
    lag_n_std = scale(lag_n)[, 1],
    lisa_type = case_when(
      n_std > 0 & lag_n_std > 0 & p_Ii <= 0.05 ~ "High–High",
      n_std < 0 & lag_n_std < 0 & p_Ii <= 0.05 ~ "Low–Low",
      n_std > 0 & lag_n_std < 0 & p_Ii <= 0.05 ~ "High–Low",
      n_std < 0 & lag_n_std > 0 & p_Ii <= 0.05 ~ "Low–High",
      TRUE                                     ~ "Not significant"
    )
  )

ggplot(janp_lisa_sf) +
  geom_sf(aes(fill = lisa_type), color = "grey30", size = 6) +
  scale_fill_manual(
    values = c(
      "High–High"       = "#d7191c",
      "Low–Low"         = "#2c7bb6",
      "High–Low"        = "#fdae61",
      "Low–High"        = "#abd9e9",
      "Not significant" = "grey85"
    )
  ) +
  labs(
    fill = "LISA cluster",
    title = "Local Moran’s I (LISA) cluster map",
    subtitle = "k = 1 nearest neighbor"
  ) +
  theme_minimal()

```

### Fire-affected site comparisons

The 2024 Jasper Fire severely burned two established acoustic transects (VALLEY5 and TEKKARA). While only one-third of montane (valley-bottom) forest has burnt since 2023, two of three transects were severely burned. To continue to monitor bird communities in unburned forest, we added two control transects in 2025 in the montane (COTTONWOOD and MUSHROOM), and we plan to continue to monitor both the burned and control transects. 

To assess whether the new transects were appropriate controls for the original sites, we evaluated how similar their species assemblages were to those observed at existing montane transects over the past three years, excluding the TEKARRA and VALLEY5 transects post-fire because these were expected to diverge substantially due to fire severity. Specifically, we compared species detections from the COTTONWOOD and MUSHROOM transects to the distribution of detections across all other montane points to quantify compositional similarity and departure from the montane baseline. Representativeness of control transects was assessed using a multivariate dispersion analysis (PERMDISP) based on Bray–Curtis dissimilarity, with distances of control transects to the montane centroid compared against the distribution of distances among established montane transects. Statistical significance of differences in dispersion was evaluated using a permutation test with 999 iterations.

We summarized bird community composition on the VALLEY5 and TEKARRA transects using a species–by–site community matrix and applied redundancy analysis (RDA) to test whether community structure differed between pre-fire and post-fire periods (@fig-after-fire). The ordination visualizes shifts in species associations attributable to fire, with site scores grouped by fire period and species vectors indicating taxa contributing most strongly to observed differences.

::: {.figure-grid}
![Tekarra 9 2024](assets/tekarra9-2024.png){width=48%}
![Tekarra 9 2025](assets/tekarra9-2025.png){width=48%}

Tekarra 9 site photos views from 2024 (A) pre-fire, and 2025 (B) post-fire. 
:::

### Observer and methodological comparisons

Transcription methods varied (Table 2) and recordings from 2007 to 2020 were classified by a single observer (legacy), while subsequent data were classified by a random selection of observers (WildTrax). To evaluate consistency between the legacy dataset and the modern WildTrax workflow, we analyzed a subset of recordings processed using both approaches. This included re-processing legacy recordings using new observers in WildTrax, allowing for direct comparison of individual observer performance between the legacy and modern protocols. For each dual-processed recording, we derived the maximum count of individuals per species identified by each specific observer. We used two different metrics to verify data continuity. First, to quantify consistency in abundance estimates, we calculated pairwise Pearson correlations between all individual observers. These relationships were visualized using a heatmap to identify any systematic deviations in counting between legacy contractors and current WildTrax observers. @fig-pairwise indicates that there is general consistency in abundance counts, but not high reliability between observers (e.g., some observers are more generous with counts than others) indicating there may be a bias *- OR BECAUSE METHOD CHANGED - e.g., re-start between bins, cap on counts*. Second, to evaluate consistency in species detection (composition), we binarized the data to presence/absence and calculated Bray–Curtis dissimilarities between individual observers. We then applied hierarchical clustering to these dissimilarity scores to verify that the transition to WildTrax did not introduce observer-specific biases in species identification or community composition. @fig-cluster shows that most observers agree on species, and there doesn’t appear to be a systematic bias during the transition to WildTrax. If the transition introduced a major bias, we would see two distinct large branches with one containing all legacy contractors and one containing all WildTrax observers.  


```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: false
#| code-fold: true

obs_dups <- janp_main |>
  filter(!observer == "Not Assigned") |>
  filter(!(detection_time > 180)) |>
  group_by(location, recording_date_time) |>
  mutate(n = n_distinct(data_type), n_obs = n_distinct(observer)) |>
  ungroup() |>
  filter(n > 1) |>
  distinct() |>
  dplyr::select(-c(organization, data_type, project_id:n_obs)) |>
  arrange(recording_date_time) |>
  group_by(location, recording_date_time, species_code, observer) %>%
  summarise(individual_order = max(individual_order, na.rm = TRUE), .groups = "drop") %>%
  ungroup() |>
  distinct() |>
  pivot_wider(
    names_from = observer,
    values_from = individual_order,
    values_fill = 0  # missing species = 0
  ) |>
  inner_join(janp_main |> dplyr::select(location, recording_date_time, recording_id) |> distinct(), by = c("location" = "location", "recording_date_time" = "recording_date_time")) |>
  relocate(recording_id, .after = recording_date_time) |>
  drop_na()

obs_matrix <- obs_dups %>%
  dplyr::select(-location, -recording_date_time, -species_code, -recording_id) %>%
  mutate(across(everything(), ~ ifelse(. > 0, 1, 0)))

# Observer names
observer_cols <- colnames(obs_matrix)

# Initialize empty tibble for pairwise Spearman correlations
pairwise_corr <- tibble(obs1 = character(), obs2 = character(), corr = double())

# Compute pairwise correlations
for(i in 1:(length(observer_cols)-1)) {
  for(j in (i+1):length(observer_cols)) {
    o1 <- observer_cols[i]
    o2 <- observer_cols[j]
    c <- cor(obs_matrix[[o1]], obs_matrix[[o2]], method = "spearman", use = "pairwise.complete.obs")
    pairwise_corr <- pairwise_corr %>%
      add_row(obs1 = o1, obs2 = o2, corr = c)
  }
}

```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| code-fold: true
#| label: fig-pairwise
#| fig-cap: Heatmap visualizes how consistently different observers recorded abundance estimates. Yellow indicates strong positive correlation (high reliability between observers), orange/red indicates weak positive correlation (general consistency) and dark purple indicates a diversion in counts while white appears where there are no overlapping observations to compare.

# Heatmap
ggplot(pairwise_corr, aes(x = obs1, y = obs2, fill = corr)) +
  geom_tile() +
  scale_fill_viridis_c(option = "C") +
  labs(x = "Observer", y = "Observer", fill = "Correlation",
       title = "Pairwise observer correlations") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

obs_matrix <- obs_dups %>%
  dplyr::select(-location, -recording_date_time, -species_code) %>%
  mutate(across(everything(), ~ ifelse(. > 0, 1, 0)))
```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| code-fold: true
#| label: fig-cluster
#| fig-cap: This Cluster Dendrogram visualizes how similar observers are based on the species they detect in the recordings. The height on the y-axis represents the level of dissimilarity and the lower the branch connecting two observers, the more similar their species lists. Most observers join the tree at a height above 0.8. If the transition to WildTrax had introduced a major bias, you would see two distinct, large branches—one containing all legacy contractors and one containing all WildTrax observers. 

dist_obs <- vegdist(t(obs_matrix), method = "bray")
hc <- hclust(dist_obs)
plot(hc)

```

### Community analysis

To characterize bird community composition, we first aggregated species-level observations into a species-by-location matrix, populated with the maximum count of each species at each location. Survey points were then classified into two primary ecoregions: alpine and montane. For the purpose of this analysis, the montane category served as a broad aggregate, grouping the upper subalpine, lower subalpine, and montane ecoregions into a single unit. We quantified the variation in community composition explained by these two ecoregions using Redundancy Analysis (RDA) in the vegan package (@Oksanen2025) and visualized species–ecoregion relationships with ordination plots (@Rao1964). Finally, to test for statistical differences in composition between the Alpine and Montane groups, we performed a permutational multivariate analysis of variance (PERMANOVA; @Anderson2001). This test was conducted on Bray–Curtis dissimilarities using 999 permutations under a reduced model.

### Functional and community-level diversity

To evaluate community-level ecological responses, we examined temporal changes in functional diversity, species richness, and community evenness. Functional diversity was quantified using Rao’s Q (@rao1982diversity; @laliberte2010adistance) via the `dbFD()` function in the `FD` package (@FDpackage). We also calculated species richness (number of unique species per location per year) and Shannon’s diversity index, which integrates richness and evenness to describe community structure. These metrics were modeled through time using linear, mixed-effects, and segmented regression models to detect both gradual and threshold-type changes. Results were summarized graphically by ecoregion and functional guild to highlight spatial variation in diversity trajectories.


```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| label: tbl-guilds
#| collapse: true
#| code-fold: true
#| tbl-cap: Guilds

guilds <- read_csv("./assets/jasper_guilds.csv")

guild_activity <- janp_main |>
  filter(!grepl('COTTONWOOD|MUSHROOM', location)) |>
  filter(data_type %in% c("legacy", "single_visit_3_max", "single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal", "amphibian", "abiotic", "insect", "unknown"), zerofill = T) |>
  dplyr::select(location, recording_date_time, species_common_name, species_code, abundance) |>
  mutate(julian = lubridate::yday(recording_date_time),
         month = month(recording_date_time),
         year = factor(year(recording_date_time))) |>
  inner_join(guilds, by = "species_code") |>
  group_by(species_code) |>
  add_tally() |>
  ungroup() |>
  group_by(julian, species_code) |>
  add_tally() |>
  ungroup() |>
  arrange(species_code) |>
  mutate(recording_date_time = as.POSIXct(recording_date_time)) |>
  mutate(species_code = factor(species_code, levels = sort(unique(species_code)))) |>
  inner_join(locs_summary, by = c("location" = "Location")) |>
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine", "Lower Subalpine", "Montane") ~ "Montane"))

datatable(guilds, 
          options = list(
            searching = TRUE,  
            paging = TRUE,    
            pageLength = 10   
          ))

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| code-fold: true

abund_sp <- janp_main %>%
  filter(!grepl('COTTONWOOD|MUSHROOM', location)) |>
  group_by(location, year, species_code) %>%
  summarise(abund = n(), .groups = "drop") %>%
  pivot_wider(id_cols = c(location, year),
              names_from  = species_code,
              values_from = abund,
              values_fill = 0)

trait_df <- guilds %>%
  dplyr::select(species_code, trait, dietary_guild, habitat_guild, migratory_guild) %>%
  distinct() %>%
  column_to_rownames("species_code")

trait_mat <- model.matrix(~ trait + dietary_guild + habitat_guild + migratory_guild - 1,
                          data = trait_df)

a_mat <- abund_sp %>% dplyr::select(-location, -year) %>% as.matrix()

common <- intersect(colnames(a_mat), rownames(trait_mat))
a_mat2     <- a_mat[, common, drop = FALSE]
trait_mat2 <- trait_mat[common, , drop = FALSE]

nonzero   <- rowSums(a_mat2) > 0
a_mat3    <- a_mat2[nonzero, , drop = FALSE]
sites3    <- abund_sp[nonzero, c("location","year")]

fd <- dbFD(x = trait_mat2, a = a_mat3, calc.FRic = TRUE, calc.CWM = FALSE, messages = FALSE)

loc_year_rao <- sites3 %>%
  mutate(RaoQ = fd$RaoQ)

yearly_rao <- loc_year_rao %>%
  group_by(year) %>%
  summarise(meanRao = mean(RaoQ), .groups = "drop")

mk        <- mmkh(yearly_rao$meanRao, ci = 0.95)
lm_trend  <- lm(meanRao ~ year, data = yearly_rao)
mix_trend <- lmer(RaoQ ~ year + (1|location), data = loc_year_rao)
seg       <- segmented(lm(meanRao ~ year, data = yearly_rao), seg.Z = ~ year)

yearly_rao <- yearly_rao |>
  mutate(
    lm_fit = predict(lm_trend, newdata = yearly_rao),
    mix_fit = predict(mix_trend, newdata = yearly_rao, re.form = NA),
    seg_fit = predict(seg, newdata = yearly_rao)
  )

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| results: hide
#| code-fold: true

shannon_d <- janp_main |> 
  filter(!grepl('COTTONWOOD|MUSHROOM', location)) |>
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane")) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F) |>
  inner_join(wt_get_species() |> dplyr::select(species_code, species_class, species_order), by = "species_code") |>
  dplyr::select(location, ecoregion, recording_date_time, species_code, species_common_name, individual_order, abundance) |>
  distinct() |>
  group_by(location, ecoregion, recording_date_time, species_code, species_common_name) |>
  summarise(count = max(individual_order)) |>
  ungroup() |>
  pivot_wider(names_from = species_code, values_from = count, values_fill = 0) |>
  pivot_longer(cols = -(location:species_common_name), names_to = "species", values_to = "count") |>
  group_by(location, ecoregion, year = year(recording_date_time), species) |>
  summarise(total_count = sum(count)) |>
  ungroup() |>
  group_by(location, ecoregion, year) |>
  summarise(shannon_index = diversity(total_count, index = "shannon")) |>
  ungroup() |>
  filter(!(year == 2012 & ecoregion == "Montane")) |>
  ggplot(aes(x = factor(year), y = shannon_index, fill = factor(year))) +
  geom_boxplot() +
  geom_point(alpha = 0.6, colour = "grey") +
  labs(x = "Year",
       y = "Shannon diversity index per location") +
  theme_bw() +
  guides(fill = guide_legend(title = "Year")) +
  scale_fill_viridis_d(alpha = 0.8, option = "cividis") +
  facet_wrap(~ecoregion, ncol = 1)
```

### Trend analysis

To quantify temporal changes in bird populations and community composition from 2007 to 2025, we analyzed trends in species-specific abundance, forest and alpine assemblages, and functional guilds. Analyses were designed to separate biological change from potential sampling and methodological effects, ensuring that observed patterns represented genuine ecological responses. This was achieved through a multi-step framework that (1) modeled detection probability and methodological variability, (2) estimated detection-corrected abundance, and (3) evaluated long-term directional trends and associated shifts in functional and community-level diversity.

#### Detection-corrected abundance estimation

Temporal trends in abundance were estimated using single-visit abundance models implemented in the `detect::svabu()` function (@solymos2012conditional). This framework jointly models site-level abundance and detection probability from single-visit counts, providing unbiased estimates without requiring repeated surveys. In the models, year, ecoregion and landcover type and proportion at a 150 meter buffer were included as observation covariates with julian date, hour of day and observer included in the detection covariates to account for within-season and diurnal variation in detectability.The resulting detection-corrected expected abundance per site-visit (λ) was then aggregated by year to produce mean annual abundance indices. These indices were subsequently used to evaluate temporal trends in species abundance.

#### Trend estimation

Temporal trends were quantified using the Mann–Kendall test (@mann1945non; @hamed2009), which detects monotonic directional change, and Sen’s Slope (@Sen01121968) to estimate the magnitude of those trends. Both tests were implemented via the `modifiedmk` package (@hamed1998) and applied to the detection-corrected abundance estimates (λ̂).Sen’s slope provides an estimate of the median annual rate of change in the abundance index over the time series. To express this rate in a standardized and interpretable way, we converted Sen’s slope to a percent change per year by dividing the estimated slope by the mean annual abundance index across the full time series and multiplying by 100. This metric represents the average proportional change in abundance per year, relative to the long-term mean abundance of the species in that ecoregion. Positive values indicate increasing abundance, while negative values indicate declining abundance.

# Results

::: {.callout-note collapse="true" style="background-color: #f4f4f4; padding: 20px;"}
Some of these analyses are still a work-in-progress. Check back soon for updates and additional details.
:::

## Jasper 2024 fire effects

Multivariate dispersion differed significantly between control and reference montane transects (PERMDISP; F₁,₅₅ = 4.05, p = 0.05). Control transects exhibited slightly higher distances to the group centroid (mean = 0.415) compared with montane reference transects (mean = 0.384), indicating greater compositional variability. This suggests that species assemblages at control transects were less tightly clustered around the central tendency of montane communities and may reflect more heterogeneous or transitional assemblages relative to established montane sites, but only by a small margin. Consequently, while control transects occur within montane environments, their communities show somewhat more variability than the broader montane baseline used in this analysis.

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| code-fold: true
#| label: fig-control-transect
#| fig-cap: Control transects

comm_matrix1 <- janp_main |>
  filter(!(grepl("VALLEY5|TEKARRA",location) & year > 2024), year %in% c(2023:2025)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  dplyr::select(-ecoregion) |>
  inner_join(locs_summary, by = c("location" = "Location")) |>
  # mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
  #                              ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane")) |>
  group_by(location, ecoregion, species_code) |>
  summarise(individual_order = max(individual_order)) |>
  ungroup() |>
  drop_na(ecoregion) |>
  drop_na(individual_order) |>
  pivot_wider(names_from = species_code, values_from = individual_order, values_fill = 0)

montane_all <- comm_matrix1 |> filter(ecoregion == "Montane")
sp_mat <- montane_all |> dplyr::select(-location, -ecoregion)
sp_mat <- as.data.frame(sp_mat)
rownames(sp_mat) <- montane_all$location
bc_dist <- vegdist(sp_mat, method = "bray")
group <- ifelse(
  grepl("^COTTONWOOD|^MUSHROOM", rownames(sp_mat)),
  "Control Transects",
  "Montane Reference"
)
bd <- betadisper(bc_dist, group)
permu_bd <- permutest(bd)
dist_df <- data.frame(
  location = rownames(sp_mat),
  group = group,
  dist_to_centroid = bd$distances
)
#summary(dist_df$dist_to_centroid[group == "Reference"])
#dist_df %>% filter(group == "Replacement")
ggplot(dist_df, aes(x=group, y=dist_to_centroid, fill=group)) +
  geom_boxplot() +
  geom_point(alpha = 0.2) +
  scale_fill_viridis_d(option = "cividis") +
  ylab("Distance to Montane Centroid") + xlab("Group") +
  theme_bw() +
  ylim(0,1)
```

The pre-fire and 1-year post-fire points occupy overlapping but shifted regions indicating that the fire did not completely replace the community but it reorganized species composition in a consistent direction which is a classic disturbance-driven compositional shift and not a collapse or a reset. 
In @fig-after-fire, the post-fire ellipse has significantly shifted among sites after fire and more heterogeneous species assemblages. Species vectors identified taxa contributing most strongly to these differences, suggesting that the Jasper Fire altered species associations rather than uniformly affecting overall abundance. Dark-eyed Junco (DEJU) shows a strong directional association with post-fire sites (they tolerate reduced canopy cover and more simplified forest structure), while Warbling Vireo (WAVI) was strongly associated with pre-fire assemblages, indicating that canopy-associated species contributed disproportionately to community composition prior to the fire. 

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| code-fold: true
#| label: fig-after-fire
#| fig-cap: Community matrix of species associations before and after the Jasper 2024 fire on the VALLEY5 and TEKARRA transects. Movement along RDA1 reflects the direction and magnitude of fire-related change in species composition. PC1 captures residual variation in species composition that is not explained by fire period reflecting the background ecological variability among sites.


janp_fire_comm <- janp_main |>
  filter(grepl("VALLEY5|TEKARRA",location)) |>
  group_by(location, year, species_code) |>
  summarise(individual_order = max(individual_order)) |>
  ungroup() |>
  mutate(fire_period = if_else(year < 2025, "Pre-fire", "Post-fire")) |>
  filter(!(species_code == "NONE"))
 
comm_mat_fire <- janp_fire_comm |>
  pivot_wider(
    names_from = species_code,
    values_from = individual_order,
    values_fill = 0) |>
  drop_na()

env_fire <- comm_mat_fire |>
  mutate(
    location = factor(location),
    fire_period = factor(fire_period)
  ) |>
  drop_na()

t3_fire <- rda(comm_mat_fire[,-c(1:3)] ~ fire_period, data = env_fire)
t3scores_fire <- scores(t3_fire, display = "sites") |>
  as.data.frame() |>
  rownames_to_column("site") |>
  bind_cols(env_fire)
t3vect_fire <- scores(t3_fire, display = "species") |>
  as.data.frame()

plot_RDA_fire <- ggplot(data = t3scores_fire, aes(x = RDA1, y = PC1)) +
  geom_point(data = t3scores_fire, aes(x = RDA1, y = PC1, colour = fire_period), 
             alpha = 0.7, size = 3, shape = 16) +
  stat_ellipse(data = t3scores_fire, aes(colour = fire_period), 
               linetype = 1, type = 'norm', level = 0.67, size = 1) +
  geom_vline(xintercept = 0, color = "#A19E99", linetype = 2, size = 1) +
  geom_hline(yintercept = 0, color = "#A19E99", linetype = 2, size = 1) +
  geom_segment(data = t3vect_fire, aes(x = 0, y = 0, xend = RDA1, yend = PC1), 
               arrow = arrow(length = unit(0.2, "cm")), size = 0.3) +
  geom_text_repel(data = t3vect_fire, aes(x = RDA1, y = PC1, label = rownames(t3vect_fire)), 
                  size = 3, colour = "black", fontface = "italic", 
                  max.overlaps = 10, 
                  segment.color = "grey70") +
  theme_bw() +
  scale_colour_viridis_d(option = "cividis", end = 0.9) +
  labs(x = "RDA1", y = "PC1", title = "Pre-post Jasper Fire species associations", 
       colour = "Fire Period") +
  theme(legend.position = "right", 
        legend.title = element_text(size = 10), 
        legend.text = element_text(size = 9), 
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))

plot_RDA_fire

```

## Species-ecoregion associations

@fig-community shows the relationship between species and ecoregion. The PERMANOVA test was performed using Bray-Curtis dissimilarity to assess whether community composition significantly differed between ecoregion groups. The analysis revealed a significant difference in community composition between alpine and montane groups. The ecoregion grouping explained approximately 27.85% of the variation in community composition, while residual variation accounted for 72.15%. These findings indicate a substantial divergence in species composition between ecoregion groups and helps to justify subsequent analyses looking at trend differences between these areas.

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: fig-community
#| tbl-cap: Community matrix of species associations between montane and alpine ecoregions

comm_matrix <- janp_main |>
  filter(!grepl('COTTONWOOD|MUSHROOM', location)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  dplyr::select(-ecoregion) |>
  inner_join(locs_summary, by = c("location" = "Location")) |>
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane")) |>
  group_by(location, ecoregion, species_code) |>
  summarise(individual_order = max(individual_order)) |>
  ungroup() |>
  drop_na(ecoregion) |>
  drop_na(individual_order) |>
  pivot_wider(names_from = species_code, values_from = individual_order, values_fill = 0)

multi_type <- comm_matrix  %>%
  dplyr::select(location, ecoregion) %>%
  distinct() %>%
  drop_na()

t3 <- rda(comm_matrix[,-c(1:2)] ~ ecoregion + location, data = multi_type)
t3scores <- scores(t3, display = "sites") %>%
as.data.frame() %>%
rownames_to_column("site") %>%
bind_cols(., multi_type)
t3vect <- scores(t3, display = "species") %>%
as.data.frame()

plot_RDA <- ggplot(data = t3scores, aes(x = RDA1, y = RDA2)) +
  geom_point(data = t3scores, aes(x = RDA1, y = RDA2, colour = ecoregion), 
             alpha = 0.7, size = 3, shape = 16) +
  stat_ellipse(data = t3scores, aes(colour = ecoregion), 
               linetype = 1, type = 'norm', level = 0.67, size = 1) +
  geom_vline(xintercept = 0, color = "#A19E99", linetype = 2, size = 1) +
  geom_hline(yintercept = 0, color = "#A19E99", linetype = 2, size = 1) +
  geom_segment(data = t3vect, aes(x = 0, y = 0, xend = RDA1, yend = RDA2), 
               arrow = arrow(length = unit(0.2, "cm")), size = 0.3) +
  geom_text_repel(data = t3vect, aes(x = RDA1, y = RDA2, label = rownames(t3vect)), 
                  size = 3, colour = "black", fontface = "italic", 
                  max.overlaps = 10, 
                  segment.color = "grey70") +
  theme_bw() +
  scale_colour_viridis_d(option = "cividis", end = 0.9) +
  labs(x = "RDA1", y = "RDA2", title = "Species-ecoregion associations", 
       colour = "Ecoregion") +
  theme(legend.position = "right", 
        legend.title = element_text(size = 10), 
        legend.text = element_text(size = 9), 
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))

plot_RDA
```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: permanova
#| tbl-cap: PERMANOVA test

comm_matrix_data <- comm_matrix[, -c(1:2)] # Exclude location and ecoregion columns
ecoregion_group <- comm_matrix$ecoregion

# Perform PERMANOVA
permanova_result <- adonis2(comm_matrix_data ~ ecoregion_group, data = comm_matrix, method = "bray", permutations = 999)

```

## Species richness and functional diversity

Activity patterns across nesting, dietary and migratory guilds are illustrated in @fig-spp-activity-nesting onwards. A notable pattern emerges across all four guilds of the proportion of tags detected being detected later in the alpine ecoregion compared to the montane ecoregion. Species richness per location is at @fig-spp-rich-locs and Shannon's diversity index over years at @fig-shannon. Overall, both richness and diversity were stable across years. Rao’s Q averaged between about 8.2 and 10.5 across survey locations, with a clear upward tendency over time (@fig-raos-q). The non‑parametric Mann–Kendall test gave a Kendall’s τ of 0.32 (p ≈ 0.07), indicating a positive but marginally non‑significant monotonic increase in functional diversity. A simple linear regression of mean Rao’s Q against year yielded a slope of 0.051 units per year (p ≈ 0.06), again suggesting an upward trend that narrowly misses the conventional 0.05 significance threshold. When we account for repeated measures at each location via a mixed‑effects model (random intercepts by location), the year effect becomes highly significant (slope = 0.058 Rao’s Q units per year; t ≈ 4.3), demonstrating that functional diversity has increases when location‑level variation is considered. Finally, breakpoint analysis identifies a shift around 2009, suggesting that functional diversity was relatively low and stable from 2007–2009, then rose to more variable but generally higher values from 2010 onward.

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Seasonal detection activity of by nesting guild and ecoregion
#| label: fig-spp-activity-nesting
#| cap-location: margin
#| code-fold: true

ggplot(guild_activity, aes(x = julian, y = habitat_guild, fill = habitat_guild)) + 
      geom_density_ridges(alpha = 0.7) +
      scale_fill_viridis_d(option = "cividis") +
      facet_wrap(~ecoregion) +
      theme_bw() +
      xlab("Day of Year") + 
      ylab("Species")

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Seasonal detection activity of by migratory guild and ecoregion
#| label: fig-spp-activity-migratory
#| cap-location: margin
#| code-fold: true

ggplot(guild_activity, aes(x = julian, y = migratory_guild, fill = migratory_guild)) + 
      geom_density_ridges(alpha = 0.7) +
      scale_fill_viridis_d(option = "cividis") +
      facet_wrap(~ecoregion) +
      theme_bw() +
      xlab("Day of Year") + 
      ylab("Species")

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Seasonal detection activity of by trait and ecoregion
#| label: fig-spp-activity-trait
#| cap-location: margin
#| code-fold: true

ggplot(guild_activity |> filter(!is.na(trait)), aes(x = julian, y = trait, fill = trait)) + 
      geom_density_ridges(alpha = 0.7) +
      scale_fill_viridis_d(option = "cividis") +
      facet_wrap(~ecoregion) +
      theme_bw() +
      xlab("Day of Year") + 
      ylab("Species")

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Seasonal detection activity of by dietary guild and ecoregion
#| label: fig-spp-activity-dietary
#| cap-location: margin
#| code-fold: true

ggplot(guild_activity, aes(x = julian, y = dietary_guild, fill = dietary_guild)) + 
      geom_density_ridges(alpha = 0.7) +
      scale_fill_viridis_d(option = "cividis") +
      facet_wrap(~ecoregion) +
      theme_bw() +
      xlab("Day of Year") + 
      ylab("Species")

```


```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Mean functional diversity (Rao's Q) over time
#| label: fig-raos-q
#| cap-location: margin
#| code-fold: true

ggplot(yearly_rao, aes(x = year, y = meanRao)) +
  geom_point(color = "#213b6e", size = 2) +  # Points for yearly Rao
  geom_line(aes(y = lm_fit, color = "Linear Model"), size = 1.2, linetype = "dashed") +
  geom_line(aes(y = mix_fit, color = "Mixed Effects"), size = 1.2, linetype = "dotted") +
  geom_line(aes(y = seg_fit, color = "Segmented Trend"), size = 1.2) +  # Segmented trend
  scale_color_manual(values = c("Linear Model" = "#b1a570", 
                                "Mixed Effects" = "#6c6e72", 
                                "Segmented Trend" = "#d9c55c")) +  # Custom color mapping
  labs(
    x = "Year",
    y = "Mean Rao's Quadratic Entropy",
    color = "Trend Type" 
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12)
  )

```

```{r}
#| warning: false
#| message: false
#| echo: true
#| eval: true
#| include: true
#| fig-align: center
#| fig-cap: Species richness by year
#| label: fig-spp-rich-locs
#| cap-location: bottom
#| code-fold: true

spp_rich_location <- janp_main |>
  filter(!grepl('COTTONWOOD|MUSHROOM', location)) |>
  filter(data_type %in% c("legacy","single_visit_3_max","single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F) |>
  dplyr::select(location, year, species_code) |>
  distinct() |>
  group_by(location, year) |>
  summarise(species_count = n_distinct(species_code)) |>
  ungroup() |>
  inner_join(locs_summary, by = c("location" = "Location")) |>
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane")) |>
  filter(!(year == 2012 & ecoregion == "Montane"))

spp_rich_location |>
  ggplot(aes(x=as.factor(year), y=species_count, fill=year)) +
  geom_boxplot() +
  geom_point(alpha = 0.7, colour = "grey") +
  geom_smooth(method = "lm") +
  theme_bw() +
  facet_wrap(~ecoregion, ncol = 1) +
  scale_fill_viridis_c(option = "cividis") +
  xlab('Year') + ylab('Species richness per location') +
  guides(fill = guide_legend(title = "Year"))

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Shannon diversity index over years
#| label: fig-shannon
#| cap-location: bottom
#| code-fold: true

shannon_d
```

## Trends

```{r}
#| warning: false
#| echo: true
#| eval: false
#| message: false
#| include: true
#| results: hide
#| code-fold: true

janp_ready_trend <- janp_main |>
  inner_join(lc_150m, by = c("location" = "Point_ID")) |>
  inner_join(canopy_150m, by = c("location" = "Point_ID")) |>
  mutate(landcover = case_when(grepl('TEKARRA|VALLEY5', location) & year > 2024 ~ "Burned", TRUE ~ landcover)) |>
  distinct()

# Trend
run_trend <- function(spp, summary = TRUE) {
  
    # 1. Summarize per site-visit using max()
    janp_trend <- janp_ready_trend |>
      filter(!(data_type == "single_visit_0_max" & year < 2021)) |>
      filter(ecoregion %in% c("Alpine")) |>
      mutate(year = year(recording_date_time), 
             hour = hour(recording_date_time),
             julian = yday(recording_date_time)) |>
      dplyr::select(organization, project_id, longitude, latitude, location,
                    location_id, task_id, ecoregion, landcover, prop_cover,
                    VEGETATION_DENSITY, canopy_species, canopy_cover, avg_height, recording_date_time, observer, species_code,
                    individual_order, abundance, detection_time) |>
      distinct() |>
      wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","human","unknown"), zerofill = T)
    
    # 2. Combine with zero sites
    base_zero <- janp_trend |>
      dplyr::select(location, ecoregion, landcover, prop_cover, VEGETATION_DENSITY, canopy_species, canopy_cover, avg_height, recording_date_time, observer) |>
      distinct()
    
    spp_max <- janp_trend |>
      filter(species_code == spp) |>
      group_by(location, ecoregion, landcover, prop_cover, VEGETATION_DENSITY,  canopy_species, canopy_cover, avg_height, recording_date_time, observer, species_code) |>
      summarise(individual_order = max(individual_order, na.rm = TRUE)) |>
      ungroup()
    
    if (nrow(spp_max) < 20) {
      stop(paste0("Probably an error in Alpine with ", spp))
    }
    
    jpt <- base_zero |> 
      left_join(spp_max, by = c("location", "ecoregion", "landcover", "prop_cover", "VEGETATION_DENSITY", "canopy_species", "canopy_cover", "avg_height", "recording_date_time", "observer")) |>
      mutate(individual_order = tidyr::replace_na(individual_order, 0)) |> mutate(year = year(recording_date_time), hour = hour(recording_date_time), julian = yday(recording_date_time)) |>
      filter(!is.infinite(individual_order)) |> 
      mutate(canopy_species = factor(canopy_species), lc_group = case_when(landcover %in% c("Tree Coniferous", "Shrub Low", "Herbaceous Mixed", "Bedrock") ~ landcover, TRUE ~ "Other"), .after = landcover) |> 
      dplyr::select(-c(landcover, VEGETATION_DENSITY)) |> group_by(location, ecoregion, canopy_species, canopy_cover, avg_height, recording_date_time, observer, individual_order, year, hour, julian) |>
      pivot_wider(names_from = lc_group, values_from = prop_cover, values_fill = 0, values_fn = sum) |> 
      ungroup() |> 
      rename(shrub = `Shrub Low`, conf = `Tree Coniferous`, herb = `Herbaceous Mixed`, bedrock = `Bedrock`, other = Other) |> 
      mutate(across(c(shrub, conf, herb, other, bedrock, canopy_cover, avg_height, julian, hour), scale)) |> 
      distinct()

    fit <- svabu(individual_order ~ year + shrub + herb + conf + bedrock + canopy_cover + avg_height | julian + hour + observer + canopy_cover + avg_height, data = jpt)
    
    if(summary == TRUE) {
      
      fit_summary_alpine <- summary(fit)
      
    }

    ref_zero_infl <- jpt %>%
  summarise(
    observer = first(observer),  # factor
    julian   = mean(julian, na.rm = TRUE),
    hour     = mean(hour, na.rm = TRUE),
    canopy_cover = mean(canopy_cover, na.rm = TRUE),
    avg_height   = mean(avg_height, na.rm = TRUE)
  )
    
    newdata <- jpt %>%
  mutate(
    observer     = ref_zero_infl$observer,
    julian       = ref_zero_infl$julian,
    canopy_cover = ref_zero_infl$canopy_cover,
    avg_height   = ref_zero_infl$avg_height,
    hour         = ref_zero_infl$hour
  )
    
    jpt$lambda_hat <- predict(fit, newdata = newdata, type = "response")
    
    jpt <- jpt %>%
  mutate(lambda_hat = predict(fit, newdata = newdata, type = "response"))

lambda_year <- jpt %>%
  group_by(year) %>%
  summarise(lambda_hat = mean(lambda_hat, na.rm = TRUE)) %>%
  ungroup() %>%
  arrange(year)
    
    # 6. Run Mann-Kendall + Sen's slope
    x <- lambda_year$lambda_hat
    mk <- mmkh(x)
    tau       <- mk[6]
    sen_slope <- mk[7]
    p_value   <- mk[2]
    pct_change <- mk[["Sen's slope"]] / mean(x) * 100
    trend_class <- dplyr::case_when(pct_change >  2.5  ~ "Increasing",
                                    pct_change < -2.5  ~ "Decreasing",
                                    TRUE               ~ "Stable")
    
    trend_result_alpine <- tibble(
        ecoregion = "Alpine",
        tau          = tau,
        p_value      = p_value,
        sen_slope    = sen_slope,
        pct_change   = pct_change,
        trend        = trend_class
      )
    
    janp_trend <- janp_ready_trend |>
      filter(!(data_type == "single_visit_0_max" & year < 2021)) |>
      filter(ecoregion %in% c("Montane", "Upper Subalpine", "Lower Subalpine"), !grepl('COTTONWOOD|MUSHROOM', location), !year == 2012) |>
      mutate(year = year(recording_date_time), 
             hour = hour(recording_date_time),
             julian = yday(recording_date_time)) |>
      dplyr::select(organization, project_id, longitude, latitude, location,
                    location_id, task_id, ecoregion, landcover, prop_cover,
                    VEGETATION_DENSITY, canopy_species, canopy_cover, avg_height, recording_date_time, observer, species_code,
                    individual_order, abundance, detection_time) |>
      distinct() |>
      wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","human","unknown"), zerofill = T)
    
    # 2. Combine with zero sites
    base_zero <- janp_trend |>
      dplyr::select(location, ecoregion, landcover, prop_cover, VEGETATION_DENSITY, canopy_species, canopy_cover, avg_height, recording_date_time, observer) |>
      distinct()
    
    spp_max <- janp_trend |>
      filter(species_code == spp) |>
      group_by(location, ecoregion, landcover, prop_cover, VEGETATION_DENSITY,  canopy_species, canopy_cover, avg_height, recording_date_time, observer, species_code) |>
      summarise(individual_order = max(individual_order, na.rm = TRUE)) |>
      ungroup()
    
    if (nrow(spp_max) < 20) {
      next(paste0("Probably an error in Alpine with ", spp))
    }
    
    jpt <- base_zero |> 
      left_join(spp_max, by = c("location", "ecoregion", "landcover", "prop_cover", "VEGETATION_DENSITY", "canopy_species", "canopy_cover", "avg_height", "recording_date_time", "observer")) |>
      mutate(individual_order = tidyr::replace_na(individual_order, 0)) |> mutate(year = year(recording_date_time), hour = hour(recording_date_time), julian = yday(recording_date_time)) |>
      filter(!is.infinite(individual_order)) |> 
      mutate(canopy_species = factor(canopy_species), lc_group = case_when(landcover %in% c("Tree Coniferous", "Shrub Low", "Herbaceous Mixed", "Bedrock") ~ landcover, TRUE ~ "Other"), .after = landcover) |> 
      dplyr::select(-c(landcover, VEGETATION_DENSITY)) |> group_by(location, ecoregion, canopy_species, canopy_cover, avg_height, recording_date_time, observer, individual_order, year, hour, julian) |>
      pivot_wider(names_from = lc_group, values_from = prop_cover, values_fill = 0, values_fn = sum) |> 
      ungroup() |> 
      rename(shrub = `Shrub Low`, conf = `Tree Coniferous`, herb = `Herbaceous Mixed`, other = Other) |> 
      mutate(across(c(shrub, conf, herb, other, canopy_cover, avg_height, julian, hour), scale)) |> 
      distinct()

    fit <- svabu(individual_order ~ year + shrub + herb + conf + canopy_cover + avg_height | julian + hour + observer + canopy_cover + avg_height, data = jpt)

    if(summary == TRUE) {
      
      fit_summary_montane <- summary(fit)
      
    }
    
    ref_zero_infl <- jpt %>%
  summarise(
    observer = first(observer),  # factor
    julian   = mean(julian, na.rm = TRUE),
    hour     = mean(hour, na.rm = TRUE),
    canopy_cover = mean(canopy_cover, na.rm = TRUE),
    avg_height   = mean(avg_height, na.rm = TRUE)
  )
    
    newdata <- jpt %>%
  mutate(
    observer     = ref_zero_infl$observer,
    julian       = ref_zero_infl$julian,
    canopy_cover = ref_zero_infl$canopy_cover,
    avg_height   = ref_zero_infl$avg_height,
    hour         = ref_zero_infl$hour
  )
    
    jpt$lambda_hat <- predict(fit, newdata = newdata, type = "response")
    
    jpt <- jpt %>%
  mutate(lambda_hat = predict(fit, newdata = newdata, type = "response"))

lambda_year <- jpt %>%
  group_by(year) %>%
  summarise(lambda_hat = mean(lambda_hat, na.rm = TRUE)) %>%
  ungroup() %>%
  arrange(year)
    
    # 6. Run Mann-Kendall + Sen's slope
    x <- lambda_year$lambda_hat
    mk <- mmkh(x)
    tau       <- mk[6]
    sen_slope <- mk[7]
    p_value   <- mk[2]
    pct_change <- mk[["Sen's slope"]] / mean(x) * 100
    trend_class <- dplyr::case_when(pct_change >  2.5  ~ "Increasing",
                                    pct_change < -2.5  ~ "Decreasing",
                                    TRUE               ~ "Stable")
    
    trend_result_montane <- tibble(
        ecoregion = "Montane",
        tau          = tau,
        p_value      = p_value,
        sen_slope    = sen_slope,
        pct_change   = pct_change,
        trend        = trend_class
      )
  
    return(list(bind_rows(trend_result_alpine, trend_result_montane),fit_summary_alpine,fit_summary_montane))
    
}

```

```{r}
#| warning: false
#| echo: true
#| eval: false
#| message: false
#| include: true
#| results: hide
#| code-fold: true

safe_run_trend <- possibly(run_trend, otherwise = NA)

trendz <- janp_main |>
  group_by(species_code) |>
  tally() |>
  arrange(-n) |>
  filter(!(species_code %in% c("RESQ","NONE"))) |>
  slice(1:30) |>
  mutate(trend = map(species_code, safe_run_trend))


```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| code-fold: true

trend_table <- trendz %>%
  mutate(trend = map(trend, ~ if(!is.list(.x)) list(NA) else .x)) %>%
  mutate(trend = map(trend, 1)) %>%
  unnest_wider(trend, names_sep = "_") %>%
  unnest(cols = everything()) %>%
  mutate(across(where(is.numeric), ~ round(.x, 2)))

datatable(trend_table)

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| code-fold: true

trend_guild <- trend_table |>
  inner_join(guilds, by = "species_code")
  
kable(trend_guild |>
  group_by(trend_ecoregion) |>
  summarise(
    total_species = n_distinct(species_code),
    declining_species = n_distinct(species_code[pct_change <= -2.5]),
    percent_declining = declining_species / total_species * 100
  ))

kable(trend_guild |>
  group_by(trend_ecoregion, habitat_guild) |>   # or another guild column if desired
  summarise(
    total_guild_species = n_distinct(species_code),
    declining_guild_species = n_distinct(species_code[pct_change <= -2.5]),
    percent_declining = declining_guild_species / total_guild_species * 100
  ) |>
  ungroup() |>
  group_by(trend_ecoregion) |>
  summarise(
    total_guilds = n_distinct(habitat_guild),
    guilds_with_decline = sum(percent_declining > 0),
    percent_guilds_declining = guilds_with_decline / total_guilds * 100
  ))

```

## Discussion and recommendations

