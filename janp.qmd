---
title: "Report on the use of passive acoustic monitoring for analysis of bird trends in Jasper National Park"
format:
  html:
    grid:
      margin-width: 300px
navbar: right
theme: cosmo
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: 
  - name: "Alex MacPhail"
    affiliation: "Biodiversity Pathways Ltd."
  - name: "Brenda Shepherd"
    affiliation: "Parks Canada"
editor: visual
bibliography: references.bib
nocite: '@*'
toc: true
toc-depth: 3
toc-expand: true
prefer-html: true
toc-location: left
styles: styles.css
github: https://github.com/biodiversitypathways/janp
---

![](janp.png){style="float:left`;" fig-alt="Photo of Jasper" fig-align="center"}

```{r}
#| label: Load packages and authenticate to WildTrax
#| include: false
#| echo: false
#| eval: true
#| warning: false
#| message: false

library(tidyverse)
library(leaflet)
library(wildrtrax)
library(sf)
library(ggridges)
library(scales)
library(kableExtra)
library(ggrepel)
library(plotly)
library(DT)
library(lubridate)
library(spdep)
library(vegan)
library(lme4)
library(modifiedmk)
library(MuMIn)
library(mgcv)
library(MASS)
library(pscl)
library(segmented)
library(glmmTMB)
library(FD)
library(broom)

wt_auth()

load('janp.RData')
#save.image('janp.RData')
```

```{r}
#| label: Download data from WildTrax
#| warning: false
#| message: false
#| echo: false
#| eval: false
#| include: true

janp_aru_projects <- wildrtrax::wt_get_download_summary(sensor = 'ARU') |>
  filter(grepl('Jasper National Park', project)) |>
  dplyr::select(project_id) |>
  pull()

# All projects associated with a single-visit ARU deployment with no abundance cap
janp_0max <- wildrtrax::wt_get_download_summary(sensor = 'ARU') |>
  filter(grepl('Jasper NP - EI', project)) |>
  filter(!grepl('2021|2022',project)) |>
  dplyr::select(project_id) |>
  pull()

# All projects associated with a single-visit ARU deployment with an abundance cap of 3
janp_3max <- wildrtrax::wt_get_download_summary(sensor = 'ARU') |>
  filter(grepl('Jasper NP - EI', project)) |>
  filter(grepl('2021|2022',project)) |>
  dplyr::select(project_id) |>
  pull()

janp_project_lists <- list(
  multi_day = janp_aru_projects,
  single_visit_0_max = janp_0max,
  single_visit_3_max = janp_3max
)

janp_aru <- imap_dfr(
  janp_project_lists,
  ~ map_dfr(
      .x, 
      ~ wildrtrax::wt_download_report(
          project_id = .x,
          sensor_id = "ARU",
          weather_cols = TRUE,
          reports = "main"
        )
    ) |> mutate(data_type = .y, .after = organization) 
)

# Mountain Pine Beetle
mpb <- wildrtrax::wt_download_report(project_id = 2129, sensor_id = "ARU", weather_cols = TRUE, reports = "main")

# Bind legacy data with acoustic data
janp_main <- bind_rows(old_s_mean, janp_aru) |>
  group_by(location) |>
  fill(ecoregion, .direction = "down") |>
  ungroup() |>
  mutate(year = year(recording_date_time)) # Get year in as a variable

```

# Abstract

Since 2007, Jasper National Park has conducted passive acoustic monitoring as part of its ecological integrity monitoring program. After 17 years, we sought to analyze trends and extract insights from these data to inform ongoing monitoring and establish robust practices for future species monitoring. Our objective was to assess whether the abundance (count) of species and guilds shifted by ±2.5% in the alpine and montane ecoregions, respectively. Data management and processing were conducted in WildTrax, where legacy datasets from multiple methodologies were combined and harmonized. We evaluated whether the sampling locations were independent and then conducted trend analyses to examine changes in species counts over time across guilds and ecoregions.

::: {.callout-note collapse="true" style="background-color: #f4f4f4; padding: 20px;"}
This report is dynamically generated, meaning its results may evolve with the addition of new data or further analyses. For the most recent updates, refer to the publication date and feel free to reach out to the authors.
:::

# Land Acknowledgement

We respectfully acknowledge that Jasper National Park is located in Treaty 6 and 8 as well as the traditional lands of the Anishinabe, Aseniwuche Winewak, Dene-zaa, Nêhiyawak, Secwépemc, Stoney Nakoda, Mountain Métis and Métis. We acknowledge the past, present, and future generations of these nations who continue to steward the land.

# Introduction

Human activities have been identified as key pressures and contributors to the global decline in forest wildlife (@allan2017recent). The repercussions of habitat fragmentation (@fahrig2003effects) and loss (@hanski2011habitat), climate change (@mantyka2012interactions, @sattar2021review, @abrahms2023climate), and increased access to sensitive areas exert direct and indirect pressures on forest biodiversity, particularly in managed regions in Canada (@lemieux2011state). Climate change and increasing wildfire activity in Alberta's Rocky Mountain Natural Region have significantly impacted montane bird monitoring; in 2023, two of the park's three long-term montane monitoring transects were affected by wildfires, while the third is currently undergoing wildfire risk reduction measures.

Since 2007, Jasper National Park initiated a program incorporating autonomous recording units (ARUs) for passive acoustic monitoring of the Park's vocalizing wildlife. ARUs are compact environmental sensors that are designed to passively record the environment (@aru-overview), capturing vocalizing species like birds and amphibians, which is growing in use across the globe (@lots-of-pam). This technology enables resource managers to conduct prolonged surveys with minimal human interference. The subsequent data collected by these units contribute valuable information to ecological integrity metrics such as species richness, diversity, occupancy, and trends over time. This data aids decision-making and management within the Park. Given the rapid and ease of accumulating data from these units, maintaining a high standard of data integrity is paramount to ensure future data interoperability and sharing. [WildTrax](https://www.wildtrax.ca) is an online platform developed by the [Alberta Biodiversity Monitoring Institute (**ABMI**)](https://abmi.ca) for users of environmental sensors to help addresses these big data challenges by providing solutions to standardize, harmonize, and share data.

The project will analyze Jasper’s bird point count data from 2007 to 2024, assessing trends in species and guild abundance while accounting for the clustering of survey points within transects. Separate analyses will be conducted for montane and sub-alpine and alpine ecoregions to align with Ecological Integrity reporting requirements, determining time-to-first-detection usability in analysis. To enhance accessibility and reproducibility, the findings will be presented in this online report with fully documented code, allowing future updates as data collection methods become standardized. Additionally, recommendations will be developed to refine data transcription priorities, improve annual reporting methods, and evaluate species guild classifications for long-term monitoring. The objectives of this report are to:

-   Describe the data management and processing procedures for the acoustic data collected from 2007 to 2024;
-   Comparing data processing methods on count of species and individuals heard on recordings;
-   Report on transects in montane/sub-alpine and alpine ecoregions, including time-to-first-detection where possible, with key metrics such as the percentage of bird species and guilds declining by ≥2.5% in both montane/sub-alpine and alpine regions.
-   Recommendations for prioritizing previous years’ data for re-transcription to 1SPT, determine the best approach for annual reporting, e.g. baseline comparisons or 10-year trend assessments, adjust methods for evaluating species trends against thresholds, and review guilds and traits used in assessments
-   Facilitate data publication to the public, resource managers, academic institutions, and any other relevant agencies

# Methods

## Data collection

Songbird data was collected using autonomous recording units (ARUs), deployed by field staff to capture one 10-minute recording per point count annually. Surveys were scheduled consistently each breeding season in June and early July, starting at dawn. Technicians walked transects containing ten points, each spaced at least 300 m apart to prevent duplicate detections and ensure independence of locations. At each location, the ARU is set up, and technicians move 10–20 m away to minimize disturbance, allowing at least 11 minutes of recording. Recordings were then clipped and organized to only include the 10-minute count.

```{r}
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| include: true
#| fig-align: center
#| fig-cap: Locations from Jasper National Park ARU Monitoring Program. Includes acoustic monitoring locations for other collaborative projects. Ecoregions were not classified for Other sites but only EI Monitoring locations.
#| label: fig-aru-monitoring-locations

janp_locs <- janp_main |>
  dplyr::select(location, latitude, longitude, year, ecoregion) |>
  drop_na(latitude) |>
  distinct() |>
  dplyr::mutate(type = case_when(grepl('BAT', location) ~ "Bat", TRUE ~ "Bird")) |>
  sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326)

# Create mpb_in_janp
mpb_sf <- mpb |>
  mutate(year = year(recording_date_time)) |>
  dplyr::select(location, year, latitude, longitude) |>
  distinct() |>
  drop_na(latitude, longitude) |>
  sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326)
mpb_in_janp <- st_intersection(mpb_sf, janp_shp)

# Combine
janp_locs_map <- janp_locs |> 
  bind_rows(mpb_in_janp) |>
  dplyr::select(location, year, ecoregion, geometry) |>
  mutate(ecoregion = case_when(
    grepl("^JANP", location) ~ "Other ARU Monitoring", 
    grepl("MPB", location) ~ "Mountain Pine Beetle Project", 
    TRUE ~ ecoregion
  ))

# Generate summary table
locs_summary <- janp_locs_map |>
  st_drop_geometry() |>
  group_by(location, ecoregion, year) |>
  distinct() |>
  mutate(value = row_number()) |>
  ungroup() |>
  arrange(year) |>
  pivot_wider(names_from = year, values_from = value, values_fill = 0) |>
  rename('Location' = location)

# Map visualization
pal <- colorFactor(
  palette = "Set3", 
  domain = janp_locs_map$ecoregion
)

leaflet() %>%
  addTiles() %>%
  addPolygons(
    data = janp_shp,
    color = "black",
    weight = 1,
    fillOpacity = 0.4,
    popup = ~paste("Park:", adminAreaN)
  ) %>%
  addCircleMarkers(
    data = janp_locs_map,
    popup = ~paste("Location:", location, "<br>"),
    fillColor = ~pal(ecoregion),  
    fillOpacity = 1,
    color = "black", 
    radius = 6 
  ) %>%
  addLegend(
    "topright",
    pal = pal,
    values = janp_locs_map$ecoregion,
    title = "Ecoregion",
    opacity = 1
  ) %>%
  addMeasure(primaryLengthUnit = "meters", primaryAreaUnit = "sqmeters") %>%
  addMiniMap(position = "bottomleft")

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| label: tbl-loc-summary
#| collapse: true
#| code-fold: true
#| tbl-cap: Locations surveyed across years. Ones indicated a deployment in that year for that location.

datatable(locs_summary, 
          options = list(
            searching = TRUE,  
            paging = TRUE,    
            pageLength = 10   
          )) |>
  formatStyle(columns = colnames(locs_summary), 
              backgroundColor = styleEqual(c("NA"), "lightgray"))  
```

## Location correlation {#sec-location-correction}

To assess spatial autocorrelation among bird survey locations in Jasper National Park, we examined the spatial relationship between survey points based on total species abundance per location and year. Given that survey points are approximately 300 meters apart, we used the `knearneigh()` function to identify the nearest neighbours within this threshold. This function calculates the closest neighboring survey points for each location. We then constructed a spatial weight matrix using the `knn2nb()` function and calculated Moran's *I* statistic using `moran.test` to determine whether spatial autocorrelation exists in the abundance of species across survey locations. A significant Moran's *I* suggests that survey locations are not independent and that spatial autocorrelation should be accounted for in further analyses. We also conducted further analyses grouping locations from each transect (`r paste(unique(janp_transects$transect_name), collapse = ", ")`).

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: false
#| include: true
#| code-fold: true

# Create an object that defines the EI transects

janp_transects <- janp_main |>
  filter(!grepl('^JANP|^MPB',location)) |>
  filter(data_type %in% c("legacy","single_visit_3_max","single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F) |>
  dplyr::select(location) |>
  distinct() |>
  separate(location, into = c("transect_name", "station_id"), remove = FALSE)

```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: false
#| include: true
#| code-fold: true

janp_total_count <- janp_main %>%
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  wt_replace_tmtt(calc = "round") |>
  group_by(location, year, species_code) %>%
  summarise(n = max(individual_order, na.rm = TRUE), .groups = "drop") %>%
  group_by(location, year) %>%
  summarise(n = sum(n, na.rm = TRUE), .groups = "drop")

janp_locs_sf <- janp_locs %>%
  distinct(location, ecoregion, geometry) %>%
  inner_join(janp_total_count, by = "location") %>%
  st_as_sf()

janp_locs_sf <- janp_locs_sf %>%
  mutate(n = as.numeric(n)) %>%
  filter(!is.na(n))

coords <- st_coordinates(janp_locs_sf)
neighbours <- knn2nb(knearneigh(coords, k = 1, longlat = TRUE))
weights <- nb2listw(neighbours, style = "W", zero.policy = TRUE)
moran_test <- moran.test(janp_locs_sf$n, listw = weights, zero.policy = TRUE)
```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true  # Change this to true to display the output

moran_test

```

## Data management, processing and quality control

Before adopting WildTrax, analysts excluded the initial 20 seconds to 1.5 minutes of recordings to reduce human impact on detection probability, then logged the first detection time per species. Recordings are now uploaded as clean 10-minute files with the voice note and observer noise removed. Transcription methods varied over time @tbl-transcriptions, possibly affecting data consistency, from both a detectability and methodological standpoint. To ensure comparability, we examined the effect of using the mean and maximum abundance of species on trend. We used generalized linear mixed models (GLMM) using the `lme4` with package (@bates2015parsimonious) to also examine time-to-first detection and the differences it posed across years to account for detection probability differences, using location as random effect (`1 | location`). In WildTrax, individuals were counted by users scanning both the spectrogram and listening to the audio output. Tags were then drawn to encompass the signal within the methods indicated in each project (see @tbl-transcriptions and @fig-acousticprocessing). Transcribers also had site photos available (see @fig-visitphotos) to optimize their species identification by having *in situ* habitat context while processing.

![WildTrax Acoustic Processing Interface (Version 1)](acousticprocessing.png){#fig-acousticprocessing .float-left .fig-align-center}

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| label: tbl-transcriptions
#| collapse: true
#| code-fold: true
#| tbl-cap: Transcription method by year with re-transcribed data being conducted from 2007 - 2012.

transcription_table <- tibble(
  Years = c("2007-2020", "2021-2022", "2023-2024", "2007-2011"),
  `Transcription Method` = c(
    "0-3.33, 3.33-6.66, 6.66-10 min",
    "1 SPT - Species per task or recording (Every new individual is tagged within the 10 minute recording).",
    "1 SPT - Species per task or recording (Every new individual is tagged within the 10 minute recording).",
    "1 SPT - Species per task or recording (Every new individual is tagged within the 10 minute recording). Re-transcription."
  ),
  `Bin Method` = c(
    "Abundance re-starts for each 3.33-minute bin",
    "Time of first detection over 10 minute period",
    "Time of first detection over 10 minute period",
    "Time of first detection over 10 minute period. Re-transcription."
  ),
  `Method Details` = c(
    "No cap on abundance; abundance re-starts for each bin, no total abundance for the 10-min recording",
    "Time of first detection over 10 minute period",
    "Time of first detection over 10 minute period",
    "Time of first detection over 10 minute period. Re-transcription."
  ),
  `Max # of Individuals` = c(
    "No cap",
    "Maximum of 3 individuals per 10-minute recording",
    "No cap",
    "No cap. Re-transcription."
  )
)

transcription_table


# Render the datatable
datatable(transcription_table, 
          options = list(
            searching = TRUE,  
            paging = TRUE,    
            pageLength = 10   
          )) |>
  formatStyle(columns = colnames(transcription_table), 
              backgroundColor = styleEqual(c("NA"), "lightgray"))  


```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: tbl-verified
#| tbl-cap: Proportion of tags verified. NA evaluated tags were from legacy acoustic data, not including re-transcriptions for method comparison in WildTrax.

all_tags <- janp_main |>
  tally() |>
  pull()

verified_tags <- janp_main |>
  group_by(tag_is_verified) |>
  tally() |>
  ungroup() |>
  mutate(Proportion = round(n / all_tags,4)*100) |>
  rename("Count" = n) |>
  rename("Tag is verified" = tag_is_verified)

kable(verified_tags)

```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: tbl-tmtt
#| tbl-cap: Too many to count (TMTT) tags in WildTrax

tmtt_tags <- janp_main |>
  dplyr::select(location, recording_date_time, species_code, individual_count) |>
  distinct() |>
  filter(individual_count == "TMTT") |>
  mutate(recording_date_time = format(recording_date_time, "%Y-%m-%d %H:%M:%S"))

datatable(tmtt_tags, 
          options = list(
            searching = TRUE,  
            paging = TRUE,    
            pageLength = 10   
          )) |>
  formatStyle(columns = colnames(tmtt_tags), 
              backgroundColor = styleEqual(c("NA"), "lightgray"))

```

![Visit photos at PYRAMID-6](visitphotos.png){#fig-visitphotos .float-left .fig-align-center}

## Analyses

::: {.callout-warning collapse="true" style="background-color: #f4f4f4; padding: 20px;"}
For the purpose of these analyses abundance was defined as the count of individuals detected during point counts, rather than as a density x area relationship.
:::

We analyzed bird abundance trends in Jasper National Park from 2007 to 2024 across multiple scales, including individual species, specific locations, grouped transects, ecoregions, and functional guilds. This multi-level approach allowed us to assess patterns of abundance while accounting for ecological and functional groupings. All analyses took place in R 4.4.2 'Pile of Leaves'. Observations were first filtered to include only data from the EI monitoring sites containing ecoregional classification, with species being classified into functional guilds using an ecological trait database (see @tbl-guilds). Spatial clustering was addressed by grouping data by individual locations and transects (see Section [Location correlation](#sec-location-correlation)). To address potential biases in detectability, we used time-to-first-detection (TTFD) in a count-removal framework (@farnsworth) to model detectability differences across species, locations, and sampling methods, following the approach outlined in @solymos2013calibrating. By integrating offsets based on detectability into our final models, we controlled for variability in detection probabilities across methods, ensuring that observed trends in species abundance reflected true ecological patterns rather than methodological artifacts.

A redundancy analysis (RDA) was conducted using the `vegan` package (@vegan2025) to quantify the variation in community composition explained by ecoregions and to visualize species–ecoregion relationships with ordination plots (see @Rao1964). Species‑level observations were aggregated into a species‑by‑location matrix, with abundances recorded as the maximum count of each species at each location and transect. Ecoregions were categorized into Alpine and Montane groups, with the latter further divided into Upper Subalpine, Lower Subalpine, and Montane zones for all subsequent analyses. Differences in composition between Alpine and Montane groups were tested using permutational multivariate analysis of variance (PERMANOVA; @Anderson2001) on Bray–Curtis dissimilarities with 999 permutations under a reduced model.

Generalized linear mixed‑effects models (GLMMs, @bates2015parsimonious) were implemented in R using the `lme4` package (@bates2015lme4) to analyze abundance trends for 20 species (`r paste(mdm, collapse = ", ")` that were the most abundant and represented different guilds for the single-species analyses. Count data were modeled with a Poisson distribution or a negative binomial distribution when overdispersion was detected. With year and data_type (transcription methodology) as fixed effects, location was included as a random effect in the models. Separate models were fitted for montane/subalpine versus alpine ecoregions. Model selection was based on minimum values of Akaike’s Information Criterion (AIC; @akaike1974).

To evaluate trend significance we applied the Mann–Kendall test (@mann1945non, @hamed1998; non‑parametric and sensitive to monotonic trends [@birds6010014]) and estimated trend magnitude with Sen’s Slope (@Sen01121968; @dawood2017spatio) using the `mmkh()` function from the `modifiedmk` package. Functional diversity was quantified with Rao’s Q (@rao1982diversity; @laliberte2010adistance) using the `dbFD()` function in the `FD` package (@FDpackage) to examine shifts in guild‑level trait diversity over time. Species richness, representing the count of unique species, was summarized per location and plotted over time to assess local biodiversity dynamics (@fig-spp-rich-locs). Shannon’s diversity index, which incorporates species richness and evenness, was calculated annually to analyze temporal changes in community structure (@fig-shannon). These metrics provide complementary perspectives on biodiversity trends across locations and years.

Finally, breakpoint analysis was performed using the `segmented` package (@segmented2008) to identify significant shifts in abundance trends. Segmented models detected structural changes in trend slopes, ensuring that phase‑specific dynamics were not masked by overall trend estimates (see @smith2015change).

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: fig-comp
#| fig-cap: Comp

# Jasper species
mdm <- c("AMPI","AMRO","BRSP","CHSP","DEJU","GCKI","HETH","FOSP","OCWA","RCKI","SWTH","VATH","WAVI","WCSP","WTSP","GCSP","YRWA","RBNU","LISP","MOCH")

comp <- janp_main |>
  mutate(year = lubridate::year(recording_date_time)) |>
  group_by(location, recording_date_time) |>
  mutate(unique_data_types = n_distinct(data_type)) |>
  ungroup() |>
  filter(unique_data_types == 2, species_code %in% mdm) |>
  group_by(year, location, recording_date_time, data_type, species_code) |>
  summarise(mean = mean(individual_order)) |>
  ggplot(aes(x = data_type, y = mean, group = data_type)) +
  geom_boxplot() +
  theme_bw()

comp

```

# Results

::: {.callout-note collapse="true" style="background-color: #f4f4f4; padding: 20px;"}
Some of these analyses are still a work-in-progress. Check back soon for updates and additional details.
:::

## Ecoregional analysis

@fig-community shows the relationship between species and ecoregion. The RDA can determine how much variation in community composition is explained by these factors and visualize species-environment relationships through ordination plots. The PERMANOVA test was performed using Bray-Curtis dissimilarity to assess whether community composition significantly differed between ecoregion groups. The analysis revealed a significant difference in community composition between alpine and montane groups. The ecoregion grouping explained approximately 27.85% of the variation in community composition, while residual variation accounted for 72.15%. These findings indicate a substantial divergence in species composition between ecoregion groups for subsequent analyses looking at trend differences between these areas.

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: fig-community
#| tbl-cap: Community matrix

comm_matrix <- janp_main |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  wt_replace_tmtt(calc = "round") |>
  dplyr::select(-ecoregion) |>
  inner_join(locs_summary, by = c("location" = "Location")) |>
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane")) |>
  group_by(location, ecoregion, species_code) |>
  summarise(individual_order = max(individual_order)) |>
  ungroup() |>
  pivot_wider(names_from = species_code, values_from = individual_order, values_fill = 0) |>
  drop_na(ecoregion)

multi_type <- comm_matrix  %>%
  dplyr::select(location, ecoregion) %>%
  distinct() %>%
  drop_na()

t3 <- rda(comm_matrix[,-c(1:2)] ~ ecoregion + location, data = multi_type)
t3scores <- scores(t3, display = "sites") %>%
as.data.frame() %>%
rownames_to_column("site") %>%
bind_cols(., multi_type)
t3vect <- scores(t3, display = "species") %>%
as.data.frame()

plot_RDA <- ggplot(data = t3scores, aes(x = RDA1, y = RDA2)) +
  geom_point(data = t3scores, aes(x = RDA1, y = RDA2, colour = ecoregion), 
             alpha = 0.7, size = 3, shape = 16) +
  stat_ellipse(data = t3scores, aes(colour = ecoregion), 
               linetype = 1, type = 'norm', level = 0.67, size = 1) +
  geom_vline(xintercept = 0, color = "#A19E99", linetype = 2, size = 1) +
  geom_hline(yintercept = 0, color = "#A19E99", linetype = 2, size = 1) +
  geom_segment(data = t3vect, aes(x = 0, y = 0, xend = RDA1, yend = RDA2), 
               arrow = arrow(length = unit(0.2, "cm")), size = 0.3) +
  geom_text_repel(data = t3vect, aes(x = RDA1, y = RDA2, label = rownames(t3vect)), 
                  size = 3, colour = "black", fontface = "italic", 
                  max.overlaps = 10, 
                  segment.color = "grey70") +
  theme_bw() +
  scale_colour_viridis_d(option = "cividis", end = 0.9) +
  labs(x = "RDA1", y = "RDA2", title = "RDA Plot of Ecoregions and Species", 
       colour = "Ecoregion") +
  theme(legend.position = "right", 
        legend.title = element_text(size = 10), 
        legend.text = element_text(size = 9), 
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))

plot_RDA
```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: permanova
#| tbl-cap: PERMANOVA test

comm_matrix_data <- comm_matrix[, -c(1:2)] # Exclude location and ecoregion columns
ecoregion_group <- comm_matrix$ecoregion

# Perform PERMANOVA
permanova_result <- adonis2(comm_matrix_data ~ ecoregion_group, data = comm_matrix, method = "bray", permutations = 999)

print(permanova_result)
```

## Guild analysis

Activity patterns across nesting, dietary and migratory guilds are illustrated in @fig-spp-activity-guilds. A notable pattern emerges across all four guilds of the proportion of tags detected being detected later in the alpine ecoregion compared to the montane ecoregion.

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| label: tbl-guilds
#| collapse: true
#| code-fold: true
#| tbl-cap: Guilds

guilds <- read_csv("jasper_guilds.csv")

guild_activity <- janp_main |>
  filter(data_type %in% c("legacy", "single_visit_3_max", "single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal", "amphibian", "abiotic", "insect", "unknown"), zerofill = T) |>
  dplyr::select(location, recording_date_time, species_common_name, species_code, individual_count) |>
  mutate(julian = lubridate::yday(recording_date_time),
         month = month(recording_date_time),
         year = factor(year(recording_date_time))) |>
  inner_join(guilds, by = "species_code") |>
  group_by(species_code) |>
  add_tally() |>
  ungroup() |>
  group_by(julian, species_code) |>
  add_tally() |>
  ungroup() |>
  arrange(species_code) |>
  mutate(recording_date_time = as.POSIXct(recording_date_time)) |>
  mutate(species_code = factor(species_code, levels = sort(unique(species_code)))) |>
  inner_join(locs_summary, by = c("location" = "Location")) |>
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine", "Lower Subalpine", "Montane") ~ "Montane"))


datatable(guilds, 
          options = list(
            searching = TRUE,  
            paging = TRUE,    
            pageLength = 10   
          ))

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Seasonal detection activity of by nesting guild and ecoregion
#| label: fig-spp-activity-nesting
#| cap-location: margin
#| code-fold: true

ggplot(guild_activity, aes(x = julian, y = habitat_guild, fill = habitat_guild)) + 
      geom_density_ridges(alpha = 0.7) +
      scale_fill_viridis_d(option = "cividis") +
      facet_wrap(~ecoregion) +
      theme_bw() +
      xlab("Day of Year") + 
      ylab("Species")

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Seasonal detection activity of by migratory guild and ecoregion
#| label: fig-spp-activity-migratory
#| cap-location: margin
#| code-fold: true

ggplot(guild_activity, aes(x = julian, y = migratory_guild, fill = migratory_guild)) + 
      geom_density_ridges(alpha = 0.7) +
      scale_fill_viridis_d(option = "cividis") +
      facet_wrap(~ecoregion) +
      theme_bw() +
      xlab("Day of Year") + 
      ylab("Species")

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Seasonal detection activity of by trait and ecoregion
#| label: fig-spp-activity-trait
#| cap-location: margin
#| code-fold: true

ggplot(guild_activity, aes(x = julian, y = trait, fill = trait)) + 
      geom_density_ridges(alpha = 0.7) +
      scale_fill_viridis_d(option = "cividis") +
      facet_wrap(~ecoregion) +
      theme_bw() +
      xlab("Day of Year") + 
      ylab("Species")

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Seasonal detection activity of by dietary guild and ecoregion
#| label: fig-spp-activity-dietary
#| cap-location: margin
#| code-fold: true

ggplot(guild_activity, aes(x = julian, y = dietary_guild, fill = dietary_guild)) + 
      geom_density_ridges(alpha = 0.7) +
      scale_fill_viridis_d(option = "cividis") +
      facet_wrap(~ecoregion) +
      theme_bw() +
      xlab("Day of Year") + 
      ylab("Species")

```

Rao’s Q averaged between about 8.2 and 10.5 across survey locations, with a clear upward tendency over time (@fig-raos-q). The non‑parametric Mann–Kendall test gave a Kendall’s τ of 0.32 (p ≈ 0.07), indicating a positive but marginally non‑significant monotonic increase in functional diversity. A simple linear regression of mean Rao’s Q against year yielded a slope of 0.051 units per year (p ≈ 0.06), again suggesting an upward trend that narrowly misses the conventional 0.05 significance threshold. When we account for repeated measures at each location via a mixed‑effects model (random intercepts by location), the year effect becomes highly significant (slope = 0.058 Rao’s Q units per year; t ≈ 4.3), demonstrating that functional diversity has increases when location‑level variation is considered. Finally, breakpoint analysis identifies a shift around 2009, suggesting that functional diversity was relatively low and stable from 2007–2009, then rose to more variable but generally higher values from 2010 onward.

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Mean functional diversity (Rao's Q) over time
#| label: fig-raos-q
#| cap-location: margin
#| code-fold: true

abund_sp <- janp_main %>%
  group_by(location, year, species_code) %>%
  summarise(abund = n(), .groups = "drop") %>%
  pivot_wider(id_cols = c(location, year),
              names_from  = species_code,
              values_from = abund,
              values_fill = 0)

trait_df <- guilds %>%
  dplyr::select(species_code, dietary_guild, habitat_guild, migratory_guild) %>%
  distinct() %>%
  column_to_rownames("species_code")

trait_mat <- model.matrix(~ dietary_guild + habitat_guild + migratory_guild - 1,
                          data = trait_df)

a_mat <- abund_sp %>% dplyr::select(-location, -year) %>% as.matrix()

common <- intersect(colnames(a_mat), rownames(trait_mat))
a_mat2     <- a_mat[, common, drop = FALSE]
trait_mat2 <- trait_mat[common, , drop = FALSE]

nonzero   <- rowSums(a_mat2) > 0
a_mat3    <- a_mat2[nonzero, , drop = FALSE]
sites3    <- abund_sp[nonzero, c("location","year")]

fd <- dbFD(x = trait_mat2, a = a_mat3, calc.FRic = FALSE, calc.CWM = FALSE, messages = FALSE)

loc_year_rao <- sites3 %>%
  mutate(RaoQ = fd$RaoQ)

yearly_rao <- loc_year_rao %>%
  group_by(year) %>%
  summarise(meanRao = mean(RaoQ), .groups = "drop")

mk        <- mmkh(yearly_rao$meanRao, ci = 0.95)
lm_trend  <- lm(meanRao ~ year, data = yearly_rao)
mix_trend <- lmer(RaoQ ~ year + (1|location), data = loc_year_rao)
seg       <- segmented(lm(meanRao ~ year, data = yearly_rao), seg.Z = ~ year)

yearly_rao <- yearly_rao |>
  mutate(
    lm_fit = predict(lm_trend, newdata = yearly_rao),
    mix_fit = predict(mix_trend, newdata = yearly_rao, re.form = NA),
    seg_fit = predict(seg, newdata = yearly_rao)
  )

ggplot(yearly_rao, aes(x = year, y = meanRao)) +
  geom_point(color = "#213b6e", size = 2) +  # Points for yearly Rao
  geom_line(aes(y = lm_fit, color = "Linear Model"), size = 1.2, linetype = "dashed") +
  geom_line(aes(y = mix_fit, color = "Mixed Effects"), size = 1.2, linetype = "dotted") +
  geom_line(aes(y = seg_fit, color = "Segmented Trend"), size = 1.2) +  # Segmented trend
  scale_color_manual(values = c("Linear Model" = "#b1a570", 
                                "Mixed Effects" = "#6c6e72", 
                                "Segmented Trend" = "#d9c55c")) +  # Custom color mapping
  labs(
    title = "Trends in Mean Rao's Q",
    subtitle = "Linear Model, Mixed Effects, and Segmented Trends",
    x = "Year",
    y = "Mean Rao's Quadratic Entropy",
    color = "Trend Type"  # Legend title
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12)
  )

```

```{r}

res_raos_q

```

## Species richness and diversity trends

Species richness per location is at @fig-spp-rich-locs and Shannon's diversity index over years at @fig-shannon. Overall, both richness and diversity were stable across years.

```{r}
#| warning: false
#| message: false
#| echo: true
#| eval: true
#| include: true
#| fig-align: center
#| fig-cap: Species richness by year
#| label: fig-spp-rich-locs
#| cap-location: bottom
#| code-fold: true

spp_rich_location <- janp_main |>
  filter(data_type %in% c("legacy","single_visit_3_max","single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F) |>
  dplyr::select(location, year, species_code) |>
  distinct() |>
  group_by(location, year) |>
  summarise(species_count = n_distinct(species_code)) |>
  ungroup() |>
  inner_join(locs_summary, by = c("location" = "Location")) |>
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane"))

spp_rich_location |>
  ggplot(aes(x=as.factor(year), y=species_count, fill=year)) +
  geom_boxplot() +
  geom_point(alpha = 0.7, colour = "grey") +
  geom_smooth(method = "lm") +
  theme_bw() +
  facet_wrap(~ecoregion) +
  scale_fill_viridis_c(option = "cividis") +
  xlab('Year') + ylab('Species richness per location') +
  coord_flip()

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Shannon diversity index over years
#| label: fig-shannon
#| cap-location: bottom
#| code-fold: true

shannon_d <- janp_main |> 
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F) |>
  inner_join(wt_get_species() |> dplyr::select(species_code, species_class, species_order), by = "species_code") |>
  dplyr::select(location, recording_date_time, species_code, species_common_name, individual_order, individual_count) |>
  distinct() |>
  group_by(location, recording_date_time, species_code, species_common_name) |>
  summarise(count = max(individual_order)) |>
  ungroup() |>
  pivot_wider(names_from = species_code, values_from = count, values_fill = 0) |>
  pivot_longer(cols = -(location:species_common_name), names_to = "species", values_to = "count") |>
  group_by(location, year = year(recording_date_time), species) |>
  summarise(total_count = sum(count)) |>
  ungroup() |>
  group_by(location, year) |>
  summarise(shannon_index = diversity(total_count, index = "shannon")) |>
  ungroup() |>
  ggplot(aes(x = factor(year), y = shannon_index, fill = factor(year))) +
  geom_boxplot() +
  geom_point(alpha = 0.6, colour = "grey") +
  labs(x = "Year",
       y = "Shannon diversity index per location") +
  theme_bw() +
  guides(fill = guide_legend(title = "Year")) +
  scale_fill_viridis_d(alpha = 0.8, option = "cividis")

shannon_d
```

## Abundance trend analysis

This section presents the normalized species abundance trends for twenty specis, with plots illustrating changes over time across dietary, migratory, and habitat guilds and annual counts broken down by alpine and montane ecoregions (@fig-annual-count), complemented by a table summarizing linear model outputs for species trends (@tbl-normalized-count-mdm-year) using the total number of unique individuals identified in each ecoregion and year. The primary objective was to identify any significant trends in species abundance changes over time while accounting for survey effort, measured as the number of locations surveyed annually. We observed approximately a significant 3% and 1% increase overall in species abundance over the study period, with an R\^2 of 0.804 and 0.370 for the alpine and montane ecoregions, respectively.

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-width: 8
#| fig-height: 8
#| fig-cap: Normalized count of mean number of individuals detected for twenty species by year
#| label: fig-normalized-count-mdm-year-alpine
#| cap-location: margin

z <- locs_summary |>
  rowwise() |>
  mutate(sum = sum(across(`2007`:`2024`))) |>
  filter(sum == 17)

# Jasper species
mdm <- c("AMPI","AMRO","BRSP","CHSP","DEJU","GCKI","HETH","FOSP","OCWA","RCKI","SWTH","VATH","WAVI","WCSP","WTSP","GCSP","YRWA","RBNU","LISP","MOCH")

tot_a <- janp_main |>
  filter(data_type %in% c("legacy","single_visit_3_max","single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F)

prop_tidy <- nrow(tot_a) / nrow(janp_main)

tot_a_mdm <- tot_a |>
  filter(species_code %in% mdm)

prop_a <- nrow(tot_a_mdm) / nrow(tot_a)

plot_mdm <- 
  tot_a_mdm |>
  mutate(year = year(recording_date_time)) |>
  dplyr::select(location, data_type, ecoregion, year, species_code, individual_order, individual_count) |>
  group_by(location, data_type, ecoregion, year, species_code) |>
  summarise(individual_order = mean(individual_order)) |>
  ungroup() |>
  mutate(year = round(year,0)) |>
  group_by(year, location, ecoregion, data_type, species_code) |>
  summarise(
    total_abundance = sum(individual_order),  
    sample_size = n_distinct(location)
  ) |>
  ungroup() |>
  mutate(normalized_count = total_abundance / sample_size) |>
  inner_join(wt_get_species() |> dplyr::select(species_code, species_common_name), by = "species_code") |>
  inner_join(guilds, by = "species_common_name") |>
  mutate(ecoregion = case_when(
    ecoregion == "Alpine" ~ "Alpine",
    ecoregion %in% c("Upper Subalpine", "Lower Subalpine", "Montane") ~ "Montane"
  ))

plot_mdm_alpine <- plot_mdm %>%
  filter(ecoregion == "Alpine")

# Plot for Alpine
ggplot(plot_mdm_alpine, aes(x = year, y = normalized_count, colour = species_code.x)) +
  geom_smooth(method = "lm") +
  geom_point(size = 2) +
  labs(
    x = "Year",
    y = "Normalized Count",
    title = "Normalized Count of Species Abundance in Alpine Ecoregion",
    colour = "Species Code"
  ) +
  scale_colour_viridis_d(option = "cividis") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~species_code.x)

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-width: 8
#| fig-height: 8
#| fig-cap: Normalized count of mean number of individuals detected for twenty species by year
#| label: fig-normalized-count-mdm-year-montane
#| cap-location: margin

plot_mdm_montane <- plot_mdm %>%
  filter(ecoregion == "Montane")

# Plot for montane
ggplot(plot_mdm_montane, aes(x = year, y = normalized_count, colour = species_code.x)) +
  geom_smooth(method = "lm") +
  geom_point(size = 2) +
  labs(
    x = "Year",
    y = "Normalized Count",
    title = "Normalized Count of Species Abundance in Montane Ecoregion",
    colour = "Species Code"
  ) +
  scale_colour_viridis_d(option = "cividis") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~species_code.x)


```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| label: tbl-normalized-count-mdm-year
#| collapse: true
#| code-fold: true
#| tbl-cap: Linear models of species trends using normalized mean count per location

datatable(
  plot_mdm |>
    group_by(species_code.x) |>
    summarise(models = list(
      lm(normalized_count ~ year + data_type, data = cur_data())
    )) |>
    mutate(model_summary = map(models, tidy)) |>
    unnest(model_summary) |>
    dplyr::select(-models) |>
    mutate(across(where(is.numeric), round, 2)),
  options = list(
    searching = TRUE,
    paging = TRUE,
    pageLength = 10
  )
)

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Annual count of twenty bird species in Jasper 
#| label: fig-annual-count
#| cap-location: bottom
#| code-fold: true

# Aggregate and normalize data
count_annual_mdm <- tot_a_mdm |>
  mutate(ecoregion = case_when(
    ecoregion == "Alpine" ~ "Alpine",
    ecoregion %in% c("Upper Subalpine", "Lower Subalpine", "Montane") ~ "Montane"
  )) |>
  mutate(year = year(recording_date_time)) |>
  dplyr::select(location, ecoregion, year, species_code, individual_order, individual_count) |>
  group_by(location, ecoregion, year, species_code) |>
  summarise(individual_order = max(individual_order), .groups = "drop") |>
  mutate(year = round(year, 0)) |>
  group_by(ecoregion, year) |>
  summarise(sum_year = sum(individual_order), 
            sample_size = n(), 
            .groups = "drop") |>
  mutate(normalized_count = sum_year / sample_size)

# Run separate models for each ecoregion
lm_results <- count_annual_mdm %>%
  group_split(ecoregion) %>%
  map_df(~ {
    model <- lm(normalized_count ~ year, data = .x)
    tibble(
      ecoregion = unique(.x$ecoregion),
      slope = coef(model)[2],
      p_value = summary(model)$coefficients[2, 4],
      r_squared = summary(model)$r.squared
    )
  })

# Merge results back
count_annual_mdm <- count_annual_mdm %>%
  left_join(lm_results, by = "ecoregion")

# Plot
ggplot(count_annual_mdm, aes(x = year, y = normalized_count, colour = ecoregion)) +
  geom_smooth(method = "lm") +
  geom_point(size = 2) +
  scale_colour_manual(values = c("Alpine" = "#71706D", "Montane" = "#001F42")) +
  labs(x = "Year", y = "Normalized Count of Medium-Distance Migrants", colour = "Ecoregion") +
  scale_x_continuous(breaks = unique(count_annual_mdm$year)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  geom_text(data = lm_results, 
            aes(x = 2008, 
                y = ifelse(ecoregion == "Alpine", 1.7, 1.55), 
                label = paste0("Ecoregion: ", ecoregion, 
                               "\nSlope: ", round(slope, 2), 
                               "\nP-value: ", round(p_value, 4))),
            size = 3, hjust = 0, vjust = 1, show.legend = FALSE)


```

The mean time to first detection remained stable across years and methods used, with no significant effect of year detected in the mixed-effects model comparison (( p = 0.12 )). Predicted mean detection times varied slightly among data types, with legacy data exhibiting the shortest detection time (( 1.51 \times 10\^2 ) seconds), followed by `single_visit_0_max` (( 1.57 \times 10\^2 ) seconds), and `single_visit_3_max` (( 1.79 \times 10\^2 ) seconds). These differences are visualized in Figure @fig-mean-time-ttfd, where detection times increase with the use of single-visit methods.

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Mean predicted time of first detection across years using different processing methods
#| label: fig-mean-time-ttfd
#| cap-location: bottom
#| code-fold: true

mean_ttfd <- janp_main |>
  filter(data_type %in% c("legacy","single_visit_3_max","single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  group_by(year, location, data_type, species_code) |>
  summarise(mean_detection = mean(detection_time, na.rm = TRUE)) |>
  ungroup() |>
  mutate(mean_detection_log = log(mean_ttfd$mean_detection + 1))

mean_ttfd_model_mixed <- lmer(mean_detection ~ year + data_type + (1 | species_code) + (1 | location), data = mean_ttfd)
reduced_model_log <- lmer(mean_detection_log ~ data_type + (1 | species_code) + (1 | location), data = mean_ttfd)
model_ttfd_anova <- anova(mean_ttfd_model_mixed, reduced_model)
p_ttfd <- model_ttfd_anova$`Pr(>Chisq)`[2]

 prediction_data <- data.frame(
  data_type = c("legacy", "single_visit_0_max", "single_visit_3_max")
)

# Calculate predicted mean_detection values
prediction_data <- prediction_data %>%
  mutate(predicted_mean_detection = exp(fixed_effects[1] + 
                                          case_when(
                                            data_type == "legacy" ~ 0,
                                            data_type == "single_visit_0_max" ~ fixed_effects["data_typesingle_visit_0_max"],
                                            data_type == "single_visit_3_max" ~ fixed_effects["data_typesingle_visit_3_max"]
                                          )))

# Plot the predicted values
ggplot(prediction_data, aes(x = data_type, y = predicted_mean_detection, fill = data_type)) +
  geom_bar(stat = "identity", color = "black") +
  theme_bw() +
  xlab("Data Type") +
  ylab("Predicted Mean Detection Time") +
  scale_fill_viridis_d(option = "cividis") +
  ggtitle("Predicted Mean Detection Time by Data Type")

```

We then examined the abundance trend of these twenty species using the maximum count of individuals heard at each survey using the Mann-Kendall test and Sen's slope to examine the significance and magnitude of the trend of the abundance of each species over the study period. The results are summarized in @tbl-mk-sens.

```{r}
#| eval: false
#| include: false

tot_a_filtered <- janp_main |>
  filter(data_type %in% c("legacy","single_visit_3_max","single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F) |>
  mutate(ecoregion = case_when(
    ecoregion %in% c("Alpine") ~ "Alpine",
    ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane"
  )) |>
  group_by(location, ecoregion, year, recording_date_time, species_code) |>
  mutate(individual_order = ifelse(is.na(individual_order), 0, individual_order),
         individual_order = ifelse(is.infinite(individual_order), 0, individual_order),  
         abundance = max(individual_order, na.rm = TRUE)) |>
  ungroup() |>
  filter(is.finite(abundance)) |>
  inner_join(guilds |> dplyr::select(species_code, trait, dietary_guild, habitat_guild, migratory_guild), by = "species_code")

results_mmkh <- tot_a_filtered %>%
  filter(species_code %in% mdm) %>%
  group_by(species_code) %>%
  summarise(
    trend_vi = list(mmkh(abundance, ci = 0.95)),
    .groups = "drop"
  ) %>%
  mutate(
    vi_p_trend = map_dbl(trend_vi, ~ if ("new P-value" %in% names(.x)) {
      .x["new P-value"]
    } else {
      NA_real_
    }),
    vi_z = map_dbl(trend_vi, ~ if ("Corrected Zc" %in% names(.x)) {
      .x["Corrected Zc"]
    } else {
      NA_real_
    }),
    vi_sens = map_dbl(trend_vi, ~ if ("Sen's slope" %in% names(.x)) {
      .x["Sen's slope"]
    } else {
      NA_real_
    })
  ) %>%
  dplyr::select(species_code, vi_p_trend, vi_z, vi_sens)

results_with_plots <- results_mmkh %>%
  mutate(
    trend_plot = map(species_code, ~ {
      species_data <- tot_a_filtered %>% filter(species_code == .x)
      ggplot(species_data, aes(x = year, y = abundance)) +
        geom_point() +
        geom_smooth(method = "lm", se = FALSE) +
        labs(title = paste("Trend for", .x), x = "Year", y = "Abundance") +
        theme_minimal()
    })
  )
```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: markup
#| label: tbl-mk-sens
#| collapse: true
#| code-fold: true
#| tbl-cap: Mann-Kendall and Sen's slope species abundance trends

datatable(
  results_mmkh |>
  mutate(across(where(is.numeric), round, 2)),
  caption = "Trend Models Summary"
)
```

We analyzed species abundance trends over time using the Mann-Kendall trend test with a 95% confidence interval. Statistically significant p-values (p \< 0.05) were found for several species, including AMRO (0.0285), BRSP (0.0246), FOSP (0.0409), GCKI (0.0498), GCSP (0.0504), WAVI (0.00629), RCKI (0.0246), and YRWA (0.0252), indicating significant trends in abundance. The Z-scores, which reflect trend strength, varied across species, with WAVI showing the highest Z-score (2.73), indicating a particularly strong trend. Other species like AMPI (1.81), AMRO (2.19), and BRSP (2.25) showed moderate trends, while species like HETH (1.51), RBNU (1.41), and WCSP (1.40) had weaker trends. Despite significant trends, the Sen's slope (vi_sens) was consistently zero for all species, indicating that there was no measurable directional change in abundance over the study period. We then proceeding with conduct a model selection workflow to examine best-fit linear models of various distributions (see @tbl-linear-models) on both single species and guild models. For the single species models we used the mean count of individuals.

```{r}
#| warning: false
#| echo: true
#| eval: false
#| message: false
#| include: true
#| results: hide
#| code-fold: true

models <- list(
  mP0 = function(data) glm(abundance ~ 1, data = data, family = poisson),
  mP1 = function(data) glm(abundance ~ year, data = data, family = poisson),
  mP2 = function(data) glm(abundance ~ year + data_type, data = data, family = poisson),
  mP3 = function(data) gam(abundance ~ s(year), data = data, family = poisson),
  mP4 = function(data) gam(abundance ~ s(year) + data_type, data = data, family = poisson),
  mP5 = function(data) glm.nb(abundance ~ year, data = data),
  mP6 = function(data) glm.nb(abundance ~ year + data_type, data = data),
  mP7 = function(data) zeroinfl(abundance ~ year | 1, data = data, dist = "poisson"),
  mP8 = function(data) zeroinfl(abundance ~ year | 1 + data_type, data = data, dist = "poisson"),
  mP9 = function(data) zeroinfl(abundance ~ year | 1, data = data, dist = "negbin"),
  mP10 = function(data) zeroinfl(abundance ~ year | 1 + data_type, data = data, dist = "negbin"),
  mP11 = function(data) glmmTMB(abundance ~ year + (1 | location), ziformula = ~1, family = poisson(), data = data),
  mP12 = function(data) glmmTMB(abundance ~ year + (1 | location) + data_type, ziformula = ~1, family = poisson(), data = data),
  mP13 = function(data) glmer(abundance ~ year + (1 | location), data = data, family = "poisson"),
  mP14 = function(data) glmer(abundance ~ year + data_type + (1 | location), data = data, family = "poisson")
)

best_models_with_plot <- function(species_code) {
  species_data <- tot_a_filtered |>
    group_by(location, year, recording_date_time) |>
    mutate(abundance = ifelse(species_code == !!species_code, abundance, 0)) |>
    ungroup() |>
    filter(species_code == !!species_code)
  
  fitted_models <- map(models, possibly( ~ {
    model <- .x(species_data)
    if (!is.null(model)) {
      cat("Fitting model:", deparse(substitute(.x)), "\n")
      print(summary(model))
    } else {
      cat("Fitting model failed:", deparse(substitute(.x)), "\n")
    }
    model
  }, NULL))
  
  aic_values <- map_dfr(names(fitted_models),
                        ~ tibble(
                          model = .x,
                          AIC = if (!is.null(fitted_models[[.x]]))
                            AIC(fitted_models[[.x]])
                          else
                            Inf
                        ))
  
  best_model_name <- aic_values |>
    filter(AIC == min(AIC, na.rm = TRUE)) |>
    pull(model)
  
  if (!is.null(fitted_models[[best_model_name]])) {
    best_model <- fitted_models[[best_model_name]]
    
    predicted_values <- predict(best_model, newdata = species_data, type = "response")
    
    species_data$predicted_abundance <- ifelse(
      length(predicted_values) == nrow(species_data),
      predicted_values,
      rep(NA, nrow(species_data))
    )
    
    trend_result <- if (length(unique(species_data$abundance)) > 1) {
      tryCatch({
        mk <- mmkh(species_data$abundance, ci = 0.95)
        list(
          p_trend = if ("newPvalue" %in% rownames(as.data.frame(mk))) {
            as.data.frame(mk)["newPvalue", "mmkh.mean", drop = TRUE]
          } else {
            NA_real_
          },
          z = if ("CorrectedZc" %in% rownames(as.data.frame(mk))) {
            as.data.frame(mk)["CorrectedZc", "mmkh.mean", drop = TRUE]
          } else {
            NA_real_
          },
          sens = if ("Sensslope" %in% rownames(as.data.frame(mk))) {
            as.data.frame(mk)["Sensslope", "mmkh.mean", drop = TRUE]
          } else {
            NA_real_
          }
        )
      }, error = function(e)
        list(
          p_trend = NA,
          z = NA,
          sens = NA
        ))
    } else {
      list(p_trend = NA,
           z = NA,
           sens = NA)
    }
    
    p <- ggplot(species_data, aes(x = year)) +
      geom_point(aes(y = abundance),
                 color = "black",
                 alpha = 0.5) +
      geom_line(aes(y = predicted_abundance),
                color = "blue",
                size = 1) +
      labs(
        title = paste(species_code, "Best Fit Model:", best_model_name),
        x = "Year",
        y = "Abundance"
      ) +
      theme_minimal() +
      theme(legend.position = "none")
    
    # Return the result as a tibble along with the ggplot and trend analysis
    tibble(
      species_code = species_code,
      name = best_model_name,
      AIC = aic_values |> filter(model == best_model_name) |> pull(AIC),
      summary = list(summary(best_model)),
      plot = list(p),
      vi_p_trend = trend_result$p_trend,
      vi_z = trend_result$z,
      vi_sens = trend_result$sens
    )
  } else {
    tibble(
      species_code = species_code,
      name = NA,
      AIC = Inf,
      summary = "No valid model",
      plot = NA,
      vi_p_trend = NA_real_,
      vi_z = NA_real_,
      vi_sens = NA_real_
    )
  }
}

# Create a trend_models tibble with the ggplots for each species
trend_models <- tibble(species_code = mdm) %>%
  mutate(best_model = map(species_code, best_models_with_plot)) %>%
  unnest(best_model, names_sep = "_")

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: markup
#| label: tbl-linear-models
#| collapse: true
#| code-fold: true
#| tbl-cap: Best-fit linear models, Mann-Kendall and Sen's slope for trend of twenty species in Jasper National Park

datatable(
  trend_models |> 
    arrange(species_code) |> 
    dplyr::select(-c(best_model_species_code, best_model_summary, best_model_plot)) |>
  mutate(across(where(is.numeric), round, 2)),
  caption = "Trend Models Summary"
)
```

```{r}
#| warning: false
#| echo: false
#| eval: false
#| message: false
#| include: true
#| results: hide
#| code-fold: true

tot_a_filtered_trait <- tot_a_filtered |>
  mutate(ecoregion = case_when(
    ecoregion %in% c("Alpine") ~ "Alpine",
    ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane"
  )) |>
  group_by(location, year, ecoregion, recording_date_time, trait) |>
  summarise(sum = sum(abundance)) |>
  ungroup()

tot_a_filtered_nesting <- tot_a_filtered |>
  mutate(ecoregion = case_when(
    ecoregion %in% c("Alpine") ~ "Alpine",
    ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane"
  )) |>
  group_by(location, year, ecoregion, recording_date_time, habitat_guild) |>
  summarise(sum = sum(abundance)) |>
  ungroup()

tot_a_filtered_migratory <- tot_a_filtered |>
  mutate(ecoregion = case_when(
    ecoregion %in% c("Alpine") ~ "Alpine",
    ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane"
  )) |>
  group_by(location, year, ecoregion, recording_date_time, migratory_guild) |>
  summarise(sum = sum(abundance)) |>
  ungroup()

tot_a_filtered_dietary <- tot_a_filtered |>
  mutate(ecoregion = case_when(
    ecoregion %in% c("Alpine") ~ "Alpine",
    ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane"
  )) |>
  group_by(location, year, ecoregion, recording_date_time, dietary_guild) |>
  summarise(sum = sum(abundance)) |>
  ungroup()

best_models_with_plot_guild <- function(guild_data, guild_col) {
  
  guild_results <- unique(guild_data[[guild_col]]) %>%
    map(function(guild) {
      filtered_data <- guild_data %>%
        filter(.data[[guild_col]] == guild) %>%
        mutate(abundance = sum) # Use the summed abundance
      
      # Fit models to the filtered guild data
      fitted_models <- map(models, possibly(~ {
        model <- .x(filtered_data)
        if (!is.null(model)) {
          cat("Fitting model for guild:", guild, "\n")
          print(summary(model))
        }
        model
      }, NULL))
      
      # Extract AIC values
      aic_values <- map_dfr(
        names(fitted_models),
        ~ tibble(model = .x, AIC = if (!is.null(fitted_models[[.x]])) AIC(fitted_models[[.x]]) else Inf)
      )
      
      # Select the best model
      best_model_name <- aic_values %>%
        filter(AIC == min(AIC, na.rm = TRUE)) %>%
        pull(model)
      
      if (!is.null(fitted_models[[best_model_name]])) {
        best_model <- fitted_models[[best_model_name]]
        predicted_values <- predict(best_model, newdata = filtered_data, type = "response")
        
        filtered_data$predicted_abundance <- ifelse(length(predicted_values) == nrow(filtered_data),
                                                    predicted_values,
                                                    rep(NA, nrow(filtered_data)))
        
        # Perform Mann-Kendall Test and Sen's Slope
        trend_result <- if (length(unique(filtered_data$abundance)) > 1) {
          tryCatch({
            mk <- mmkh(filtered_data$abundance, ci = 0.95)
            list(
              p_trend = if ("newPvalue" %in% rownames(as.data.frame(mk))) {
                as.data.frame(mk)["newPvalue", "mmkh.mean", drop = TRUE]
              } else {
                NA_real_
              },
              z = if ("CorrectedZc" %in% rownames(as.data.frame(mk))) {
                as.data.frame(mk)["CorrectedZc", "mmkh.mean", drop = TRUE]
              } else {
                NA_real_
              },
              sens = if ("Sensslope" %in% rownames(as.data.frame(mk))) {
                as.data.frame(mk)["Sensslope", "mmkh.mean", drop = TRUE]
              } else {
                NA_real_
              }
            )
          }, error = function(e)
            list(
              p_trend = NA,
              z = NA,
              sens = NA
            ))
        } else {
          list(p_trend = NA, z = NA, sens = NA)
        }
        
        # Create a plot for the guild
        p <- ggplot(filtered_data, aes(x = year)) +
          geom_point(aes(y = abundance), color = "black", alpha = 0.5) +
          geom_line(aes(y = predicted_abundance), color = "blue", size = 1) +
          labs(title = paste("Guild:", guild, "| Best Fit Model:", best_model_name),
               x = "Year", y = "Abundance") +
          theme_minimal()
        
        return(tibble(
          guild = guild,
          model_name = best_model_name,
          AIC = aic_values %>% filter(model == best_model_name) %>% pull(AIC),
          summary = list(summary(best_model)),  # Always a list
          p_trend = trend_result$p_trend,
          z = trend_result$z,
          sens = trend_result$sens,
          plot = list(p)  # Always a list
        ))
      } else {
        return(tibble(
          guild = guild,
          model_name = NA,
          AIC = Inf,
          summary = list(NULL),  # Ensure it's a list for consistency
          p_trend = NA,
          z = NA,
          sens = NA,
          plot = list(NULL)  # Ensure it's a list for consistency
        ))
      }
    })
  
  bind_rows(guild_results)
}

# Run for guilds
trend_models_trait <- best_models_with_plot_guild(tot_a_filtered_trait |> filter(!is.na(trait)), "trait")
trend_models_habitat <- best_models_with_plot_guild(tot_a_filtered_nesting, "habitat_guild")
trend_models_migratory <- best_models_with_plot_guild(tot_a_filtered_migratory, "migratory_guild")
trend_models_dietary <- best_models_with_plot_guild(tot_a_filtered_dietary, "dietary_guild")


```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: markup
#| label: tbl-linear-models-guilds
#| collapse: true
#| code-fold: true
#| tbl-cap: Best-fit linear models, Mann-Kendall and Sen's slope for guilds of twenty species in Jasper National Park
 
datatable(
  bind_rows(trend_models_trait, trend_models_habitat, trend_models_dietary) |> 
    dplyr::select(guild, model_name, AIC, p_trend, z, sens) |>
    dplyr::mutate(across(where(is.numeric), round, 2)),
  caption = "Guild Trend Models Summary"
)

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Trend of guilds for twenty bird species in Jasper 
#| label: fig-annual-trend-guild-nesting
#| cap-location: bottom
#| code-fold: true

# Plot
ggplot(tot_a_filtered_nesting, aes(x = year, y = sum, colour = ecoregion)) +
  geom_smooth(method = "lm") +
  geom_point(size = 2) +
  scale_colour_manual(values = c("Alpine" = "#71706D", "Montane" = "#001F42")) +
  labs(x = "Year", y = "Abundance", colour = "Ecoregion") +
  scale_x_continuous(breaks = unique(count_annual_mdm$year)) +
  theme_bw() +
  facet_wrap(~ecoregion) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Trend of guilds for twenty bird species in Jasper 
#| label: fig-annual-trend-guild-dietary
#| cap-location: bottom
#| code-fold: true

# Plot
ggplot(tot_a_filtered_dietary, aes(x = year, y = sum, colour = ecoregion)) +
  geom_smooth(method = "lm") +
  geom_point(size = 2) +
  scale_colour_manual(values = c("Alpine" = "#71706D", "Montane" = "#001F42")) +
  labs(x = "Year", y = "Abundance", colour = "Ecoregion") +
  theme_bw() +
  facet_wrap(~ecoregion) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

### Transect-level analysis

Stay tuned for more results.

# Discussion

Stay tuned for the discussion!
