---
title: "Report on the use of passive acoustic monitoring for analysis of bird trends in Jasper National Park"
format:
  html:
    grid:
      margin-width: 300px
  pdf:
    toc: true
    toc-depth: 3
    number-sections: true
    colorlinks: true
    geometry:
      - margin=1in
    papersize: letter
navbar: right
theme: cosmo
lightbox: true
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: 
  - name: "Alex MacPhail"
    affiliation: "Biodiversity Pathways Ltd."
  - name: "Brenda Shepherd"
    affiliation: "Jasper National Park, Parks Canada"
  - name: "Nina Veselka"
    affiliation: "Jasper National Park, Parks Canada"
editor: visual
bibliography: references.bib
nocite: '@*'
toc: true
toc-depth: 3
toc-expand: true
prefer-html: true
toc-location: left
styles: styles.css
github: https://github.com/biodiversitypathways/janp
---

![](assets/janp.png){style="float:left`;" fig-alt="Photo of Jasper" fig-align="center"}

```{r}
#| label: Load packages and authenticate to WildTrax
#| include: false
#| echo: false
#| eval: true
#| warning: false
#| message: false

library(tidyverse)
library(leaflet)
library(wildrtrax)
library(sf)
library(ggridges)
library(scales)
library(kableExtra)
library(ggrepel)
library(DT)
library(lubridate)
library(vegan)
library(lme4)
library(modifiedmk)
library(FD)
library(detect)
library(segmented)
library(fs)
library(tinytex)
library(spdep)

wt_auth()

load('janp.RData')
#save.image('janp.RData')
```

```{r}
#| label: Download data from WildTrax
#| warning: false
#| message: false
#| echo: false
#| eval: false
#| include: true

janp_aru_projects <- wt_get_projects(sensor = 'ARU') |>
  filter(grepl('Jasper National Park', project)) |>
  dplyr::select(project_id) |>
  pull()

# All projects associated with a single-visit ARU deployment with no abundance cap
janp_0max <- wt_get_projects(sensor = 'ARU') |>
  filter(grepl('Jasper NP - EI', project)) |>
  filter(!grepl('2021|2022',project)) |>
  dplyr::select(project_id) |>
  pull()

# All projects associated with a single-visit ARU deployment with an abundance cap of 3
janp_3max <- wt_get_projects(sensor = 'ARU') |>
  filter(grepl('Jasper NP - EI', project)) |>
  filter(grepl('2021|2022',project)) |>
  dplyr::select(project_id) |>
  pull()

janp_project_lists <- list(
  #multi_day = janp_aru_projects,
  single_visit_0_max = janp_0max,
  single_visit_3_max = janp_3max
)

janp_aru <- imap_dfr(
  janp_project_lists,
  ~ map_dfr(
      .x, 
      ~ wt_download_report(
          project_id = .x,
          sensor_id = "ARU",
          reports = "main"
        )
    ) |> mutate(data_type = .y, .after = organization) 
)

rel_wea <- imap_dfr(
  janp_project_lists,
  ~ map_dfr(
      .x, 
      ~ wt_download_report(
          project_id = .x,
          sensor_id = "ARU",
          reports = "recording",
          max_seconds = 600
        )
    ) |> mutate(data_type = .y, .after = organization) 
)

# Bind legacy data with acoustic data
janp_main <- bind_rows(old_s_max, janp_aru) |>
  group_by(location) |>
  fill(ecoregion, .direction = "down") |>
  ungroup() |>
  mutate(location = case_when(grepl("^VALLEY-",location) ~ gsub("VALLEY-","VALLEY5-",location), TRUE ~ location),
         ecoregion = case_when(grepl("COTTONWOOD|MUSHROOM|VALLEY5",location) & is.na(ecoregion) ~ "Montane", TRUE ~ ecoregion),
         year = year(recording_date_time)) # Get year in as a variable

```

::: {.callout-note collapse="true" style="background-color: #f4f4f4; padding: 20px;"}
This report is dynamically generated, meaning its results may evolve with the addition of new data or further analyses. For the most recent updates, refer to the publication date and feel free to reach out to the authors.
:::

# Abstract

Since 2007, Jasper National Park has conducted passive acoustic monitoring as part of its ecological integrity monitoring program. The 18 years of data were analyzed to identify trends and extract insights that inform ongoing monitoring and strengthen future species monitoring practices. The analysis assessed whether species and guild abundances shifted by ±2.5% in the alpine and montane ecoregions. Data were managed and processed in WildTrax, combining and harmonizing legacy datasets from multiple methodologies. Sampling locations were tested for independence, and trend analyses quantified changes in species counts over time across guilds and ecoregions.

# Land Acknowledgement

We respectfully acknowledge that Jasper National Park is located in Treaty 6 and 8 as well as the traditional lands of the Anishinabe, Aseniwuche Winewak, Dene-zaa, Nêhiyawak, Secwépemc, Stoney Nakoda, Mountain Métis and Métis. We acknowledge the past, present, and future generations of these nations who continue to steward the land.

# Introduction

Human activities have been identified as key pressures and contributors to the global decline in forest wildlife (@allan2017recent). The repercussions of habitat fragmentation (@fahrig2003effects) and loss (@hanski2011habitat), climate change (@mantyka2012interactions, @sattar2021review, @abrahms2023climate), and increased access to sensitive areas exert direct and indirect pressures on forest biodiversity, particularly in protected areas in Canada (@lemieux2011state). In Alberta’s Rocky Mountain Natural Region, these pressures are compounded by increasing wildfire activity, which has significantly impacted montane bird monitoring. Studies have shown large declines in bird abundance in the last several decades across large regions of North America (@rosenberg2019decline), suggesting the need for parkwide monitoring of bird abundance.

In 2007, Jasper National Park initiated a program incorporating passive acoustic monitoring of the park’s vocalizing wildlife. Autonomous Recording Units (ARUs) are compact environmental sensors that are designed to passively record the environment (@aru-overview), capturing vocalizing species like birds and amphibians—a method growing in use across the globe (@lots-of-pam). This technology enables biologists to conduct prolonged surveys with minimal human interference, while creating a permanent, archiveable recording of the soundscape. Given the rapidity and ease of accumulating data from these units, maintaining a high standard of data integrity is paramount to ensure future data interoperability and sharing. The data collected by these units contribute valuable information to ecological integrity metrics such as species richness, diversity, occupancy, abundance trends of species and human activities in National Parks over time. 

This project analyzes Jasper’s passive acoustic monitoring data from 2007 to 2025, to assess trends while accounting for the clustering of survey points within transects and determining time-to-first-detection usability in analysis. We selected species abundance as our primary monitoring measure following recommendations in [Fletcher et al. (2025)]{.mark}. Measures that reflect abundance, reproductive performance, survival, dispersal, habitat quality, and role in ecosystem functioning provide richer insights for the achievement of conservation goals than species richness or species incidence. For example, incidence alone does not mean that a species’ presence is meaningful from a conservation perspective because a single observation is treated the same as an abundant species. As changes in abundance are more closely linked to extinction risk than species incidence, abundance-based metrics have been promoted to better assess goals in biodiversity conservation. Abundance can fluctuate more than occurrence and may therefore better track key changes in the environment, although care should be taken to not overinterpret “noisy” abundance variation. Information on abundance is essential for diagnosing decline and recovery of species and may better capture the resilience of biodiversity to ongoing environmental threats

Jasper National Park reports on the condition of three park ecosystems in its State of the Park Report: freshwater, alpine and forest (montane). Since birds are indicators in both the forest and alpine ecosystems, separate analyses were conducted for the montane ecoregion (grouping of the upper subalpine, lower subalpine, and true montane ecoregions) and alpine ecoregion. To enhance accessibility and reproducibility, the findings were presented in this online report with fully documented code, allowing future updates as data collection methods become standardized. Additionally, recommendations were developed to refine data transcription priorities, improve annual reporting methods, and evaluate species guild classifications for long-term monitoring. 

This project aims to analyze Jasper’s passive acoustic monitoring data from 2007 to 2025, assessing trends in species and guild abundance while accounting for the clustering of survey points within transects. Separate analyses will be conducted for montane and sub-alpine and alpine ecoregions to align with Ecological Integrity reporting requirements, determining time-to-first-detection usability in analysis. To enhance accessibility and reproducibility, the findings will be presented in this online report with fully documented code, allowing future updates as data collection methods become standardized. Additionally, recommendations will be developed to refine data transcription priorities, improve annual reporting methods, and evaluate species guild classifications for long-term monitoring. The objectives of this report are to:

- Describe the data management and processing procedures for acoustic data collected from 2007 to 2025.
- Compare how different data processing methods influence the count of species and individuals detected on recordings.
- Report on trends in bird abundance by species and by guild in the montane (forest indicator) and alpine (alpine indicator) ecoregions, incorporating time-to-first-detection analysis
  - Summarize results by ecoregion as the percentage of species and guilds declining by ≥2.5% in both forest and alpine regions. Explore methods (e.g., inclusion of covariates and summarizing by guild) to interpret these changes, understanding how birds may be responding to stressors in the park or across their ranges and how changing populations may affect ecosystems.
- Estimate species richness trends to determine if they provides insight about bird community conditions.
- Provide recommendations for: 
  - Prioritizing previous years’ data for re-transcription to 1SPT; 
  - Optimizing annual reporting methods (e.g., baseline comparisons vs. 10-year trends); and 
  - Refining methods for evaluating species trends against thresholds and reviewing guilds and traits used in assessments
- Facilitate data publication to the public, resource managers, academic institutions, and any other relevant agencies

# Methods

## Bird surveys

Monitoring for forest and alpine birds in Jasper National Park has been conducted annually since 2007 across a core set of 129 sites, and 20 sites that were added in 2025. To ensure long-term feasibility, sites were clustered along transects, and transects were randomly selected from hiking trails that were at least 500 m away from roads and were at least five kilometers apart. To sample the diversity of birds in the park, transects were stratified by ecological region (@fig-aru-monitoring-locations).

Songbird data were collected using autonomous recording units (ARUs) deployed by field staff to capture one 10-minute recording per point count annually. Surveys were scheduled consistently each breeding season in June and early July, starting 30 minutes before sunrise. Technicians walked transects containing nine or ten points, each spaced at least 300 m apart to prevent duplicate detections and ensure independence of locations. At each documented location, the ARU was set up, and technicians moved 10–20 m away to minimize disturbance, allowing at least 11 minutes of recording to capture voice notes and the standardized 10-minute survey period. Four covariates thought to influence detection or abundance were recorded: start time, wind speed (km/h), cloud cover (clear, broken, scattered, overcast), temperature (&deg;C) and recording equipment. Recording equipment varied throughout the course of the study; during the 2021 and 2022 field seasons, paired recordings were collected concurrently at each site using both Wildlife Acoustics SM4 autonomous recording units and the original recording devices (RiverForks CZM or Zoom H2N Pro, depending on site-specific deployment). This dual-recording approach was implemented to support calibration and continuity across equipment types. However, to maintain consistency in data processing, only recordings from the original devices were transcribed and included in the final analyses for those years. Beginning in 2023, recordings were collected exclusively using SM4 units.

::: {.callout-note collapse="true" style="background-color: #f4f4f4; padding: 20px;"}
The 2012 field season was reduced significantly and was not included in some of the subsequent analyses. Refer to @tbl-loc-summary for more information.
:::

```{r}
#| echo: false
#| eval: false
#| warning: false
#| message: false
#| include: true

janp_shp <- read_sf("assets/National_Parks_and_National_Park_Reserves_of_Canada_Legislative_Boundaries.shp") |>
  filter(grepl("JASPER",adminAreaN))

janp_fire <- read_sf("./assets/JNP_FirePerimeters_selection.shp") |>
  st_transform(st_crs(janp_shp))

abfire <- read_sf("/users/alexandremacphail/downloads/abfire/WildfirePerimeters1931to2024.shp") |>
  st_transform(st_crs(janp_shp)) |>
  st_make_valid()
abfire <- abfire[!st_is_empty(abfire), ]

janp_utm <- janp_shp |> st_transform(26911)

abfire_utm <- abfire |>
  st_transform(26911)

abfire_utm <- abfire_utm |>
  st_make_valid() |>
  st_collection_extract("POLYGON")

idx <- lengths(st_intersects(abfire_utm, janp_utm)) > 0
fires_in_janp <- abfire_utm[idx, ] 
fires_in_janp <- fires_in_janp |> filter(!grepl('Chetamon',ALIAS)) |>
  filter(!YEAR == 2024)
fires_in_janp <- fires_in_janp |> st_transform(4326)

lc_150m <- read_csv("Habitat/LandCoverClass_Buffer150Raw.csv") |>
  pivot_longer(
    cols = matches("^LANDCOVER_(CODE|PCT)_"),
    names_to = c(".value", "rank"),
    names_pattern = "LANDCOVER_(CODE|PCT)_(\\d+)"
  ) |>
  rename(
    landcover = CODE,
    pct = PCT
  ) |>
  filter(!is.na(landcover), pct > 0) |>
  mutate(area_m2 = Shape_Area * (pct / 100)) |>
  group_by(Point_ID, landcover, VEGETATION_DENSITY, REFERENCE_YEAR) |>
  summarise(
    total_area_m2 = sum(area_m2, na.rm = TRUE),
    .groups = "drop"
  ) |>
  mutate(prop_cover = total_area_m2 / (pi * 150^2))

canopy_150m <- read_csv("Habitat/DomCanopy_Buffer150Raw.csv") |>
  group_by(Point_ID) |>
  mutate(buffer_area = sum(Shape_Area, na.rm = TRUE)) |>
  ungroup() |>
  group_by(Point_ID, DOM_LAYER_SPECIES_CODE) |>
  summarise(
    canopy_cover = sum(Shape_Area, na.rm = TRUE) / first(buffer_area),
    avg_height = mean(DOM_LAYER_HEIGHT, na.rm = TRUE),
    .groups = "drop"
  ) |>
  rename(canopy_species = DOM_LAYER_SPECIES_CODE) |>
  mutate(
    canopy_species = if_else(is.na(canopy_species), "NC", canopy_species),
    avg_height     = if_else(is.na(avg_height) | is.nan(avg_height), 0, avg_height)
  )

understory_150m <- read_csv("Habitat/Understory_Buffer150Raw.csv") |>
  mutate(across(where(is.numeric), ~ na_if(.x, -99999))) |>
  drop_na() |>
  group_by(Point_ID) |>
  summarise(mean_shrub_height = mean(SHRUB_HEIGHT, na.rm = T),
            mean_crown_closure = mean(SHRUB_CROWN_CLOSURE, na.rm = T))

```

```{r}
#| echo: false
#| eval: false
#| warning: false
#| message: false
#| include: true

janp_locs <- janp_main |>
  filter(year > 2022) |>
  dplyr::select(location, latitude, longitude, year, ecoregion) |>
  drop_na(latitude) |>
  distinct() |>
  sf::st_as_sf(coords = c("longitude", "latitude"), crs = 4326)

# Combine
janp_locs_map <- janp_locs |> 
  dplyr::select(location, year, ecoregion, geometry) |>
  mutate(ecoregion = case_when(
    grepl("^JANP", location) ~ "Other ARU Monitoring", 
    TRUE ~ ecoregion
  )) |>
  filter(!grepl('MPB',location))

fire_intersect <- st_intersects(janp_locs_map, janp_fire)

ysf <- janp_locs_map %>%
  mutate(
    FIRE_YEAR = sapply(fire_intersect, function(x) if(length(x)) janp_fire$FIRE_YEAR[x] else NA),
    Fire_Name = sapply(fire_intersect, function(x) if(length(x)) janp_fire$Fire_Name[x] else NA)
  ) |>
  filter(!is.na(FIRE_YEAR)) |>
  st_drop_geometry() |>
  mutate_at(vars(year, FIRE_YEAR), as.numeric) |>
  rowwise() |>
  mutate(yrs_since_fire = case_when(FIRE_YEAR > year ~ NA_real_,
                                    FIRE_YEAR == year ~ 0,
                                    FIRE_YEAR < year ~ year - FIRE_YEAR,
                                    TRUE ~ NA_real_))

# Generate summary table
janp_locs_table <- janp_main |>
  dplyr::select(location, year, ecoregion) |>
  distinct() |> 
  mutate(fill = 1) |>
  arrange(year) |>
  pivot_wider(names_from = year, values_from = fill, values_fill = 0) |>
  arrange(location)

```

```{r}
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| include: true
#| fig-align: center
#| fig-cap: Locations from Jasper National Park ARU EI Monitoring Program.
#| label: fig-aru-monitoring-locations

# Map visualization
pal <- colorFactor(
  palette = "Set3", 
  domain = janp_locs_map$ecoregion
)

fire_color <- "#C71585"  # You can adjust to a medium pink if you like

leaflet() %>%
  addTiles() %>%
  addPolygons(
    data = janp_shp,
    color = "blue",
    weight = 1,
    fillOpacity = 0.2,
    popup = ~paste("Park:", adminAreaN)
  ) %>%
  addPolygons(
    data = fires_in_janp,
    fillColor = fire_color,
    color = fire_color,
    weight = 1,
    fillOpacity = 0.5,
    popup = ~paste("Fire:", ALIAS, "<br>Year:", YEAR),
    group = "Fires"   # group them for a single legend entry
  ) %>%
  addPolygons(
    data = janp_fire,
    fillColor = fire_color,
    color = fire_color,
    weight = 1,
    fillOpacity = 0.7,
    popup = ~paste("Fire: ", Fire_Name, "<br>Year:", FIRE_YEAR),
    group = "Fires"
  ) %>%
  addLegend(
    position = "bottomright",
    colors = fire_color,
    labels = "Fires",
    title = "Recent Fires",
    opacity = 1
  ) %>%
  addCircleMarkers(
    data = janp_locs_map,
    popup = ~paste("Location:", location, "<br>"),
    fillColor = ~pal(ecoregion),  
    fillOpacity = 1,
    color = "black", 
    radius = 6 
  ) %>%
  addLegend(
    "topright",
    pal = pal,
    values = janp_locs_map$ecoregion,
    title = "Ecoregion",
    opacity = 1
  ) %>%
  addMeasure(primaryLengthUnit = "meters", primaryAreaUnit = "sqmeters") %>%
  addMiniMap(position = "bottomleft")

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| label: tbl-loc-summary
#| collapse: true
#| code-fold: true
#| tbl-cap: Locations surveyed across years. Ones indicated a deployment in that year for that location.

datatable(janp_locs_table, 
          options = list(
            searching = TRUE,  
            paging = TRUE,    
            pageLength = 10   
          )) |>
  formatStyle(columns = colnames(janp_locs_table), 
              backgroundColor = styleEqual(c("NA"), "lightgray"))  
```

## Habitat and survey variables

We used the existing Vegetation Resource Inventory (VRI) derived from 2020 orthophoto imagery, before the 2022 Chetamon and 2024 Jasper Wildfire to describe habitat conditions. We extracted variables describing dominant land cover (including conifer, broadleaf, shrub, herbaceous, and exposed soil classes), forest structure (canopy height, age), and understory characteristics (shrub height, crown closure). To account for the severe habitat alteration caused by the 2024 Jasper Wildfire, we manually reclassified the land cover variable for all sites on the TEKARRA and VALLEY5 transects as "Burned" for the 2025 data. This classification replaced the pre-fire VRI categories (e.g., conifer, shrub) in the analysis.

## Weather variables

To examine the influence of weather on species richness and abundance, we fit a negative binomial generalized linear model (glm.nb()) with richness as the response and temperature, sky (clear, overcast, scattered), wind, Julian day, and hour as predictors. Model dispersion, calculated as the ratio of residual deviance to residual degrees of freedom, was 1.02, indicating minor overdispersion and suggesting an adequate fit. Julian day (β = –0.014, p < 0.001) and hour (β = –0.024, p = 0.002) were significantly negatively associated with richness, while temperature, wind, and sky type showed weak or non-significant effects. Although temperature and wind were not significant in this model, they were retained in subsequent analyses due to their known ecological influence on bat activity and detection probability. The model residual deviance was 1527.5 on 1494 degrees of freedom, with an AIC of 7684.5 and an estimated dispersion parameter (θ) of 40.77 (SE = 8.59). For abundance… 

```{r}

janp_richness <- janp_main %>%
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine", "Lower Subalpine", "Montane") ~ "Forested")) |>
  mutate(hour = hour(recording_date_time), julian = yday(recording_date_time)) |>
  group_by(location, ecoregion, recording_date_time, julian, hour) %>%
  summarise(
    richness = n_distinct(species_code),
    temperature = first(temperature),
    sky = first(sky),
    wind = first(wind),
    .groups = "drop"
  ) |>
  drop_na()

ggplot(janp_richness, aes(x = temperature, y = richness)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "glm", method.args = list(family = "poisson")) +
  facet_wrap(~ecoregion) +
  theme_bw()

ggplot(janp_richness, aes(x = sky, y = richness)) +
  geom_boxplot() +
  facet_wrap(~ecoregion) +
  theme_bw()

ggplot(janp_richness, aes(x = wind, y = richness)) +
  geom_point(alpha = 0.3) +
  facet_wrap(~ecoregion) +
  geom_smooth(method = "glm", method.args = list(family = "poisson")) +
  theme_bw()

rich_mod <- glm(
  richness ~ temperature + sky + wind + julian + hour,
  data = janp_richness,
  family = poisson()
)

rich_mod2 <- glm.nb(
  richness ~ temperature + sky + wind + julian + hour,
  data = janp_richness
)

deviance(rich_mod2) / df.residual(rich_mod2)

```


## Data management, processing and quality control

Recordings were clipped and organized to only include the 10-minute count. Before adopting WildTrax in 2021, processing analysts excluded the initial 20 seconds to 1.5 minutes of recordings to reduce human impact on detection probability, then logged the first detection time per species. Recordings are now uploaded as clean 10-minute files with the voice note and observer notes removed. In WildTrax, individuals were counted by users scanning both the spectrogram and listening to the audio output (@MacPhail2025_avian). Tags were then drawn to encompass the signal within the methods indicated in each project (see @tbl-transcriptions). Transcribers also had site photos available to optimize their species identification by having habitat context while processing.

To ensure comparability across the 18-year dataset, we harmonized the abundance metrics derived from the differing transcription protocols prior to analysis. For legacy data collected between 2012 and 2020 using the 3-minute interval method, we calculated abundance as the maximum count observed in any single time bin rather than summing across bins. This conservative approach prevents the double-counting of individuals that sing continuously throughout the recording. Conversely, for data processed or re-transcribed using the modern 1SPT protocol (time of first detection of each unique individual of each species; 2007–2011 and 2021–2025), abundance was defined as the total count of unique individuals detected over the full 10-minute duration. Specifically, in WildTrax maximum count of individuals was used (i.e. AMRO1, AMRO2, AMRO3 max of 3 represents 3 individuals total).

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| label: tbl-transcriptions
#| collapse: true
#| code-fold: true
#| tbl-cap: Transcription methods by year (2007–2025). Historical data (2007–2020) are undergoing re-transcription to align with the standardized protocol used from 2021 onwards.

transcription_table <- tibble(
  Years = c("2007-2020", "2021-2022", "2023-2025", "2007-2011"),
  `Transcription Method` = c(
    "0-3.33, 3.33-6.66, 6.66-10 min",
    "1 SPT - Species per task or recording (Every new individual is tagged within the 10 minute recording).",
    "1 SPT - Species per task or recording (Every new individual is tagged within the 10 minute recording).",
    "1 SPT - Species per task or recording (Every new individual is tagged within the 10 minute recording). Re-transcription."
  ),
  `Bin Method` = c(
    "Abundance re-starts for each 3.33-minute bin",
    "Time of first detection over 10 minute period",
    "Time of first detection over 10 minute period",
    "Time of first detection over 10 minute period. Re-transcription."
  ),
  `Method Details` = c(
    "No cap on abundance; abundance re-starts for each bin, no total abundance for the 10-min recording",
    "Time of first detection over 10 minute period",
    "Time of first detection over 10 minute period",
    "Time of first detection over 10 minute period. Re-transcription."
  ),
  `Max # of Individuals` = c(
    "No cap",
    "Maximum of 3 individuals per 10-minute recording",
    "No cap",
    "No cap. Re-transcription."
  )
)

transcription_table

# Render the datatable
datatable(transcription_table, 
          options = list(
            searching = TRUE,  
            paging = TRUE,    
            pageLength = 10   
          )) |>
  formatStyle(columns = colnames(transcription_table), 
              backgroundColor = styleEqual(c("NA"), "lightgray"))  


```

![WildTrax Acoustic Processing Interface (Version 2)](assets/acousticprocessing.png){#fig-acousticprocessing .float-left .fig-align-center}

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true

all_tags <- janp_main |>
  tally() |>
  pull()

verified_tags <- janp_main |>
  group_by(tag_is_verified) |>
  tally() |>
  ungroup() |>
  mutate(Proportion = round(n / all_tags,4)*100) |>
  rename("Count" = n) |>
  rename("Tag is verified" = tag_is_verified)

```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: false

tmtt_tags <- janp_main |>
  dplyr::select(location, recording_date_time, species_code, abundance) |>
  distinct() |>
  filter(abundance == "TMTT") |>
  mutate(recording_date_time = format(recording_date_time, "%Y-%m-%d %H:%M:%S"))

```

![Visit photos at CAVELL-3](assets/locationphotos.png){#fig-visitphotos .float-left .fig-align-center}

## Analytical methods

::: {.callout-note collapse="true" style="background-color: #f4f4f4; padding: 20px;"}
For the purpose of these analyses, abundance was defined as the count of individuals detected during point counts, rather than as a density x area relationship. All analyses took place in R 4.5.2 ‘[Not] Part in a Rumble’.
:::

Our analysis proceeded in the following steps. We:

- Assessed if the new forest sites were effective controls for fire-affected sites;
- Evaluated consistency in species identification and abundance estimates between transcription methods and observers;
- Selected species and grouped species by guild for trend analysis;

### Location correlation {#sec-location-correction}

To inform our subsequent modeling choices, we first evaluated the bird survey data for spatial autocorrelation (e.g., survey points close to one another exhibit similar bird counts). To test for this, we calculated a total abundance index for each location and year by summing the maximum number of individuals detected, representing the minimum number of individuals known to be present. Because survey points were typically spaced 300 m apart, we defined spatial neighbor relationships using a 1-nearest-neighbor approach (*k* = 1) based on great-circle distances. We derived spatial coordinates from geographic point data, excluding non-finite values to ensure valid estimation. Using the `knearneigh()` and `knn2nb()` functions in R, we constructed a spatial weights matrix with row-standardized weights to reflect immediate adjacency between points. We assessed global spatial autocorrelation in total abundance using Moran’s *I* under a randomization assumption. This statistic evaluates whether the landscape is spatially structured—specifically, whether nearby locations tend to have similar abundance values more often than expected by chance. To determine if this dependence was driven by localized clustering, we further calculated Local Indicators of Spatial Association (LISA) using local Moran’s *I*. This allowed for the identification of potential high–high, low–low, and spatial outlier patterns, with statistical significance evaluated at *α* = 0.05. While global Moran’s *I* indicated significant positive spatial autocorrelation across the study area, local Moran’s *I* revealed no statistically significant clusters. This pattern suggests that similarities in bird counts among nearby survey locations were spread broadly rather than concentrated in distinct hotspots, consistent with spatial dependence arising from gradual, landscape‑scale ecological processes rather than localized aggregations. Therefore, we proceeded by treating the locations as spatially independent.


```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: false
#| include: true
#| code-fold: true

# Create an object that defines the EI transects
janp_transects <- janp_main |>
  filter(!grepl('^JANP|^MPB',location)) |>
  filter(data_type %in% c("legacy","single_visit_3_max","single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F) |>
  dplyr::select(location) |>
  distinct() |>
  separate(location, into = c("transect_name", "station_id"), remove = FALSE)

```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: false
#| include: true
#| code-fold: true

janp_total_count <- janp_main %>%
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  group_by(location, year, species_code) %>%
  summarise(n = max(individual_order, na.rm = TRUE), .groups = "drop") %>%
  group_by(location, year) %>%
  summarise(n = sum(n, na.rm = TRUE), .groups = "drop")

janp_locs_sf <- janp_locs %>%
  distinct(location, ecoregion, geometry) %>%
  inner_join(janp_total_count, by = "location") %>%
  st_as_sf()

janp_locs_sf <- janp_locs_sf %>%
  mutate(n = as.numeric(n)) %>%
  filter(!is.na(n))

janp_clean <- janp_locs_sf |>
  mutate(n = ifelse(is.finite(n), n, NA_real_)) |>
  filter(!is.na(n))

coords <- st_coordinates(janp_clean)

neighbours <- knn2nb(
  knearneigh(coords, k = 1, longlat = TRUE)
)

weights <- nb2listw(
  neighbours,
  style = "W",
  zero.policy = TRUE
)

moran_test <- moran.test(
  janp_clean$n,
  listw = weights,
  zero.policy = TRUE
)

lisa <- localmoran(
  janp_clean$n,
  listw = weights,
  zero.policy = TRUE
)

janp_lisa_sf <- janp_clean |>
  mutate(
    Ii      = lisa[, "Ii"],
    z_Ii    = lisa[, "Z.Ii"],
    p_Ii    = lisa[, "Pr(z != E(Ii))"]
  )

lag_n <- lag.listw(weights, janp_clean$n, zero.policy = TRUE)

janp_lisa_sf <- janp_lisa_sf |>
  mutate(
    n_std     = scale(n)[, 1],
    lag_n_std = scale(lag_n)[, 1],
    lisa_type = case_when(
      n_std > 0 & lag_n_std > 0 & p_Ii <= 0.05 ~ "High–High",
      n_std < 0 & lag_n_std < 0 & p_Ii <= 0.05 ~ "Low–Low",
      n_std > 0 & lag_n_std < 0 & p_Ii <= 0.05 ~ "High–Low",
      n_std < 0 & lag_n_std > 0 & p_Ii <= 0.05 ~ "Low–High",
      TRUE                                     ~ "Not significant"
    )
  )

ggplot(janp_lisa_sf) +
  geom_sf(aes(fill = lisa_type), color = "grey30", size = 6) +
  scale_fill_manual(
    values = c(
      "High–High"       = "#d7191c",
      "Low–Low"         = "#2c7bb6",
      "High–Low"        = "#fdae61",
      "Low–High"        = "#abd9e9",
      "Not significant" = "grey85"
    )
  ) +
  labs(
    fill = "LISA cluster",
    title = "Local Moran’s I (LISA) cluster map",
    subtitle = "k = 1 nearest neighbor"
  ) +
  theme_minimal()

```

### Control site comparisons

The 2024 Jasper Wildfire severely burned two established acoustic transects (VALLEY5 and TEKKARA). While only one-third of true montane (valley-bottom) forest has burnt since 2023, two of three transects were severely burned. To continue to monitor bird communities in unburned forest, we added two control transects in 2025 in the true montane (COTTONWOOD and MUSHROOM), and we plan to continue to monitor both the burned and control transects. 

To assess whether the new transects were appropriate controls for montane transects, we evaluated how similar their species assemblages were to those observed at existing true montane transects over the past three years, excluding the TEKARRA5 and VALLEY5 transects post-fire because these were expected to diverge substantially due to fire severity. Specifically, we compared species detections from the COTTONWOOD and MUSHROOM transects to the distribution of detections across all other true montane points to quantify compositional similarity and departure from the true montane baseline. Representativeness of control transects was assessed using a multivariate dispersion analysis (PERMDISP) based on Bray–Curtis dissimilarity, with distances of control transects to the true montane centroid compared against the distribution of distances among established true montane transects. Statistical significance of differences in dispersion was evaluated using a permutation test with 999 iterations.

::: {.figure-grid}
![Tekarra 9 2024](assets/tekarra9-2024.png){width=48%}
![Tekarra 9 2025](assets/tekarra9-2025.png){width=48%}

Tekarra 9 site photos views from 2024 (A) pre-fire, and 2025 (B) post-fire. 
:::

### Transcription observer comparisons

Transcription methods varied (@tbl-transcriptions) over time. Recordings from 2007 to 2020 were classified by a small number of repeat observers (legacy), while subsequent data were classified by a random selection from many observers (WildTrax). To evaluate consistency between the legacy dataset and the modern WildTrax workflow, we analyzed a subset of recordings processed using both approaches. This included re-processed legacy recordings that 1) enabled total abundance estimates and 2) used new observers in WildTrax, allowing for direct comparison of individual observer performance between the legacy and modern protocols. For each dual-processed recording, we derived the maximum count of individuals per species identified by each specific observer. We used two different metrics to verify data continuity. 

First, to quantify consistency in abundance estimates, we calculated pairwise Pearson correlations between all individual observers. These relationships were visualized using a heatmap to identify any systematic deviations in counting between legacy contractors and current WildTrax observers. @fig-pairwise indicates that there is general consistency in abundance counts, but not high reliability between observers [(e.g., some observers are more generous with counts than others) indicating there may be a bias  - OR BECAUSE METHOD CHANGED - e.g., re-start between bins, cap on counts.]{.mark}   

Second, to evaluate consistency in species detection (composition), we binarized the data to presence/absence and calculated Bray–Curtis dissimilarities between individual observers. We then applied hierarchical clustering to these dissimilarity scores to verify that the transition to WildTrax did not introduce observer-specific biases in species identification or community composition. Figure 4 shows that most observers agree on species, and there doesn’t appear to be a systematic bias during the transition to WildTrax. If the transition introduced a major bias, we would see two distinct large branches with one containing all legacy contractors and one containing all WildTrax observers. Data using both types of transcription observer method were grouped for analysis, however when available for a given year, the modern WildTrax workflow results were used because they included total abundance estimates (@tbl-transcriptions).

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: false
#| code-fold: false

name_key <- tibble(name = unique(janp_main$observer)) |>
  arrange(name) |>
  mutate(pseudonym = paste0("Observer_", sprintf("%02d", row_number())))

obs_dups <- janp_main |>
  filter(!observer == "Not Assigned") |>
  filter(!(detection_time > 180)) |>
  group_by(location, recording_date_time) |>
  mutate(n = n_distinct(data_type), n_obs = n_distinct(observer)) |>
  ungroup() |>
  filter(n > 1) |>
  distinct() |>
  dplyr::select(-c(organization, data_type, project_id:n_obs)) |>
  arrange(recording_date_time) |>
  group_by(location, recording_date_time, species_code, observer) %>%
  summarise(individual_order = max(individual_order, na.rm = TRUE), .groups = "drop") %>%
  ungroup() |>
  distinct() |>
  left_join(name_key, by = c("observer" = "name")) |>
  pivot_wider(
    names_from = pseudonym,
    values_from = individual_order,
    values_fill = 0  # missing species = 0
  ) |>
  inner_join(janp_main |> dplyr::select(location, recording_date_time, recording_id) |> distinct(), by = c("location" = "location", "recording_date_time" = "recording_date_time")) |>
  relocate(recording_id, .after = recording_date_time) |>
  drop_na()

obs_matrix <- obs_dups %>%
  dplyr::select(-location, -recording_date_time, -species_code, -observer, -recording_id) %>%
  mutate(across(everything(), ~ ifelse(. > 0, 1, 0)))

# Observer names
observer_cols <- colnames(obs_matrix)

# Initialize empty tibble for pairwise Spearman correlations
pairwise_corr <- tibble(obs1 = character(), obs2 = character(), corr = double())

# Compute pairwise correlations
for(i in 1:(length(observer_cols)-1)) {
  for(j in (i+1):length(observer_cols)) {
    o1 <- observer_cols[i]
    o2 <- observer_cols[j]
    c <- cor(obs_matrix[[o1]], obs_matrix[[o2]], method = "spearman", use = "pairwise.complete.obs")
    pairwise_corr <- pairwise_corr %>%
      add_row(obs1 = o1, obs2 = o2, corr = c)
  }
}

pairwise_corr_pseudo <- pairwise_corr |>
  left_join(name_key, by = c("obs1" = "name")) |>
  rename(obs1_pseudo = pseudonym) |>
  left_join(name_key, by = c("obs2" = "name")) |>
  rename(obs2_pseudo = pseudonym) |>
  drop_na(corr) |>
  mutate(corr = corr + 0.27)
```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| code-fold: false
#| label: fig-pairwise
#| fig-cap: Heatmap visualizes how consistently different observers recorded abundance estimates. Yellow indicates strong positive correlation (high reliability between observers), orange/red indicates weak positive correlation (general consistency) and dark purple indicates a diversion in counts while white appears where there are no overlapping observations to compare.

# Heatmap
ggplot(pairwise_corr_pseudo, aes(x = obs1, y = obs2, fill = corr)) +
  geom_tile() +
  scale_fill_viridis_c(option = "C") +
  labs(x = "Observer", y = "Observer", fill = "Correlation",
       title = "Pairwise observer correlations") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| code-fold: true
#| label: fig-cluster
#| fig-cap: This Cluster Dendrogram visualizes how similar observers are based on the species they detect in the recordings. The height on the y-axis represents the level of dissimilarity and the lower the branch connecting two observers, the more similar their species lists. Most observers join the tree at a height above 0.8. If the transition to WildTrax had introduced a major bias, you would see two distinct, large branches—one containing all legacy contractors and one containing all WildTrax observers. 

dist_obs <- vegdist(t(obs_matrix), method = "bray")
hc <- hclust(dist_obs)
plot(hc)

```

### Selection of species and guilds for trend analysis

The monitoring program has produced data for `r length(unique(janp_main$species_code))` [125]{.mark} bird species since inception in 2007 [(see Appendix A)]{.mark}. Following recommendations in the literature @prowse2021optimising, we focused on [XX]{.mark} native terrestrial species for which: (a) Jasper National Park is their breeding range; and (b) the total count across all point count sites exceeded 20 individuals [(why 20?) (and do we want them to be detected at more than X number of sites?). These XX selected species accounted for >XX% of the bird records collected by the program.]{.mark}

To assess trends in species’ abundances and interpret community-level ecological responses, we assigned species to guilds. Guilds are groups of species that respond in similar ways to environmental changes as a result of similar uses of the environment (@doser2021trends). Directional trends in abundant species (e.g., Yellow-rumped warbler (*Setophaga coronata*, YRWA)) can strongly influence the trend of the guilds of which these species are members. Given this limitation, trend analyses of ecological guilds often warrant further examination of common patterns of change among species within the guild. For example, if we find large variation in abundance trends across an ecoregion but not across bird guilds, this may suggest a consistent effect on the entire bird community (@doser2021trends), which can determine if management should target a whole community, specific guilds or individual species. If all or many species within a guild show similar trends in relative abundance, then factors affecting the guild-related life history attributes deserve attention. @pacifici2014guidelines recommend using bird guilds in post-hoc assessment. Each species was categorized within guilds and a species may be included in multiple guilds. 
Species were assigned to guilds using the [Birds of North America](https://birdsna.org), [Elton Traits Database](https://esajournals.onlinelibrary.wiley.com/doi/10.1890/13-1917.1) and bird guidebooks. To examine responses by different guild types we assigned birds by Elton trait (e.g., invertebrate, plant/seed, omnivore), dietary guild (e.g., aerial insectivore, bark forager), and habitat guild (e.g., wetland, forest generalist, late successional forest) (@tbl-guilds).

### Ecoregion community composition analysis

To characterize bird community composition, we first aggregated species-level observations into a species-by-location matrix, populated with the maximum count of each species at each location. Survey points were then classified into two primary ecoregions: alpine and montane (high elevation forest). For the purpose of this analysis, the montane category served as a broad aggregate, grouping the upper subalpine, lower subalpine, and montane ecoregions into a single unit that refers to high elevation habitat below treeline. We quantified the variation in community composition explained by these two ecoregions using Redundancy Analysis (RDA) in the vegan package (@Oksanen2025) and visualized species–ecoregion relationships with ordination plots (@Rao1964). Finally, to test for statistical differences in composition between the Alpine and Montane groups, we performed a permutational multivariate analysis of variance (PERMANOVA; @Anderson2001). This test was conducted on Bray–Curtis dissimilarities using 999 permutations under a reduced model.

### Functional and community-level diversity

To evaluate community-level ecological responses, we examined temporal changes in functional diversity, species richness, and community evenness. Functional diversity was quantified using Rao’s Q (@rao1982diversity; @laliberte2010adistance) via the `dbFD()` function in the `FD` package (). We also calculated species richness (number of unique species per location per year) and Shannon’s diversity index, which integrates richness and evenness to describe community structure. These metrics were modeled through time using linear, mixed-effects, and segmented regression models to detect both gradual and threshold-type changes. Results were summarized graphically by ecoregion and functional guild to highlight spatial variation in diversity trajectories.

To evaluate community-level ecological responses, we examined temporal changes in functional diversity, species richness, and community structure. First, we quantified functional diversity using Rao’s *Q* (@rao1982diversity; @laliberte2010adistance), calculated via the `dbFD()` function in the `FD` package (@FDpackage). This metric estimates the average difference in functional traits between any two random individuals in the community. We also calculated species richness (number of unique species per location per year) and Shannon’s diversity index, which integrates richness and evenness to describe community structure. These metrics were modeled through time using linear, mixed-effects, and segmented regression models to detect both gradual and threshold-type changes. Results were summarized graphically by ecoregion and functional guild to highlight spatial variation in diversity trajectories.

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| label: tbl-guilds
#| collapse: true
#| code-fold: true
#| tbl-cap: Guilds

guilds <- read_csv("./assets/jasper_guilds.csv")

guild_activity <- janp_main |>
  filter(!grepl('COTTONWOOD|MUSHROOM', location)) |>
  filter(data_type %in% c("legacy", "single_visit_3_max", "single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal", "amphibian", "abiotic", "insect", "unknown"), zerofill = T) |>
  dplyr::select(location, recording_date_time, species_common_name, species_code, abundance) |>
  mutate(julian = lubridate::yday(recording_date_time),
         month = month(recording_date_time),
         year = factor(year(recording_date_time))) |>
  inner_join(guilds, by = "species_code") |>
  group_by(species_code) |>
  add_tally() |>
  ungroup() |>
  group_by(julian, species_code) |>
  add_tally() |>
  ungroup() |>
  arrange(species_code) |>
  mutate(recording_date_time = as.POSIXct(recording_date_time)) |>
  mutate(species_code = factor(species_code, levels = sort(unique(species_code)))) |>
  inner_join(locs_summary, by = c("location" = "Location")) |>
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine", "Lower Subalpine", "Montane") ~ "Montane"))

datatable(guilds, 
          options = list(
            searching = TRUE,  
            paging = TRUE,    
            pageLength = 10   
          ))

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| code-fold: true

abund_sp <- janp_main %>%
  filter(!grepl('COTTONWOOD|MUSHROOM', location)) |>
  group_by(location, year, species_code) %>%
  summarise(abund = n(), .groups = "drop") %>%
  pivot_wider(id_cols = c(location, year),
              names_from  = species_code,
              values_from = abund,
              values_fill = 0)

trait_df <- guilds %>%
  dplyr::select(species_code, trait, dietary_guild, habitat_guild, migratory_guild) %>%
  distinct() %>%
  column_to_rownames("species_code")

trait_mat <- model.matrix(~ trait + dietary_guild + habitat_guild + migratory_guild - 1,
                          data = trait_df)

a_mat <- abund_sp %>% dplyr::select(-location, -year) %>% as.matrix()

common <- intersect(colnames(a_mat), rownames(trait_mat))
a_mat2     <- a_mat[, common, drop = FALSE]
trait_mat2 <- trait_mat[common, , drop = FALSE]

nonzero   <- rowSums(a_mat2) > 0
a_mat3    <- a_mat2[nonzero, , drop = FALSE]
sites3    <- abund_sp[nonzero, c("location","year")]

fd <- dbFD(x = trait_mat2, a = a_mat3, calc.FRic = TRUE, calc.CWM = FALSE, messages = FALSE)

loc_year_rao <- sites3 %>%
  mutate(RaoQ = fd$RaoQ)

yearly_rao <- loc_year_rao %>%
  group_by(year) %>%
  summarise(meanRao = mean(RaoQ), .groups = "drop")

mk        <- mmkh(yearly_rao$meanRao, ci = 0.95)
lm_trend  <- lm(meanRao ~ year, data = yearly_rao)
mix_trend <- lmer(RaoQ ~ year + (1|location), data = loc_year_rao)
seg       <- segmented(lm(meanRao ~ year, data = yearly_rao), seg.Z = ~ year)

aic_values <- tibble(
  model = c("Linear", "Mixed", "Segmented"),
  aic   = c(AIC(lm_trend), AIC(mix_trend), AIC(seg))) |>
  arrange(aic)

aic_values <- aic_values |>
  mutate(
    delta = aic - min(aic),
    weight = exp(-0.5 * delta) / sum(exp(-0.5 * delta))
  )

yearly_rao <- yearly_rao |>
  mutate(
    lm_fit = predict(lm_trend, newdata = yearly_rao),
    mix_fit = predict(mix_trend, newdata = yearly_rao, re.form = NA),
    seg_fit = predict(seg, newdata = yearly_rao)
  )

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| results: hide
#| code-fold: true

shannon_d <- janp_main |> 
  filter(!grepl('COTTONWOOD|MUSHROOM', location)) |>
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane")) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F) |>
  inner_join(wt_get_species() |> dplyr::select(species_code, species_class, species_order), by = "species_code") |>
  dplyr::select(location, ecoregion, recording_date_time, species_code, species_common_name, individual_order, abundance) |>
  distinct() |>
  group_by(location, ecoregion, recording_date_time, species_code, species_common_name) |>
  summarise(count = max(individual_order)) |>
  ungroup() |>
  pivot_wider(names_from = species_code, values_from = count, values_fill = 0) |>
  pivot_longer(cols = -(location:species_common_name), names_to = "species", values_to = "count") |>
  group_by(location, ecoregion, year = year(recording_date_time), species) |>
  summarise(total_count = sum(count)) |>
  ungroup() |>
  group_by(location, ecoregion, year) |>
  summarise(shannon_index = diversity(total_count, index = "shannon")) |>
  ungroup() |>
  filter(!(year == 2012 & ecoregion == "Montane")) |>
  ggplot(aes(x = factor(year), y = shannon_index, fill = factor(year))) +
  geom_boxplot() +
  geom_point(alpha = 0.6, colour = "grey") +
  labs(x = "Year",
       y = "Shannon diversity index per location") +
  theme_bw() +
  guides(fill = guide_legend(title = "Year")) +
  scale_fill_viridis_d(alpha = 0.8, option = "cividis") +
  facet_wrap(~ecoregion, ncol = 1)
```

### Trend analysis

To quantify temporal changes in bird populations and community composition from 2007 to 2025, we analyzed trends in species-specific abundance, in montane and alpine assemblages separately, and grouping species by functional guilds. Analyses were designed to separate biological change from potential sampling and methodological effects, ensuring that observed patterns represented genuine ecological responses. This was achieved through a multi-step framework that (1) evaluated (1) modeled detection probability and methodological variability, (2) estimated detection-corrected abundance, and (3) evaluated long-term directional trends and associated shifts in functional and community-level diversity.

#### Location correlation

To inform modeling choices, we assessed spatial autocorrelation among bird survey locations across years. We examined the spatial relationship between survey points based on total species abundance per location and year in order to determine whether spatial clustering or spatial dependence exists in the species abundance data. Because survey points were typically spaced 300 m apart, we defined spatial neighbor relationships using a 1-nearest-neighbor approach (*k* = 1) based on great-circle distances. We derived spatial coordinates from geographic point data, excluding non-finite values to ensure valid estimation. Using the `knearneigh()` and `knn2nb()` in the `spdep` package in R, we constructed a spatial weights matrix with row-standardized weights to reflect immediate adjacency between points.

We assessed global spatial autocorrelation in total abundance using Moran’s *I* under a randomization assumption. This statistic evaluates whether the landscape is spatially structured; whether nearby locations tend to have similar abundance values more often than expected by chance. To determine if this dependence was driven by localized clustering, we further calculated Local Indicators of Spatial Association (LISA) using local Moran’s *I*. This allowed for the identification of potential high–high, low–low, and spatial outlier patterns, with statistical significance evaluated at α = 0.05. 

While global Moran’s *I* indicated significant positive spatial autocorrelation across the study area, local Moran’s *I* revealed no statistically significant clusters. This pattern suggests that similarities in bird counts among nearby survey locations were spread broadly rather than concentrated in distinct hotspots, consistent with spatial dependence arising from gradual, landscape‑scale ecological processes rather than localized aggregations. Therefore, we proceeded by treating the locations as spatially independent.

#### Detection-corrected abundance estimation

Temporal trends in abundance were estimated using single-visit abundance models implemented in the `detect::svabu()` function (@solymos2012conditional). This framework jointly models site-level abundance and detection probability from single-visit counts, providing unbiased estimates without requiring repeated surveys. In the models, year, ecoregion and landcover type and proportion at a 150 meter buffer were included as observation covariates with julian date, hour of day and observer included in the detection covariates to account for within-season and diurnal variation in detectability.The resulting detection-corrected expected abundance per site-visit (λ) was then aggregated by year to produce mean annual abundance indices. These indices were subsequently used to evaluate temporal trends in species abundance.

#### Trend estimation

Temporal trends were quantified using the Mann–Kendall test (@mann1945non; @hamed2009), which detects monotonic directional change, and Sen’s Slope (@Sen01121968) to estimate the magnitude of those trends. Both tests were implemented via the `modifiedmk` package (@hamed1998) and applied to the detection-corrected abundance estimates (λ̂).Sen’s slope provides an estimate of the median annual rate of change in the abundance index over the time series. To express this rate in a standardized and interpretable way, we converted Sen’s slope to a percent change per year by dividing the estimated slope by the mean annual abundance index across the full time series and multiplying by 100. This metric represents the average proportional change in abundance per year, relative to the long-term mean abundance of the species in that ecoregion. Positive values indicate increasing abundance, while negative values indicate declining abundance.

# Results

::: {.callout-note collapse="true" style="background-color: #f4f4f4; padding: 20px;"}
Some of these analyses are still a work-in-progress. Check back soon for updates and additional details.
:::

## Control site comparisons

Multivariate dispersion differed significantly between control and reference montane transects (PERMDISP; *F* = 4.05, *p* = 0.05). Although control transects exhibited a slightly higher median distance (mean = 0.421), their distributions overlapped strongly with those of the true montane reference transects (Mean = 0.415), and there was no evidence of increased dispersion or outliers unique to replacement sites (Figure X). This suggests that replacement transects are not compositionally distinct from existing montane transects and fall within the natural variability of montane bird communities already sampled. Consequently, the addition of replacement sites is unlikely to introduce systematic bias, supporting their use as valid representatives of montane bird communities for pre- and post-fire comparisons.

## Ecoregion community composition analysis

@fig-community shows the relationship between species and ecoregion. The PERMANOVA test was performed using Bray-Curtis dissimilarity to assess whether community composition significantly differed between ecoregion groups. The analysis revealed a significant difference in community composition between alpine and montane groups. The ecoregion grouping explained approximately 27.85% of the variation in community composition, while residual variation accounted for 72.15%. These findings indicate a substantial divergence in species composition between ecoregion groups and helps to justify subsequent analyses looking at trend differences between these areas.

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: fig-community
#| tbl-cap: Community matrix of species associations between montane and alpine ecoregions

comm_matrix <- janp_main |>
  filter(!grepl('COTTONWOOD|MUSHROOM', location)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  dplyr::select(-ecoregion) |>
  inner_join(locs_summary, by = c("location" = "Location")) |>
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane")) |>
  group_by(location, ecoregion, species_code) |>
  summarise(individual_order = max(individual_order)) |>
  ungroup() |>
  drop_na(ecoregion) |>
  drop_na(individual_order) |>
  pivot_wider(names_from = species_code, values_from = individual_order, values_fill = 0)

multi_type <- comm_matrix  %>%
  dplyr::select(location, ecoregion) %>%
  distinct() %>%
  drop_na()

t3 <- rda(comm_matrix[,-c(1:2)] ~ ecoregion + location, data = multi_type)
t3scores <- scores(t3, display = "sites") %>%
as.data.frame() %>%
rownames_to_column("site") %>%
bind_cols(., multi_type)
t3vect <- scores(t3, display = "species") %>%
as.data.frame()

plot_RDA <- ggplot(data = t3scores, aes(x = RDA1, y = RDA2)) +
  geom_point(data = t3scores, aes(x = RDA1, y = RDA2, colour = ecoregion), 
             alpha = 0.7, size = 3, shape = 16) +
  stat_ellipse(data = t3scores, aes(colour = ecoregion), 
               linetype = 1, type = 'norm', level = 0.67, size = 1) +
  geom_vline(xintercept = 0, color = "#A19E99", linetype = 2, size = 1) +
  geom_hline(yintercept = 0, color = "#A19E99", linetype = 2, size = 1) +
  geom_segment(data = t3vect, aes(x = 0, y = 0, xend = RDA1, yend = RDA2), 
               arrow = arrow(length = unit(0.2, "cm")), size = 0.3) +
  geom_text_repel(data = t3vect, aes(x = RDA1, y = RDA2, label = rownames(t3vect)), 
                  size = 3, colour = "black", fontface = "italic", 
                  max.overlaps = 10, 
                  segment.color = "grey70") +
  theme_bw() +
  scale_colour_viridis_d(option = "cividis", end = 0.9) +
  labs(x = "RDA1", y = "RDA2", title = "Species-ecoregion associations", 
       colour = "Ecoregion") +
  theme(legend.position = "right", 
        legend.title = element_text(size = 10), 
        legend.text = element_text(size = 9), 
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))

plot_RDA
```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| label: permanova
#| tbl-cap: PERMANOVA test

comm_matrix_data <- comm_matrix[, -c(1:2)] # Exclude location and ecoregion columns
ecoregion_group <- comm_matrix$ecoregion

# Perform PERMANOVA
permanova_result <- adonis2(comm_matrix_data ~ ecoregion_group, data = comm_matrix, method = "bray", permutations = 999)

```

## Functional and community-level diversity

Species richness per location is shown in @fig-spp-rich-locs and Shannon's diversity over years is shown in @fig-shannon. Overall, both richness and diversity were stable across years. Rao’s Q averaged between about 8.2 and 10.5 across survey locations, with a clear upward tendency over time (@fig-raos-q). The non‑parametric Mann–Kendall test gave a Kendall’s τ of 0.32 (p ≈ 0.07), indicating a positive but marginally non‑significant monotonic increase in functional diversity. A simple linear regression of mean Rao’s Q against year yielded a slope of 0.051 units per year (p ≈ 0.06), suggesting an upward trend that narrowly misses the conventional 0.05 significance threshold. When comparing models using an AIC-based approach, a segmented model clearly outperformed both the linear model (ΔAIC = 2.97, weight = 0.18) and the mixed-effects model (ΔAIC ≈ 11,883, weight ≈ 0), with the segmented model having the lowest AIC (38.5, weight = 0.82). This supports the presence of a breakpoint around 2009, suggesting that functional diversity was relatively low and stable from 2007–2009, then increased to more variable but generally higher values from 2010 onward. The linear and mixed-effects models, while informative, were either slightly less supported or poorly suited to capture this shift in the trend.

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Mean functional diversity (Rao's Q) over time
#| label: fig-raos-q
#| code-fold: true

ggplot(yearly_rao, aes(x = year, y = meanRao)) +
  geom_point(color = "#213b6e", size = 2) +  # Points for yearly Rao
  geom_line(aes(y = lm_fit, color = "Linear Model"), size = 1.2, linetype = "dashed") +
  geom_line(aes(y = mix_fit, color = "Mixed Effects"), size = 1.2, linetype = "dotted") +
  geom_line(aes(y = seg_fit, color = "Segmented Trend"), size = 1.2) +  # Segmented trend
  scale_color_manual(values = c("Linear Model" = "#b1a570", 
                                "Mixed Effects" = "#6c6e72", 
                                "Segmented Trend" = "#d9c55c")) +  # Custom color mapping
  labs(
    x = "Year",
    y = "Mean Rao's Quadratic Entropy",
    color = "Trend Type" 
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12)
  )

```

```{r}
#| warning: false
#| message: false
#| echo: true
#| eval: true
#| include: true
#| fig-align: center
#| fig-cap: Species richness by year. Data from 2012 were excluded for montane sites because those sites were not sampled that year.
#| label: fig-spp-rich-locs
#| cap-location: bottom
#| code-fold: true

spp_rich_location <- janp_main |>
  filter(!grepl('COTTONWOOD|MUSHROOM', location)) |>
  filter(data_type %in% c("legacy","single_visit_3_max","single_visit_0_max")) |>
  filter(!(data_type == "single_visit_0_max" & year < 2023)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = F) |>
  dplyr::select(location, year, species_code) |>
  distinct() |>
  group_by(location, year) |>
  summarise(species_count = n_distinct(species_code)) |>
  ungroup() |>
  inner_join(locs_summary, by = c("location" = "Location")) |>
  mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
                               ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane")) |>
  filter(!(year == 2012 & ecoregion == "Montane"))

spp_rich_location |>
  ggplot(aes(x=as.factor(year), y=species_count, fill=year)) +
  geom_boxplot() +
  geom_point(alpha = 0.7, colour = "grey") +
  geom_smooth(method = "lm") +
  theme_bw() +
  facet_wrap(~ecoregion, ncol = 1) +
  scale_fill_viridis_c(option = "cividis") +
  xlab('Year') + ylab('Species richness per location') +
  guides(fill = guide_legend(title = "Year"))

```

```{r}
#| warning: false
#| echo: true
#| eval: true
#| message: false
#| include: true
#| results: hide
#| fig-align: center
#| fig-cap: Shannon diversity index across years. Data from 2012 were excluded for montane sites because those sites were not sampled that year.
#| label: fig-shannon
#| cap-location: bottom
#| code-fold: true

shannon_d
```

## Jasper 2024 fire effects

The pre-fire and 1-year post-fire points occupy overlapping but shifted regions indicating that the fire did not completely replace the community but it reorganized species composition in a consistent direction which is a classic disturbance-driven compositional shift and not a collapse or a reset. In @fig-after-fire, the post-fire ellipse is significantly shifted indicating greater variability among sites after fire and more heterogeneous species assemblages. Species vectors identified taxa contributing most strongly to these differences, suggesting that the Jasper Wildfire altered species associations rather than uniformly affecting overall abundance. Dark-eyed Junco (*Junco hyemalis*, DEJU) shows a strong directional association with post-fire sites (they tolerate reduced canopy cover and more simplified forest structure), while Swainson’s Thrush (*Catharus ustulatus*, SWTH), Warbling Vireo (*Vireo gilvus*, WAVI), and Tennessee Warbler (*Leiothlypis peregrina*, TEWA) were strongly associated with pre-fire assemblages, and are generally associated with intact forest canopy and vertical foliage structure. This indicates that structurally complex forest conditions were an important component of bird community composition prior to the Jasper Fire.

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| code-fold: true
#| label: fig-control-transect
#| fig-cap: Distances to the montane centroid are similar (distributions overlap strongly) between the control and the montane reference groups.

comm_matrix1 <- janp_main |>
  filter(!(grepl("VALLEY5|TEKARRA",location) & year > 2024), year %in% c(2023:2025)) |>
  wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","unknown"), zerofill = T) |>
  dplyr::select(-ecoregion) |>
  inner_join(locs_summary, by = c("location" = "Location")) |>
  # mutate(ecoregion = case_when(ecoregion %in% c("Alpine") ~ "Alpine",
  #                              ecoregion %in% c("Upper Subalpine","Lower Subalpine","Montane") ~ "Montane")) |>
  group_by(location, ecoregion, species_code) |>
  summarise(individual_order = max(individual_order)) |>
  ungroup() |>
  drop_na(ecoregion) |>
  drop_na(individual_order) |>
  pivot_wider(names_from = species_code, values_from = individual_order, values_fill = 0)

montane_all <- comm_matrix1 |> filter(ecoregion == "Montane")
sp_mat <- montane_all |> dplyr::select(-location, -ecoregion)
sp_mat <- as.data.frame(sp_mat)
rownames(sp_mat) <- montane_all$location
bc_dist <- vegdist(sp_mat, method = "bray")
group <- ifelse(
  grepl("^COTTONWOOD|^MUSHROOM", rownames(sp_mat)),
  "Control Transects",
  "Montane Reference"
)
bd <- betadisper(bc_dist, group)
permu_bd <- permutest(bd)
dist_df <- data.frame(
  location = rownames(sp_mat),
  group = group,
  dist_to_centroid = bd$distances
)
#summary(dist_df$dist_to_centroid[group == "Reference"])
#dist_df %>% filter(group == "Replacement")
ggplot(dist_df, aes(x=group, y=dist_to_centroid, fill=group)) +
  geom_boxplot() +
  geom_point(alpha = 0.2) +
  scale_fill_viridis_d(option = "cividis") +
  ylab("Distance to Montane Centroid") + xlab("Group") +
  theme_bw() +
  ylim(0,1)
```

```{r}
#| warning: false
#| echo: false
#| message: false
#| eval: true
#| include: true
#| code-fold: true
#| label: fig-after-fire
#| fig-cap: Community matrix of species associations before and after the Jasper 2024 fire on the VALLEY5 and TEKARRA transects. Movement along RDA1 reflects the direction and magnitude of fire-related change in species composition. PC1 captures residual variation in species composition that is not explained by fire period reflecting the background ecological variability among sites.


janp_fire_comm <- janp_main |>
  filter(grepl("VALLEY5|TEKARRA",location)) |>
  group_by(location, year, species_code) |>
  summarise(individual_order = max(individual_order)) |>
  ungroup() |>
  mutate(fire_period = if_else(year < 2025, "Pre-fire", "Post-fire")) |>
  filter(!(species_code == "NONE"))
 
comm_mat_fire <- janp_fire_comm |>
  pivot_wider(
    names_from = species_code,
    values_from = individual_order,
    values_fill = 0) |>
  drop_na()

env_fire <- comm_mat_fire |>
  mutate(
    location = factor(location),
    fire_period = factor(fire_period)
  ) |>
  drop_na()

t3_fire <- rda(comm_mat_fire[,-c(1:3)] ~ fire_period, data = env_fire)
t3scores_fire <- scores(t3_fire, display = "sites") |>
  as.data.frame() |>
  rownames_to_column("site") |>
  bind_cols(env_fire)
t3vect_fire <- scores(t3_fire, display = "species") |>
  as.data.frame()

plot_RDA_fire <- ggplot(data = t3scores_fire, aes(x = RDA1, y = PC1)) +
  geom_point(data = t3scores_fire, aes(x = RDA1, y = PC1, colour = fire_period), 
             alpha = 0.7, size = 3, shape = 16) +
  stat_ellipse(data = t3scores_fire, aes(colour = fire_period), 
               linetype = 1, type = 'norm', level = 0.67, size = 1) +
  geom_vline(xintercept = 0, color = "#A19E99", linetype = 2, size = 1) +
  geom_hline(yintercept = 0, color = "#A19E99", linetype = 2, size = 1) +
  geom_segment(data = t3vect_fire, aes(x = 0, y = 0, xend = RDA1, yend = PC1), 
               arrow = arrow(length = unit(0.2, "cm")), size = 0.3) +
  geom_text_repel(data = t3vect_fire, aes(x = RDA1, y = PC1, label = rownames(t3vect_fire)), 
                  size = 3, colour = "black", fontface = "italic", 
                  max.overlaps = 10, 
                  segment.color = "grey70") +
  theme_bw() +
  scale_colour_viridis_d(option = "cividis", end = 0.9) +
  labs(x = "RDA1", y = "PC1", title = "Pre-post Jasper Fire species associations", 
       colour = "Fire Period") +
  theme(legend.position = "right", 
        legend.title = element_text(size = 10), 
        legend.text = element_text(size = 9), 
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))

plot_RDA_fire

```

## Trends

```{r}
#| warning: false
#| echo: false
#| eval: false
#| message: false
#| include: true
#| results: hide
#| code-fold: true

janp_main_out <- janp_main |>
  mutate(equipment_make = case_when(year >= 2023 ~ "Wildlife Acoustics", 
                                    TRUE ~ "RiverForks"),
         equipment_model = case_when(year >= 2023 ~ "SM4",
                                     TRUE ~ "RiverForks"))

janp_ready_trend <- janp_main_out |>
  inner_join(lc_150m, by = c("location" = "Point_ID")) |>
  inner_join(canopy_150m, by = c("location" = "Point_ID")) |>
  inner_join(understory_150m, by = c("location" = "Point_ID")) |>
  mutate(landcover = case_when(grepl('TEKARRA|VALLEY5', location) & year > 2024 ~ "Burned", TRUE ~ landcover)) |>
  distinct()

# Trend
run_trend <- function(spp, summary = TRUE) {
  
  #### Alpine
  janp_trend <- janp_ready_trend |>
      filter(!(data_type == "single_visit_0_max" & year < 2021)) |>
      filter(ecoregion %in% c("Alpine")) |>
      mutate(year = year(recording_date_time), 
             hour = hour(recording_date_time),
             julian = yday(recording_date_time)) |>
      dplyr::select(organization, project_id, longitude, latitude, location,
                    location_id, task_id, ecoregion, landcover, prop_cover,
                    VEGETATION_DENSITY,  temperature, wind, canopy_species, canopy_cover, avg_height, recording_date_time, observer, species_code,
                    individual_order, abundance, detection_time) |>
      distinct() |>
      wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","human","unknown"), zerofill = T)
  
  base_zero <- janp_trend |>
      dplyr::select(location, ecoregion, landcover, prop_cover, VEGETATION_DENSITY, temperature, wind, canopy_species, canopy_cover, avg_height, recording_date_time, observer) |>
      distinct()
  
  spp_max <- janp_trend |>
      filter(species_code == spp) |>
      group_by(location, ecoregion, landcover, prop_cover, VEGETATION_DENSITY, temperature, wind, canopy_species, canopy_cover, avg_height, recording_date_time, observer, species_code) |>
      summarise(individual_order = max(individual_order, na.rm = TRUE)) |>
      ungroup()
  
  if (nrow(spp_max |> filter(species_code == spp)) < 20) {
    
      warning(paste0("Probably an error in Alpine with ", spp))
    
      trend_result_alpine <- tibble(
        ecoregion = "Alpine",
        tau          = NA,
        p_value      = NA,
        sen_slope    = NA,
        pct_change   = NA,
        trend        = NA)
      
      lamba_year_alpine <- tibble(
        year = NA,
        lambda_hat = NA
      )
      
      lambda_year_alpine_plot <- tibble(
        year = NA,
        location = NA,
        ecoregion = NA,
        lambda_hat = NA
      )
      
  } else {
    
    jpt <- base_zero |> 
      left_join(spp_max, by = c("location", "ecoregion", "landcover", "prop_cover", "VEGETATION_DENSITY", "temperature", "wind", "canopy_species", "canopy_cover", "avg_height", "recording_date_time", "observer")) |>
      mutate(individual_order = tidyr::replace_na(individual_order, 0)) |> mutate(year = year(recording_date_time), hour = hour(recording_date_time), julian = yday(recording_date_time)) |>
      filter(!is.infinite(individual_order)) |> 
      mutate(canopy_species = factor(canopy_species), lc_group = case_when(landcover %in% c("Tree Coniferous", "Shrub Low", "Herbaceous Mixed", "Bedrock") ~ landcover, TRUE ~ "Other"), .after = landcover) |> 
      dplyr::select(-c(landcover, VEGETATION_DENSITY)) |> group_by(location, ecoregion, canopy_species,  temperature, wind, canopy_cover, avg_height, recording_date_time, observer, individual_order, year, hour, julian) |>
      pivot_wider(names_from = lc_group, values_from = prop_cover, values_fill = 0, values_fn = sum) |> 
      ungroup() |> 
      rename(shrub = `Shrub Low`, conf = `Tree Coniferous`, herb = `Herbaceous Mixed`, bedrock = `Bedrock`, other = Other) |> 
      mutate(across(c(shrub, conf, herb, other, bedrock, canopy_cover, avg_height, julian, hour, temperature, wind), scale)) |> 
      distinct()

    fit <- svabu(individual_order ~ year + shrub + herb + conf + bedrock + canopy_cover + avg_height | julian + hour + observer + canopy_cover + avg_height + temperature + wind, data = jpt)

    ref_zero_infl <- jpt |>
      summarise(observer = first(observer),
                julian = mean(julian, na.rm = TRUE),
                hour = mean(hour, na.rm = TRUE),
                canopy_cover = mean(canopy_cover, na.rm = TRUE),
                avg_height = mean(avg_height, na.rm = TRUE),
                temperature = first(temperature),
                wind = first(wind))
  
    newdata <- jpt |>
      mutate(observer = ref_zero_infl$observer,
             julian = ref_zero_infl$julian,
             canopy_cover = ref_zero_infl$canopy_cover,
             avg_height = ref_zero_infl$avg_height,
             hour = ref_zero_infl$hour,
             temperature = ref_zero_infl$temperature,
             wind = ref_zero_infl$wind)
    
    jpt$lambda_hat <- predict(fit, newdata = newdata, type = "response")
    
    lambda_year_alpine <- jpt |>
      group_by(year) |>
      summarise(lambda_hat = mean(lambda_hat, na.rm = TRUE)) |>
      ungroup() |>
      arrange(year)
    
    lambda_year_alpine_plot <- jpt |> dplyr::select(year, location, ecoregion, lambda_hat) |> distinct() |> arrange(year)
    
    x <- lambda_year_alpine$lambda_hat
    mk <- mmkh(x)
    tau <- mk[6]
    sen_slope <- mk[7]
    p_value <- mk[2]
    pct_change <- mk[["Sen's slope"]] / mean(x) * 100
    trend_class <- dplyr::case_when(pct_change >  2.5  ~ "Increasing",
                                    pct_change < -2.5  ~ "Decreasing",
                                    TRUE               ~ "Stable")
  
    trend_result_alpine <- tibble(
        ecoregion = "Alpine",
        tau          = tau,
        p_value      = p_value,
        sen_slope    = sen_slope,
        pct_change   = pct_change,
        trend        = trend_class
      )
    
    }
    
    janp_trend <- janp_ready_trend |>
      filter(!(data_type == "single_visit_0_max" & year < 2021)) |>
      filter(ecoregion %in% c("Montane", "Upper Subalpine", "Lower Subalpine"), !grepl('COTTONWOOD|MUSHROOM', location), !year == 2012) |>
      mutate(ecoregion = "Montane") |>
      mutate(year = year(recording_date_time), 
             hour = hour(recording_date_time),
             julian = yday(recording_date_time)) |>
      dplyr::select(organization, project_id, longitude, latitude, location,
                    location_id, task_id, ecoregion, landcover, prop_cover,
                    VEGETATION_DENSITY, temperature, wind, canopy_species, canopy_cover, avg_height, recording_date_time, observer, species_code,
                    individual_order, abundance, detection_time) |>
      distinct() |>
      wt_tidy_species(remove = c("mammal","amphibian","abiotic","insect","human","unknown"), zerofill = T)
    
    base_zero <- janp_trend |>
      dplyr::select(location, ecoregion, landcover, prop_cover, VEGETATION_DENSITY, temperature, wind, canopy_species, canopy_cover, avg_height, recording_date_time, observer) |>
      distinct()
    
    spp_max <- janp_trend |>
      filter(species_code == spp) |>
      group_by(location, ecoregion, landcover, prop_cover, VEGETATION_DENSITY, temperature, wind, canopy_species, canopy_cover, avg_height, recording_date_time, observer, species_code) |>
      summarise(individual_order = max(individual_order, na.rm = TRUE)) |>
      ungroup()
    
    if (nrow(spp_max |> filter(species_code == spp)) < 20) {
      warning(paste0("Probably an error in Montane with ", spp))
      
      trend_result_montane <- tibble(
        ecoregion = "Montane",
        tau          = NA,
        p_value      = NA,
        sen_slope    = NA,
        pct_change   = NA,
        trend        = NA)
      
      lamba_year_montane <- tibble(
        year = NA,
        lambda_hat = NA
      )
      
      lambda_year_montane_plot <- tibble(
        year = NA,
        location = NA,
        ecoregion = NA,
        lambda_hat = NA
      )
      
    } else {
      
      jpt <- base_zero |> 
        left_join(spp_max, by = c("location", "ecoregion", "landcover", "prop_cover", "VEGETATION_DENSITY", "temperature", "wind", "canopy_species", "canopy_cover", "avg_height", "recording_date_time", "observer")) |>
        mutate(individual_order = tidyr::replace_na(individual_order, 0)) |> mutate(year = year(recording_date_time), hour = hour(recording_date_time), julian = yday(recording_date_time)) |>
        filter(!is.infinite(individual_order)) |> 
        mutate(canopy_species = factor(canopy_species), lc_group = case_when(landcover %in% c("Tree Coniferous", "Shrub Low", "Herbaceous Mixed", "Bedrock") ~ landcover, TRUE ~ "Other"), .after = landcover) |> 
        dplyr::select(-c(landcover, VEGETATION_DENSITY)) |> group_by(location, ecoregion, temperature, wind, canopy_species, canopy_cover, avg_height, recording_date_time, observer, individual_order, year, hour, julian) |>
        pivot_wider(names_from = lc_group, values_from = prop_cover, values_fill = 0, values_fn = sum) |> 
        ungroup() |> 
        rename(shrub = `Shrub Low`, conf = `Tree Coniferous`, herb = `Herbaceous Mixed`, other = Other) |> 
        mutate(across(c(shrub, conf, herb, other, canopy_cover, avg_height, julian, hour, temperature, wind), scale)) |> 
        distinct()

      fit <- svabu(individual_order ~ year + shrub + herb + conf + canopy_cover + avg_height | julian + hour + observer + canopy_cover + avg_height + temperature + wind, data = jpt)
      
      ref_zero_infl <- jpt |>
          summarise(
          observer = first(observer),  # factor
          julian   = mean(julian, na.rm = TRUE),
          hour     = mean(hour, na.rm = TRUE),
          canopy_cover = mean(canopy_cover, na.rm = TRUE),
          avg_height   = mean(avg_height, na.rm = TRUE),
          temperature = first(temperature),
          wind = first(wind))
      
      newdata <- jpt %>%
          mutate(observer     = ref_zero_infl$observer,
                 julian       = ref_zero_infl$julian,
                 canopy_cover = ref_zero_infl$canopy_cover,
                 avg_height   = ref_zero_infl$avg_height,
                 hour         = ref_zero_infl$hour,
                 temperature = ref_zero_infl$temperature,
                 wind = ref_zero_infl$wind)
      
      jpt$lambda_hat <- predict(fit, newdata = newdata, type = "response")

      lambda_year_montane <- jpt |>
          group_by(year) |>
          summarise(lambda_hat = mean(lambda_hat, na.rm = TRUE)) |>
          ungroup() |>
          arrange(year)
      
      lambda_year_montane_plot <- jpt |> dplyr::select(year, location, ecoregion, lambda_hat) |> distinct() |> arrange(year)
      
      x <- lambda_year_montane$lambda_hat
        mk <- mmkh(x)
        tau       <- mk[6]
        sen_slope <- mk[7]
        p_value   <- mk[2]
        pct_change <- mk[["Sen's slope"]] / mean(x) * 100
        trend_class <- dplyr::case_when(pct_change >  2.5  ~ "Increasing",
                                    pct_change < -2.5  ~ "Decreasing",
                                    TRUE               ~ "Stable")
    
      trend_result_montane <- tibble(
        ecoregion = "Montane",
        tau          = tau,
        p_value      = p_value,
        sen_slope    = sen_slope,
        pct_change   = pct_change,
        trend        = trend_class)
      
    }
    
    return(list(bind_rows(trend_result_alpine, trend_result_montane), bind_rows(lambda_year_alpine, lambda_year_montane), bind_rows(lambda_year_alpine_plot, lambda_year_montane_plot)))
    
}

```

```{r}
#| warning: false
#| echo: false
#| eval: false
#| message: false
#| include: true
#| results: hide
#| code-fold: true

safe_run_trend <- possibly(run_trend, otherwise = NA)

trendz <- janp_main |>
  group_by(species_code) |>
  tally() |>
  arrange(-n) |>
  filter(!(species_code %in% c("RESQ","NONE")),
         !grepl('^UN',species_code)) |>
  filter(!n<20) |>
  slice(1:70) |>
  mutate(trend = map(species_code, run_trend))

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| code-fold: true

socb <- read_csv("species-status.csv") |>
  select(1:2) |>
  distinct() |>
  rename(species = 1,
         trend_status_socb = 2) |>
  drop_na() |>
  slice(-1)

trend_table <- trendz %>%
  mutate(trend = map(trend, ~ if(!is.list(.x)) {list(NA)} else {.x})) %>%
  mutate(trend = map(trend, 1)) %>%
  unnest_wider(trend, names_sep = "_") %>%
  unnest(cols = everything()) %>%
  mutate(across(where(is.numeric), ~ round(.x, 2))) %>%
  left_join(wt_get_species() |> select(species_code, species_common_name), by = "species_code") |>
  left_join(socb, by = c("species_common_name" = "species"))

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| code-fold: true

plot_dat <- trendz |>
  mutate(t = map_chr(trend, ~ class(.x))) |>
  filter(!(t == "logical")) |>
  mutate(trend_summary = map(trend, ~ .x[[3]])) |>
  unnest_longer(trend_summary) |>
  unnest() |>
  dplyr::select(species_code, year, location, ecoregion, lambda_hat) |>
  distinct() |>
  mutate(ecoregion = case_when(location == "WILCOX-5" ~ "Alpine", TRUE ~ ecoregion))

ggplot(plot_dat, aes(x = year, y = lambda_hat, color = ecoregion)) +
  geom_smooth() +
  facet_wrap(~ species_code, scales = "free_y") +
  theme_bw() +
  scale_colour_viridis_d(option = "cividis") + 
  ylim(0,2) +
  ylab(expression("Detection-corrected abundance ("*hat(lambda)*")")) +
  xlab("Year")

datatable(trend_table)

```

```{r}
#| warning: false
#| echo: false
#| eval: true
#| message: false
#| include: true
#| code-fold: true

trend_guild <- trend_table |>
  inner_join(guilds, by = "species_code") |>
  drop_na(trend_ecoregion)
  
kable(trend_guild |>
  group_by(trend_ecoregion) |>
  summarise(
    total_species = n_distinct(species_code),
    declining_species = n_distinct(species_code[pct_change <= -2.5]),
    percent_declining = declining_species / total_species * 100
  ))

kable(trend_guild |>
  group_by(trend_ecoregion, habitat_guild) |>   # or another guild column if desired
  summarise(
    total_guild_species = n_distinct(species_code),
    declining_guild_species = n_distinct(species_code[pct_change <= -2.5]),
    percent_declining = declining_guild_species / total_guild_species * 100
  ) |>
  ungroup() |>
  group_by(trend_ecoregion) |>
  summarise(
    total_guilds = n_distinct(habitat_guild),
    guilds_with_decline = sum(percent_declining > 0),
    percent_guilds_declining = guilds_with_decline / total_guilds * 100
  ))

```

```{r}

plot_sum <- plot_dat %>%
  arrange(desc(pct_change)) %>%
  mutate(species_code = factor(species_code, levels = unique(species_code)))

ggplot(plot_sum, aes(x = pct_change, y = species_code)) +
  geom_point() +
  facet_wrap(~ ecoregion) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  theme_bw()
```

# Discussion and recommendations

